<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【软件工程学习】 第二章 可行性研究</title>
      <link href="/2025/10/15/25-10-15-2-SoftEng-feasibility/"/>
      <url>/2025/10/15/25-10-15-2-SoftEng-feasibility/</url>
      
        <content type="html"><![CDATA[<h2 id="一、系统流程图"><a href="#一、系统流程图" class="headerlink" title="一、系统流程图"></a>一、系统流程图</h2><p>系统流程图是概括地描绘物理系统的传统工具。</p><ol><li><p><strong>符号</strong><br><img src="/image/25-10-15-2-SoftEng-feasibility/1760535042549.jpg" alt="1760535042549"></p></li><li><p><strong>示例</strong><br><img src="image/25-10-15-2-SoftEng-feasibility/1760535248917.png" alt="1760535248917"></p></li></ol><h2 id="二、数据流图"><a href="#二、数据流图" class="headerlink" title="二、数据流图"></a>二、数据流图</h2><p>数据流图是一种图形化技术，它描绘信息流和数据从输入移动到输出所经受的变换。</p><ol><li><p><strong>符号</strong><br><img src="/image/25-10-15-2-SoftEng-feasibility/1760535093939.jpg" alt="1760535093939"></p></li><li><p><strong>示例</strong><br><img src="image/25-10-15-2-SoftEng-feasibility/1760535276159.png" alt="1760535276159"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【软件工程学习】 第一章 软件工程概述</title>
      <link href="/2025/10/15/25-10-15-1-SoftEng-intro/"/>
      <url>/2025/10/15/25-10-15-1-SoftEng-intro/</url>
      
        <content type="html"><![CDATA[<h2 id="一、软件工程的价值与应用场景"><a href="#一、软件工程的价值与应用场景" class="headerlink" title="一、软件工程的价值与应用场景"></a>一、软件工程的价值与应用场景</h2><ol><li><strong>实际用途</strong>：<ul><li>国家考试（如软考）、工作面试（如亚麻面试）、毕业设计、读研。</li><li>参与需求分析、撰写需求/设计报告、招标书/投标书、项目申请书。</li><li>开发原型（需掌握原型工具）、开发软件（需学习开发框架）。</li><li>绘制模型图/流程图、AI开发APP等。</li></ul></li><li><strong>工作场景</strong>：<ul><li>文档撰写、模型设计、原型开发、前后端分离开发、系统设计等。</li></ul></li></ol><h2 id="二、软件工程学科与教材分析"><a href="#二、软件工程学科与教材分析" class="headerlink" title="二、软件工程学科与教材分析"></a>二、软件工程学科与教材分析</h2><ol><li><strong>经典教材</strong>：<ul><li>《Software Engineering: A Practitioner’s Approach》（2020年）：涵盖软件过程、建模、质量、项目管理等。</li><li>《软件工程导论》（2013年）：传统生命周期与面向对象方法。</li><li>《面向对象软件工程：敏捷统一方法》（2014/2023年）：强调领域建模、架构设计、交互建模等。</li><li>《软件工程：谷歌的实践》（2022年）：聚焦文化、流程、工具（如代码评审、CI/CD）。</li></ul></li><li><strong>学科演变</strong>：<ul><li>从传统软件工程→面向对象→敏捷开发→系统工程。</li><li>新趋势：低代码、AI开发、产品化（从Project到Product）。</li></ul></li></ol><h2 id="三、软件工程核心内容"><a href="#三、软件工程核心内容" class="headerlink" title="三、软件工程核心内容"></a>三、软件工程核心内容</h2><ol><li><strong>关键主题</strong>：<ul><li><strong>需求分析</strong>：用户故事、用例建模、领域模型。</li><li><strong>设计</strong>：架构设计、OOD（如亚麻面试）、设计模式、UI/UX。</li><li><strong>实现</strong>：前后端分离、组件化、框架化（如Vue+Node.js）。</li><li><strong>测试与维护</strong>：单元测试、持续集成/交付（CI/CD）。</li><li><strong>项目管理</strong>：风险管理、配置管理、团队协作。</li></ul></li><li><strong>工具与技术</strong>：<ul><li>原型工具（如Axure）、版本控制（Git）、低代码平台、AI开发工具。</li></ul></li></ol><h2 id="四、软件工程的新发展与挑战"><a href="#四、软件工程的新发展与挑战" class="headerlink" title="四、软件工程的新发展与挑战"></a>四、软件工程的新发展与挑战</h2><ol><li><strong>新趋势</strong>：<ul><li><strong>产品化</strong>：从定制开发转向标准化产品（产品经理角色凸显）。</li><li><strong>AI与低代码</strong>：AI辅助开发、低代码平台降低开发门槛。</li><li><strong>系统工程</strong>：重视整体设计（如北美系统设计面试）。</li></ul></li><li><strong>行业困境</strong>：<ul><li>软件工程与开发框架脱节，部分高校停招软件工程专业。</li><li>需平衡理论（如建模、文档）与实践（如框架、工具）。</li></ul></li></ol><h2 id="五、学习建议"><a href="#五、学习建议" class="headerlink" title="五、学习建议"></a>五、学习建议</h2><ol><li><strong>核心技能</strong>：<ul><li>掌握软件建模（UML）、文档撰写、原型工具。</li><li>学习前后端框架（如Vue、Node.js）或低代码开发。</li><li>熟悉开源软件、AI开发工具。</li></ul></li><li><strong>实践方向</strong>：<ul><li>开发小型项目（如班级管理系统、微信小程序）。</li><li>参与需求分析、设计、测试全流程。</li></ul></li></ol><h2 id="六、案例与工具展示"><a href="#六、案例与工具展示" class="headerlink" title="六、案例与工具展示"></a>六、案例与工具展示</h2><ol><li><strong>项目案例</strong>：<ul><li>校园日历、课堂抽问程序、班级积分系统等（结合Vue+Node.js、MVC等）。</li></ul></li><li><strong>工具应用</strong>：<ul><li>Git/GitHub版本管理、Axure原型设计、AI辅助开发。</li></ul></li></ol><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>软件工程是连接理论与实践的桥梁，需结合传统方法（如需求分析、设计）与新技术（如AI、低代码）。学习重点应放在建模能力、工具使用、框架实践及行业趋势适应上，同时关注团队协作与项目管理。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 介绍 </tag>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【计算机组成原理学习】 第三章 指令系统</title>
      <link href="/2025/10/15/25-10-14-3-CompOrg-command-system/"/>
      <url>/2025/10/15/25-10-14-3-CompOrg-command-system/</url>
      
        <content type="html"><![CDATA[<h2 id="第三章-指令系统"><a href="#第三章-指令系统" class="headerlink" title="第三章 指令系统"></a>第三章 指令系统</h2><h3 id="3-1-指令格式"><a href="#3-1-指令格式" class="headerlink" title="3.1 指令格式"></a>3.1 指令格式</h3><ol><li><p><strong>基本格式</strong><br>|  |  |<br>| —- | —- |<br>| 操作码字段 | 地址码字段 |</p></li><li><p><strong>地址码结构</strong><br>对于一般的双操作数运算指令，除去<strong>操作码（Operation Code）</strong>，还包含  </p><ul><li>第一操作数地址 $A_1$，</li><li>第二操作数地址 $A_2$，</li><li>操作结果存放地址 $A_3$，</li><li>下一条指令地址 $A_4$。</li></ul></li><li><p><strong>指令结构</strong>  </p><ul><li><p><strong>四地址指令</strong>  </p><ul><li>含义：$(A_1) OP (A_2) \rightarrow A_3$</li><li>直观，但太长，不实际。</li></ul></li><li><p><strong>三地址指令</strong>  </p><ul><li>含义：$(A_1) OP (A_2) \rightarrow A_3$，$(PC) + 1 \rightarrow PC$</li><li>每执行一条指令，<strong>程序计数器（PC）</strong> 自增。</li><li>仍然较长，在大、中型计算机使用。</li><li>适用于向量、矩阵运算。</li></ul></li><li><p><strong>二地址指令</strong>  </p><ul><li>含义：$(A_1) OP (A_2) \rightarrow A_1$，$\rm (PC) + 1 \rightarrow PC$</li><li>$A_1$ 为<strong>目的操作数地址</strong>，$A_2$为<strong>源操作数地址</strong>。$A_1$中原内容会被破坏。</li><li>至少需要访问<strong>四次主存</strong>。</li></ul></li><li><p><strong>一地址指令</strong>  </p><ul><li>含义：$(Acc) OP (A_1) \rightarrow Acc$，$(PC) + 1 \rightarrow PC$</li><li>另一个操作数在<strong>累加寄存器（Accumulator）</strong> 中，操作结果也存入累加寄存器，用于累加操作、连续运算。</li><li>只需访问<strong>两次</strong>主存。</li></ul></li><li><p><strong>零地址指令</strong>  </p><ul><li>只有操作码，没有地址码。</li><li>操作数从堆栈顶部<strong>弹出</strong>，结果<strong>压入</strong>堆栈。  </li><li>用于<strong>嵌套、递归</strong>。</li></ul><blockquote><p><strong>堆（Heap）</strong> 是程序运行时用于动态分配内存的一块区域。与栈不同，堆的内存分配和释放通常由程序员手动控制（如C/C++中的<code>malloc</code>/<code>free</code>），或者由垃圾回收机制自动管理（如Java、Python）。堆空间较大，但分配和释放效率较低，且容易出现内存碎片。<br><strong>栈（Stack）</strong> 是程序运行时自动分配和释放的内存区域，主要用于存放函数的参数、局部变量等。栈由系统自动管理，内存连续，分配和释放速度快，但容量有限。栈的操作方式类似于数据结构中的栈，即“先进后出”。<br><strong>堆栈</strong>通常指“栈”，尤其是在底层和系统编程中；少数情况下也可指“堆和栈”的总称。</p></blockquote></li><li><p><strong>规律</strong><br>地址数越少：</p><ul><li>程序越<strong>长</strong>。</li><li>程序存储量<strong>越小</strong>。</li><li>执行速度<strong>越低</strong>。</li></ul></li></ul></li><li><p><strong>操作码编码</strong>  </p><ul><li><p><strong>规整型（定长）编码</strong><br>操作码位数、位置固定。设系统共有 $m$ 条指令，$N$ 位操作码字段，则  </p><script type="math/tex; mode=display">m \leq 2^N \\N \geq \log_2m</script><p>可简化硬件设计，减少编译时间，用于字长较长的大、中型计算机与超级小型计算机。</p></li><li><p><strong>非规整型（变长）编码</strong><br>操作码位数不固定，分散放在指令字不同位置上。压缩指令操作码字段平均长度。  </p><ul><li><strong>扩展操作码法</strong><br>使操作数多的指令操作码字段长尽量短，操作数少的指令操作码字段长尽量长。<br>要求：<ul><li>不允许短码是长码的前缀。</li><li>操作码不能重复。</li></ul></li></ul></li></ul></li></ol><h3 id="3-2-寻址技术"><a href="#3-2-寻址技术" class="headerlink" title="3.2 寻址技术"></a>3.2 寻址技术</h3><p>寻找操作数的地址或下一条指令的地址，包括编址方式和寻址方式。</p><ol><li><p><strong>编址方式</strong><br>对各种存储设备进行编码的方式。</p><ul><li><p><strong>编址单位</strong>  </p><ul><li>字编址：编址单位与访问单位相一致。</li><li>字节编址：编址单位与一字节相一致。字节编址方式存在地址信息浪费。</li><li>位编址：浪费更大。</li></ul></li><li><p><strong>位数</strong>  </p><ul><li>与<strong>主存容量</strong>和<strong>编址单位</strong>有关。</li></ul></li></ul></li><li><p><strong>寻址方式</strong></p><ul><li>指令寻址、数据寻址。</li><li>顺序寻址、跳跃寻址。</li></ul></li><li><p><strong>数据寻址</strong><br>根据地址码寻找真实操作数地址。</p><ul><li><p><strong>立即寻址</strong>  </p><ul><li>指令中世界存放操作数本身，这样的数称为<strong>立即数</strong>。</li><li>操作数不能被修改，长度受指令长度限制，用于赋初值或提供常数。</li></ul></li><li><p><strong>寄存器寻址</strong>  </p><ul><li>给出某通用寄存器编号 $R_i$，寄存器中为操作数。$S = (R_i)$。</li><li>速度快，地址码字段短，几乎所用计算机都使用。</li></ul></li><li><p><strong>直接寻址</strong>  </p><ul><li>地址码 $A$ 即为操作数有效地址形式地址等于有效地址，$EA = A$，$S = (A)$。</li><li>不需寻址运算，简单，便于硬件实现，但地址空间受地址码字段位数限制。</li></ul></li><li><p><strong>间接寻址</strong>  </p><ul><li>地址码为主存中存储操作数的单元的地址。指令中划出标明直接（$@ = 0$）或间接（$@ = 1$）寻址的标志位。$EA = (A)$，$S = ((A))$。</li><li>分为一级间接寻址与多级间接寻址。</li></ul></li><li><p><strong>寄存器间接寻址</strong>  </p><ul><li>通用寄存器给出主存中存储操作数的单元的地址。$S = ((R_i))$。</li><li>指令较短，只需一次访存。</li></ul></li><li><p><strong>变址寻址</strong>  </p><ul><li>将编址寄存器 $R_x$ 内容与地址码 $A$ 相加得到有效地址，$EA = ((R_x) + A)$。</li><li>频繁修改地址时只需修改变址值，用于成批数据处理。</li></ul></li><li><p><strong>基址寻址</strong>  </p><ul><li>将基址寄存器 $R_x$ 内容与指令中位移量 $D$ 相加得到有效地址，$EA = (R_b) + D$，$S = ((R_b) + D)$。</li><li>将用户编程时的逻辑地址转化位物理地址。</li><li>区别<br>|  |  |<br>| —- | —- |<br>| 变址寻址 | 变址寻址是面向用户的，用于访问字符串、向量和数组等成批数据 |<br>| 基址寻址 | 基址寻址面向系统，主要用于逻辑地址和物理地址的变换，用以解决程序在主存中的再定位和扩大寻址空间等向题 |</li></ul></li><li><p><strong>相对寻址</strong>  </p><ul><li>由程序计数器提供基准地址，指令中地址码作为位移量 $D$。$EA = (PC) + D$。</li></ul></li><li><p><strong>页面寻址</strong>  </p><ul><li>将整个主存空间分成若干大小相同的区，每个区成为一页。</li><li>分类<br>|  |  |<br>| — | —- |<br>| 基页（零页寻址） | $EA = 0 // A$，操作数在零页面中。|<br>| 当前页寻址 | 页面地址为程序计数器高位内容，$EA = (PC)_H // A$。<br>| 页寄存器地址 | 页寄存器提供页面地址。 |</li><li>寻址方式标识<center><img src="/image/Summaries/1758960780042.png" width = "300" height = "207" alt="移码和真值的映射" align=center /></center></li></ul></li></ul></li><li><p><strong>变型或组合寻址方式</strong>  </p><ul><li><p><strong>自增型寄存器间址和自减型寄存器间址</strong>  </p><ul><li>自增寻址时，寄存器 $R_i$ 内容为有效地址，$EA = (R_i), R \leftarrow (R_i) + d$。$d$ 为修改量，记作$(R_i)+$，表示先操作后修改。</li><li>自减寻址时，$R_i \leftarrow (R_i) - d, EA = (R_i)$，记作 $-(R_i)$，表示先修改后操作。</li></ul></li><li><p><strong>扩展变址方式</strong>  </p><ul><li><strong>前变址寻址方式</strong><br>$EA = ((R_x) + A), S = (((R_x) + A))$。</li><li><strong>后变址寻址方式</strong><br>$EA = (R_x) + (A), S = ((R_x) + (A))$。</li><li><strong>基址变址寻址</strong><br>基址寄存器 $R_b$，变址寄存器 $R_x$，位移量 $D$，$EA = (R_b) + (R_x) + D$。</li></ul></li></ul></li></ol><h3 id="3-3-堆栈与堆栈操作"><a href="#3-3-堆栈与堆栈操作" class="headerlink" title="3.3 堆栈与堆栈操作"></a>3.3 堆栈与堆栈操作</h3><ol><li><p><strong>寄存器堆栈</strong><br>用一组专门的寄存器构成的堆栈，也称<strong>硬堆栈</strong>。具有自动推移功能。栈顶位置固定，无栈顶指针。</p></li><li><p><strong>存储器堆栈</strong><br>从主存中划出一段区域作为堆栈，也称<strong>软堆栈</strong>。栈底固定，需要专门的硬件寄存器作为栈顶指针（SP）。</p><ul><li>自底向上生成堆栈</li><li>自顶向下生成堆栈</li></ul></li><li><p><strong>堆栈操作</strong>  </p></li></ol><h3 id="3-4-指令类型"><a href="#3-4-指令类型" class="headerlink" title="3.4 指令类型"></a>3.4 指令类型</h3><ol><li><p><strong>数据传送类指令</strong>  </p><ul><li><p><strong>一般传送指令 MOV</strong><br>数据从源地址传送到目的地址，而源地址不变</p></li><li><p><strong>堆栈操作指令 PUSH，POP</strong>  </p></li><li><p><strong>数据交换指令</strong>  </p></li></ul></li><li><p><strong>运算类指令</strong>  </p><ul><li><p><strong>算数运算类指令</strong></p></li><li><p><strong>逻辑运算类指令</strong></p><ul><li><strong>按位测（位检查）</strong>  </li><li><strong>按位清（位清除）</strong>  </li><li><strong>按位置（位设置）</strong></li><li><strong>按位修改</strong>  </li><li><strong>判符合</strong></li></ul></li></ul></li><li><p><strong>移位类指令</strong>  </p><ul><li><strong>算数移位</strong></li><li><strong>逻辑移位</strong></li><li><strong>循环移位</strong></li></ul></li><li><p><strong>程序控制类指令</strong>  </p><ul><li><strong>转移指令</strong>  </li><li><strong>子程序调用指令</strong> </li></ul></li><li><p><strong>输入输出类指令</strong>  </p><ul><li><strong>独立编址的 I/O 指令</strong></li><li><strong>统一编址的 I/O 指令</strong></li></ul></li><li><p><strong>80x86 指令系统举例</strong></p><ul><li>MOV</li><li>PUSH/POP</li><li>加减、比较</li><li>乘除</li><li>BCD、ASCII 运算</li><li>基本逻辑指令</li><li>位测试指令</li><li>移位与循环指令</li><li>转移控制指令</li><li>子程序调用与返回指令</li><li>输入输出指令</li></ul></li></ol><h3 id="3-5-指令系统的发展"><a href="#3-5-指令系统的发展" class="headerlink" title="3.5 指令系统的发展"></a>3.5 指令系统的发展</h3><ol><li><p><strong>x86 架构的扩展指令集</strong>  </p><ul><li>MMX（Multi Media eXtension）</li><li>SSE（Streaming SIMD Extension）</li><li>3DNow</li><li>SSE2</li><li>SSE3</li><li>SSE4</li><li>SSE5</li><li>AVX（Advanced Vector eXtension）</li><li>FMA（Fused Multiply Accumulate）</li></ul></li><li><p><strong>从复杂指令系统道精简指令系统</strong></p></li><li><p><strong>VLIW（Very Long Instruction Word） 和 EPIC（Explicit Parallel Instruction Code）</strong></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【计算机组成原理学习】 第二章 数据的机器层次表示</title>
      <link href="/2025/10/15/25-10-14-2-CompOrg-data-represent/"/>
      <url>/2025/10/15/25-10-14-2-CompOrg-data-represent/</url>
      
        <content type="html"><![CDATA[<h2 id="第二章-数据的机器层次表示"><a href="#第二章-数据的机器层次表示" class="headerlink" title="第二章 数据的机器层次表示"></a>第二章 数据的机器层次表示</h2><h3 id="2-1-数值数据的表示"><a href="#2-1-数值数据的表示" class="headerlink" title="2.1 数值数据的表示"></a>2.1 数值数据的表示</h3><ol><li><p><strong>无符号数</strong><br>整个机器字长全部二进制位位数值位。<br>范围$[0, 2^n - 1]$。</p></li><li><p><strong>原码</strong><br>将最高位设为符号位，其余位数值位，与真值相同。<br>其中，$[+0]<em>原 = 00000$，$[-0]</em>原 = 10000$。<br>原码实现乘除简单，实现加减复杂。<br>范围$[-(2^{n - 1} - 1), 2^{n - 1} - 1]$。</p></li><li><p><strong>补码</strong><br>正数补码与原码相同，负数补码为真值数值按位取反，在最低位加 1。<br>其中，$[+0]<em>补 = [-0]</em>补 = 00000$。<br>范围$[-2^{n - 1}, 2^{n - 1} - 1]$。</p></li><li><p><strong>反码</strong><br>正数反码与原码相同，负数补码为真值数值按位取反。<br>其中，$[+0]<em>原 = 00000$，$[-0]</em>原 = 11111$。<br>范围$[-(2^{n - 1} - 1), 2^{n - 1} - 1]$。</p></li></ol><h3 id="2-2-机器数的定点表示与浮点表示"><a href="#2-2-机器数的定点表示与浮点表示" class="headerlink" title="2.2 机器数的定点表示与浮点表示"></a>2.2 机器数的定点表示与浮点表示</h3><ol><li><p><strong>定点小数</strong><br>即纯小数（$-1 &lt; x &lt; 1$），小数点位置固定，整数位被取代为符号位。设机器字长$n + 1$位，原码、反码范围$[-(1 - 2^{-n}), 1 - 2^{-n}]$，补码$[-1, 1 - 2^{-n}]$。</p></li><li><p><strong>定点整数</strong><br>纯整数（$\mathbb{Z}$），小数点位置固定。</p></li><li><p><strong>浮点数</strong><br>浮点数$N$为  </p><script type="math/tex; mode=display">N = M \cdot r^E</script><p>$E$为<strong>阶码（Exponent）</strong>，M为<strong>尾数（Mantissa）</strong>，$r$为阶码的<strong>底</strong>，暂取$r = 2$。    </p><center><img src="/image/Summaries/1757250188210.png" width = "300" height = "130" alt="兼容性示意" align=center /></center></li><li><p><strong>规格化浮点数</strong><br>为充分利用尾数有效位，规定规格化浮点数尾数最高位必须有效，即  </p><script type="math/tex; mode=display">|M| \in [\frac{1}{r}, 1)</script><blockquote><p>$\frac{1}{2}$的原码为规格化数，补码不是；$-1$无法用原码表示，补码为规格化数。</p></blockquote><p>浮点数典型值<br><img src="/image/Summaries/1757676990902.png" alt="1757676990902"></p></li><li><p><strong>浮点数阶码的移码表示法</strong>  </p><ul><li>移码<br>移码可将带符号数映射到正数域。<script type="math/tex; mode=display">[X]_移 = X + 偏置值</script>设补码长度为$n$位，偏置值则为$2^n$，即  <center><img src="/image/Summaries/1757677423598.png" width = "300" height = "165" alt="移码和真值的映射" align=center /></center></li><li>移码的性质  <ul><li>最高位为$0$表示复数，最高位为$1$表示正数。</li><li>$[+0]<em>移 = [-0]</em>移 = 10000000$</li><li>可将移码视为无符号数，直接按无符号数规则比较大小。</li><li>将某数的补码最高位取反即可得移码。</li></ul></li><li>作用  <ul><li>便于比较浮点数大小。</li><li>简化判零电路。</li></ul></li></ul></li><li><p><strong>尾数基数$r$</strong>  </p><ul><li>尾数基数可影响  <ul><li>可表示数得范围。</li><li>数在数轴上的分布。</li><li>可表示数的精度。</li><li>运算的精度损失</li></ul></li></ul></li><li><p><strong>IEEE 754 标准浮点数</strong></p><ul><li>格式<br><img src="/image/Summaries/1757678303857.png" alt="1757678303857">  </li><li>三种浮点数<br><img src="/image/Summaries/1757678382268.png" alt="1757678382268"><br>注意，偏置值为$2^{n - 1} - 1$，$n$为阶码长度。<br>对于规格化的二进制浮点数，最高数值位总是$1$，可隐含尾数数值长度实际为$24$、$53$、$65$位。</li></ul></li><li><p><strong>IEEE 754 标准浮点数（十六进制写法）与十进制数的互相转化</strong>  </p><ul><li>将十进制数转为短浮点数  <ul><li>把十进制数转换为二进制数（非标准）。  </li><li>规格化。  </li><li>计算阶码的移码（偏置值 + 阶码真值）。</li><li>以尾数符号、阶码移码、<strong>尾数数值（去除需隐含的位）</strong> 的顺序拼接二进制数。  </li><li>四位为一组，写出十六进制数。</li></ul></li><li>将短浮点数转为十六进制数  <ul><li>将十六进制数写为二进制数，分离出尾数符号、阶码移码、<strong>尾数数值（无需隐含的位）</strong>。</li><li>计算阶码真值。</li><li>写出规格化二进制数（<strong>原隐含位与尾数数值合并</strong>）。</li><li>非规格化（尾数与乘方合并，即移位）。</li><li>转换位十进制数。</li><li>加上符号。</li></ul></li></ul><p>IEEE 754 短浮点数与规格化浮点数$v$的关系  </p><script type="math/tex; mode=display">v = (-1)^S \cdot (1.f) \cdot 2^{E - 127}</script><p>$S$为符号位，$E$为移码阶码，$f$为尾数小数部分。</p></li><li><p><strong>定点、浮点表示法与定点、浮点计算机</strong>  </p><ul><li>定点、浮点表示法的区别<br>|  | 定点表示法 | 浮点表示法 |<br>| —- | —- | —- |<br>| 数值范围 | 小，分布均匀 | 大，越靠近原点越密集 |<br>| 精度（等字长） | 高 | 低 |<br>| 运算 | 简单 | 复杂 |<br>| 溢出处理 | 超出表示范围一定溢出 | 超出尾数范围不一定溢出，阶码范围也超出时才溢出 |</li><li>定点机与浮点机  <ul><li>定点机：所有操作均为定点数，浮点运算需借助软件子程序。</li><li>定点机 + 浮点运算部件</li><li>浮点机：具有浮点运算指令与基本浮点运算器。</li></ul></li></ul></li></ol><h3 id="2-3-非数值数据的表示"><a href="#2-3-非数值数据的表示" class="headerlink" title="2.3 非数值数据的表示"></a>2.3 非数值数据的表示</h3><ol><li><p><strong>字符、字符串的表示</strong>  </p><ul><li>ASCII：7 位二进制。</li><li>存放  <ul><li>向量存放法：最简单、最节省空间。</li><li>串表法：链表形式，但主存利用率下降。</li></ul></li></ul></li><li><p><strong>汉字编码</strong></p><ul><li>GB 2312—80（国标码）：两个字节，用低七位编码。</li><li>区位码：区号—位号（十六进制）。关系<script type="math/tex; mode=display">国标码 = 区位码（十六进制）+ 2020\rm H</script></li><li>机内码：处理中西文兼容。<script type="math/tex; mode=display">机内码 = 国标码 + 8080\rm H</script></li><li>字形码：汉字点阵中，笔画索道之处记为$1$。</li></ul></li><li><p><strong>统一代码（Unicode）</strong>  </p></li></ol><h3 id="2-4-十进制数与数串的表示"><a href="#2-4-十进制数与数串的表示" class="headerlink" title="2.4 十进制数与数串的表示"></a>2.4 十进制数与数串的表示</h3><ol><li><p><strong>二进制编码的十进制数（Binary Code Decimal，BCD）</strong><br><img src="/image/Summaries/1757683990139.png" alt="1757683990139">  </p><ul><li>8421 码：1010~1111为非法码。</li><li>2421 码<ul><li>对 9 的自补码：自身按位取反得到该数对 9 的补数。</li><li>0101~1010为非法码。</li></ul></li><li>余 3 码：一种无权码，为 8421 码加 0011。</li><li>Gray 码<ul><li>无权码</li><li>相邻两个码只有一位不同。</li><li>首尾两个码也只有一位不同。</li><li>非法码视具体方案而定。</li></ul></li></ul></li><li><p><strong>十进制数串</strong>  </p><ul><li>非压缩的十进制数串<br>即字符串，一个字节存放一个十进制数或符号 ASCII 码。<ul><li>前分隔式数字串：符号位占用单独一个字节，放在数值位之前，正号 ASCII 码为<code>2BH</code>，负号为<code>2DH</code>。</li><li>后嵌入式字符串：正数不变，负数将<code>40H</code>与最低数值位相加，数字 0~9 编码为 <code>70H</code>~<code>79H</code>。<br>非压缩的十进制数串主要用于非数值处理。</li></ul></li><li>压缩的十进制数串<br>一个字节存放两位 BCD 码表示的十进制数，一个压缩的十进制数串占用连续的多字节，符号位占半字节，存放在最低数值位之后。</li></ul></li></ol><h3 id="2-5-不同类型的数据表示举例"><a href="#2-5-不同类型的数据表示举例" class="headerlink" title="2.5 不同类型的数据表示举例"></a>2.5 不同类型的数据表示举例</h3><ol><li><strong>C 语言</strong>  </li><li><strong>现代微型计算机系统中的数据表示</strong></li></ol><h3 id="2-6-数据校验码"><a href="#2-6-数据校验码" class="headerlink" title="2.6 数据校验码"></a>2.6 数据校验码</h3><ol><li><p><strong>奇偶校验</strong>  </p><ul><li>在有效信息前加一个校验位，得到校验码。</li><li>校验位将使校验码中1的个数位奇数（奇校验）或偶数（偶校验）。奇校验不存在全 0 代码，使用更多</li><li>校验出错时，表明一定有错，但不知何处出错。</li></ul></li><li><p><strong>交叉奇偶校验</strong><br>不仅每一个字节有奇偶校验，全部字节同一位也设置一个奇偶校验位置做纵向校验。可以发现两位同时出错的情况。</p></li><li><p><strong>汉明（Hamming）校验码</strong><br>在有效信息位中插入几个校验位形成汉明码，使码距较均匀地拉大，并把每一个二进制位分配到几个就校验组中。某一位出错时可引起几个校验位地值发生变化。</p></li><li><p><strong>循环冗余校验码（Cyclic Redundancy Check, CRC）</strong>  </p><center><img src="/image/Summaries/1757750927649.png" width = "300" height = "168" alt="移码和真值的映射" align=center /></center>  <ul><li>把带编码的$N$位有效信息表示为多项式$M(X)$。</li><li>将$M(X)$左移$K$位得$M(X) \cdot X^K$，再用另一个约定得多项式$G(X)$（$K + 1$位）去除，得到余数$R(X)$，与有效位拼接后得到CRC。</li><li>余数与出错位序号之间有唯一关系。</li><li>生成多项式的选择  <ul><li>任何一位发生错误都使余数不为$0$。</li><li>不同位发生错误使余数不同。</li><li>对余数做模$2$除法，应使余数循环。</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【计算机组成原理学习】 第一章 概论</title>
      <link href="/2025/10/15/25-10-14-1-CompOrg-intro/"/>
      <url>/2025/10/15/25-10-14-1-CompOrg-intro/</url>
      
        <content type="html"><![CDATA[<h2 id="教材"><a href="#教材" class="headerlink" title="教材"></a>教材</h2><p><a href="http://tup.tsinghua.edu.cn/bookscenter/book_08395002.html">计算机组成原理（第四版） 蒋本珊 清华大学出版社</a></p><h2 id="第一章-概论"><a href="#第一章-概论" class="headerlink" title="第一章 概论"></a>第一章 概论</h2><h3 id="1-1-电子计算机与存储程序控制"><a href="#1-1-电子计算机与存储程序控制" class="headerlink" title="1.1 电子计算机与存储程序控制"></a>1.1 电子计算机与存储程序控制</h3><ol><li><p><strong>存储程序的计算机</strong><br>世界上第一台数字计算机：美国 ENIAC（1946）。<br>早期存储程序控制的计算机：美国 EDVAC（Von Neumann, 1951），英国 EDSAC（1949）。</p></li><li><p><strong>存储程序概念（Von Neumann, 1945）</strong>  </p><ul><li>计算机硬件应由五大基本部件组成。</li><li>计算机内部采用二进制表示指令和数据。</li><li>将程序与原始数据存入存储器中，在启动计算机工作。</li></ul></li></ol><h3 id="1-2-计算机的硬件组成"><a href="#1-2-计算机的硬件组成" class="headerlink" title="1.2 计算机的硬件组成"></a>1.2 计算机的硬件组成</h3><ol><li><p><strong>计算机的主要部件</strong><br>|  |  |<br>| —- | —- |<br>| 输入设备 | 将人们编好的程序和原始数据输送到计算机中，并将其转化为计算机内部所能识别和接受的信息方式的部件 |<br>| 输出设备 | 将计算机的处理结果以人或其他设备所能接收的形式送出计算机的设备 |<br>| 存储器 | 用于存放程序和数据的部件 |<br>| 运算器 | 对信息进行处理和运算的部件，又称算数逻辑运算部件（Arithmetic and Logical Unit, ALU） |<br>| 控制器 | 按照人们预先确定的操作步骤，控制整个计算机各部件有条不紊地自动工作地部件 |</p></li><li><p><strong>计算机各部件的连接</strong></p><ul><li>小微型机的典型结构：总线结构<br>总线（Bus）：一组能为多个部件服务的公共信息传送线路，分时地发送与接收各部件地信息。<br>| 总线 | 结构 | 功能 |<br>| —- | —- | —- |<br>| 地址总线（Address Bus） | 单方向、多根线 | CPU 向主存、外设传输地址 |<br>| 数据总线（Data Bus） | 双方向、多根线 | CPU 向主存、外设读入、送出数据 |<br>| 控制总线（Control Bus） | 双方向、多根线 | CPU 送出控制命令和主存、外设向CPU反馈信号 |</li><li>大、中型计算机的典型结构：通道结构<br>更着重于系统扩大与效率提高。在系统连接上分为四级：主机、通道、设备控制器和外部设备。</li></ul></li><li><p><strong>计算机设计者观察到的计算机硬件系统</strong>  </p><center><img src="/image/Summaries/1757150813397.png" width = "300" height = "388" alt="计算机设计者观察到的计算机硬件系统" align=center /></center></li><li><p><strong>存储器设计思想</strong></p><ul><li><p>冯·诺伊曼（普林斯顿）结构<br>指令和数据不加区别地混合存储在统一存储器中，共享数据总线。<br><center><img src="/image/Summaries/1757154345657.png" width = "300" height = "154" alt="冯·诺伊曼结构" align=center /></center><br>冯·诺伊曼结构不能同时取指令和数据，且易造成总线拥挤。</p></li><li><p>哈佛结构<br>存储分为程序存储器（PM）和数据存储器(DM)。  </p><center><img src="/image/Summaries/1757154663091.png" width = "435" height = "150" alt="冯·诺伊曼结构" align=center /></center>  <blockquote><p>缺点：硬件复杂、空间利用低、不灵活。</p></blockquote></li></ul><p>现在常将高速缓冲器（Cache）采用哈佛结构，主存采用冯·诺伊曼结构。</p></li></ol><h3 id="1-3-计算机系统"><a href="#1-3-计算机系统" class="headerlink" title="1.3 计算机系统"></a>1.3 计算机系统</h3><ol><li><p><strong>硬件与软件的关系</strong><br>软件与硬件没有明确界线。<br>| 做法 | 作用 |<br>| —- | —- |<br>| 硬件软化 | 增强系统的功能和适应性 |<br>| 软件硬化 | 降低软件时间开销 |</p></li><li><p><strong>固件（Firmware, A. Opler, 1967）</strong><br>存储在能永久保存信息的器件（如 ROM）中的<u><b>程序</b></u>,是具有软件功能的硬件。  </p></li><li><p><strong>系列机</strong><br>一个厂家生产的，具有相同系统结构，但具有不同组成和实现的一系列不同型号的机器。</p></li><li><p><strong>软件兼容</strong><br>旧软件能在新机器上使用。<br><center><img src="/image/Summaries/1757156556399.png" width = "300" height = "289" alt="兼容性示意" align=center /></center><br>软件必须保证向后兼容，争取做到向上兼容。</p></li><li><p><strong>计算机系统的多层次结构</strong>  </p><center><img src="/image/Summaries/1757156735992.png" width = "500" height = "530" alt="计算机系统的多层次结构" align=center /></center></li><li><p><strong>实际机器与虚拟机器</strong><br>|  |  |<br>| —- | —- |<br>| 实际机器 | 由硬件和固件实现的机器 |<br>| 虚拟机器 | 只对某级观察者存在，不关心下级工作，以软件为主 |</p></li></ol><h3 id="1-4-计算机的工作过程和主要性能指标"><a href="#1-4-计算机的工作过程和主要性能指标" class="headerlink" title="1.4 计算机的工作过程和主要性能指标"></a>1.4 计算机的工作过程和主要性能指标</h3><ol><li><p><strong>工作过程</strong>  </p><ul><li>将程序读到主存中。</li><li>逐条取出指令执行。</li></ul></li><li><p><strong>性能指标</strong>  </p><ul><li>机器字长<br>参与运算的数的基本位数，一般等于内部寄存器大小。字指“数据字”。  </li><li>数据通路宽度<br>数据总线一次能并行传送信息的位数。</li><li>主存容量  </li><li>运算速度  <ul><li>吞吐量、响应时间<br>吞吐量：系统单位时间内处理请求的数量。<br>响应时间：CPU 时间加等待时间。</li><li>CPU 主频、CPU 时钟周期<br>主频：CPU 数字脉冲信号频率。为时钟周期的倒数。</li><li>CPI<br>CPI（Cycles per Instruction）：每条指令所用的周期数。<br>IPC（Instructions per Cycle）：每周期执行的指令数。<script type="math/tex; mode=display">{\rm IPC} = \frac{1}{\rm CPI}</script></li><li>CPU 执行时间  <script type="math/tex; mode=display">\rm CPU 执行时间 = \frac{CPU 时钟周期数}{时钟频率} = \frac{指令数 \times CPI}{时钟频率}</script></li><li>MIPS（Millon Instructions per Second），MFLOPS（Millon Floating-point Operations per Second）  <script type="math/tex; mode=display">\rm MIPS = \frac{指令条数}{执行时间 \times 10^{6}} = \frac{主频}{CPI} = 主频 \times IPC</script><script type="math/tex; mode=display">\rm MFLOPS = \frac{浮点操作次数}{执行时间 \times 10^{6}}</script></li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 介绍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Hexo 插件开发学习】 一、Hello World。</title>
      <link href="/2025/10/12/25-10-11-1_HexoExt-hello-world/"/>
      <url>/2025/10/12/25-10-11-1_HexoExt-hello-world/</url>
      
        <content type="html"><![CDATA[<p>众所周知，学 Python 从 <code>print(&quot;Hello world&quot;)</code> 开始，学 C++ 从 <code>cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; endl;</code> 开始。那么，学 Hexo 插件从哪里开始呢？</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>实现一个简单插件，当插件被加载时在终端输出字符。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><h3 id="1-准备环境"><a href="#1-准备环境" class="headerlink" title="1. 准备环境"></a>1. 准备环境</h3><p>第一，你需要一个可用的网站源代码库。</p><p>第二，你不会真拿网站源代码库做实验吧？复制一份吧。</p><h3 id="2-创建插件"><a href="#2-创建插件" class="headerlink" title="2. 创建插件"></a>2. 创建插件</h3><p>懒得写了，参考<a href="https://blog.csdn.net/godread_cn/article/details/122031503">这个</a>。</p><p>创建一个叫 <code>hexo-tutor-hello</code> 的插件。执行 <code>npm init</code> 时进行这样的配置：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package name: (hexo-tutor-hello)</span><br><span class="line">version: (1.0.0)</span><br><span class="line">description: A Hello World tutorial plugin for Hexo.</span><br><span class="line">entry point: (index.js)</span><br><span class="line">test command:</span><br><span class="line">git repository: null</span><br><span class="line">keywords: hexo tutor intro</span><br><span class="line">author: Remy Campanella</span><br><span class="line">license: (ISC) MIT</span><br></pre></td></tr></table></figure></p><h3 id="3-编写文件"><a href="#3-编写文件" class="headerlink" title="3. 编写文件"></a>3. 编写文件</h3><p>据配置可知，程序的入口是 <code>index.js</code>。我们需要创建这个文件，并编辑：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>( <span class="comment">// 执行过滤器。</span></span><br><span class="line">    <span class="string">&quot;before_generate&quot;</span>, <span class="comment">// 填入过滤器。`before_generate`：在生成器解析前执行。</span></span><br><span class="line">    <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 一个匿名函数，定义在`before_generate`阶段执行的具体操作。</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello world!&quot;</span>); <span class="comment">// JavaScript 终端输出。</span></span><br><span class="line">        hexo.<span class="property">log</span>.<span class="title function_">info</span>(<span class="string">&quot;Hello world from Hexo log!&quot;</span>); <span class="comment">// Hexo 日志系统终端输出。</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h3 id="4-注册插件"><a href="#4-注册插件" class="headerlink" title="4. 注册插件"></a>4. 注册插件</h3><p>编辑根目录下 <code>package.json</code>：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// Existed code...</span></span><br><span class="line">    <span class="attr">&quot;hexo-tutor-hello&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.0.0&quot;</span> <span class="comment">// 使用 “^ + 当前插件使用的版本号”。</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></p><p>编辑根目录下 <code>_config.yml</code>：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins:</span> <span class="comment"># 若原文件没有此条目则添加。</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo-tutor-hello</span> <span class="comment"># 插件名。</span></span><br></pre></td></tr></table></figure></p><h3 id="5-测试"><a href="#5-测试" class="headerlink" title="5. 测试"></a>5. 测试</h3><p>在根目录启动终端，运行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure></p><p>得到终端输出：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">INFO  Validating config</span><br><span class="line">INFO  </span><br><span class="line">  ===================================================================</span><br><span class="line">      #####  #    # ##### ##### ###### #####  ###### #      #   #</span><br><span class="line">      #    # #    #   #     #   #      #    # #      #       # #</span><br><span class="line">      #####  #    #   #     #   #####  #    # #####  #        #</span><br><span class="line">      #    # #    #   #     #   #      #####  #      #        #</span><br><span class="line">      #    # #    #   #     #   #      #   #  #      #        #</span><br><span class="line">      #####   ####    #     #   ###### #    # #      ######   #</span><br><span class="line">                            5.5.0</span><br><span class="line">  ===================================================================</span><br><span class="line">INFO  Start processing</span><br><span class="line">Hello world!</span><br><span class="line">INFO  Hello world from Hexo log!</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 网站 </category>
          
          <category> Hexo 插件开发学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 插件开发 </tag>
            
            <tag> Node.js </tag>
            
            <tag> 前端工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Hexo 插件开发学习】 零、哥们，这插件保熟吗？</title>
      <link href="/2025/10/11/25-10-10-1_HexoExt-intro/"/>
      <url>/2025/10/11/25-10-10-1_HexoExt-intro/</url>
      
        <content type="html"><![CDATA[<center><em style="color: #666666">众所周知，凡是有插件的东西我都喜欢折腾一下。</em></center><br><center><em style="color: #666666">众所又周知，Hexo 是有插件系统的。</em></center><br><center><em style="color: #666666">那么，头抬起，请坐和放宽，好东西就要来了。（doge）</em></center><p>不幸的是，我并没有找到一个适合我的教程。随着学业的进行，我越来越理解“大学课程知识不足以找工作”这句话了。这不是大学课程的锅，而是从基础到应用本来就有一段很长的距离。同学们都在数字电路学过 Verilog（硬件描述语言，考试甚至还考了语法），但是能将 Verilog 应用在机器上则需要比学习语法更多的准备（计算机组成原理实验：（抬头））。此外，在学习中，我已适应了这样一套教程模式：</p><ul><li>对新手友好（至少是有编程基础的）</li><li>以相对完整的示例进行导向（而不是抽象的函数、接口说明）</li><li>具有真实可使用的代码而不是伪代码（说的就是你，<a href="https://c.biancheng.net/view/c0w91wc.html">《数据结构（C 语言版）》</a>）</li></ul><p>当然，<strong>我并不是说不具有以上特点的教程就不好</strong>。直接开讲函数、接口、字段的教程有利于具有一定经验的读者快速抓住技术要点、提高学习效率。其实，这样的教程应该被称为“文档”。</p><h2 id="如何学习？"><a href="#如何学习？" class="headerlink" title="如何学习？"></a>如何学习？</h2><p>了解 Hexo 插件开发，就是要了解 Hexo 插件基本结构、Hexo 插件加载顺序、Hexo 插件函数功能。要获取有关教程并不难，但是<strong>我看不懂</strong>。因此我需要通过简单的例子进行学习（至少起步）。</p><p>既然网上没有这样的教程，那就让 AI 生成一个。</p><blockquote><p><div style="float: right;">众所周知，学编程从输出Hello world开始，学Minecraft模组从添加第一个物品开始，那么，开发Hexo插件有没有简单又通用又好上手的新手尝试项目呢</div><br>当然有！Hexo 插件开发的“Hello World”项目，最经典、通用、好上手的，就是 “给每篇文章末尾自动添加自定义版权声明”。</p></blockquote><p>以此为基础，让 AI 逐步增加项目的难度，直至实现自己的需求。</p><h2 id="这是一个教程吗？"><a href="#这是一个教程吗？" class="headerlink" title="这是一个教程吗？"></a>这是一个教程吗？</h2><p>让一个连开发文档都看不懂的人写教程还是太城市化了（畏怖），因此我不打算把这个合集定义为一个教程。正如本站的关于页所说，这里记录的是学习过程。对于其他读者来说，这更像是一份“踩坑实录”和“避雷指南”。你在这里看到的，可能不是最优解，甚至充满了笨拙的尝试和可笑的错误。但如果你也和我一样，在面对那些“写给专业人士”的文档时感到无从下手，希望找到一个能陪你一起从零开始、把“天书”翻译成“人话”的同伴，那么欢迎来到我的世界。我们可以一起迷路，再一起找到出口。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 网站 </category>
          
          <category> Hexo 插件开发学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 插件开发 </tag>
            
            <tag> Node.js </tag>
            
            <tag> 前端工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【新功能特辑】不蒜子访问量统计</title>
      <link href="/2025/09/30/25-9-30-1_HexoDev_ver-desc-1_1_0/"/>
      <url>/2025/09/30/25-9-30-1_HexoDev_ver-desc-1_1_0/</url>
      
        <content type="html"><![CDATA[<p>自源代码库版本 <code>1.1.0</code> 起，本站引入<a href="https://busuanzi.ibruce.info/">不蒜子网页访问量统计服务</a>，以提供更准确的访问量统计。</p><h2 id="用户隐私说明"><a href="#用户隐私说明" class="headerlink" title="用户隐私说明"></a>用户隐私说明</h2><p><a href="https://busuanzi.ibruce.info/">不蒜子网页访问量统计服务</a>提供两种统计：页面访问量统计和用户访问量统计。页面访问量统计仅记录页面被访问的动作，用户访问量统计仅收集用户 IP 地址进行去重。这里的 IP 地址只能大致判断用户所在的国家和地区，难以得知用户更私密的信息。且不蒜子是轻量级的统计服务，没有收集用户隐私的服务。</p><h2 id="顺带一提"><a href="#顺带一提" class="headerlink" title="顺带一提"></a>顺带一提</h2><h3 id="为什么要引入这个服务？"><a href="#为什么要引入这个服务？" class="headerlink" title="为什么要引入这个服务？"></a>为什么要引入这个服务？</h3><p>要回答这个问题，就要了解 Hexo + Butterfly 自带的页面访问量统计<strong>为什么不行</strong>。</p><p>简单来讲，原版页面访问量统计是<strong>可覆盖的</strong>，一次新部署之后访问量统计可能会改变，甚至丢失。回顾网站部署前的命令行操作（我的操作）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hexo clean <span class="comment"># 清除缓存，为新功能做准备。</span></span><br><span class="line">hexo generate <span class="comment"># 执行 Markdown 转 HTML、生成搜索索引文件等操作。</span></span><br><span class="line">hexo server <span class="comment"># 在本机上进行**调试**。即便是在服务器上执行此命令也不等同于正式启动服务。</span></span><br><span class="line">hexo server --drafts <span class="comment"># 调试，且展示草稿。</span></span><br><span class="line"></span><br><span class="line">hexo deploy <span class="comment"># 部署服务器，包括 `hexo generate`。</span></span><br></pre></td></tr></table></figure></p><blockquote><p>注意：<code>hexo deploy</code> 不会自动启动服务，自动启动服务功能是 Github Pages 给的。</p></blockquote><p>这里，访问量统计被当作了缓存，在 <code>hexo clean</code> 被清理。即便访问量统计能保留，这也是作者在调试时产生的访问统计量，真正的访问量还在线上等着被覆盖呢（悲）。</p><p>这就是静态网站的缺陷：<strong>仅有的数据易被视作缓存，难以长期存储</strong>。这引出了第三方服务的意义之一：<strong>使纯静态网站拥有动态网站的功能，统计的数据更加有意义</strong>。</p><h3 id="这个服务是怎么实现的？"><a href="#这个服务是怎么实现的？" class="headerlink" title="这个服务是怎么实现的？"></a>这个服务是怎么实现的？</h3><p>不蒜子通过 JavaScript 异步请求实现数据统计，无需复杂的后端配置。其核心流程分为两步：</p><ul><li>前端嵌入代码：在网站页面中插入一段 JS 脚本，用于触发统计请求。</li><li>后端计数服务：接收请求后，根据访问来源（IP、页面 URL 等）更新数据库中的 PV（页面浏览量）和 UV（独立访客数）。</li></ul><p>不蒜子使用轻量级数据库（如 Redis）存储统计数据，以键值对形式记录：<br>| 服务 | 算法 | 功能 |<br>| —- | —- | —- |<br>| 页面访问量统计 | PV（Page View）算法 | 每个 URL 对应一个计数器，长期统计页面被访问的次数 |<br>| 用户访问量统计 | UV（User View）算法 | 在 PV 算法的基础上，将用户一天内的访问视作一次，得到独立访客数 |</p><h3 id="那我缺的-DHCP-这一块的谁给我补啊？"><a href="#那我缺的-DHCP-这一块的谁给我补啊？" class="headerlink" title="那我缺的 DHCP 这一块的谁给我补啊？"></a>那我缺的 DHCP 这一块的谁给我补啊？</h3><p>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）是一个网络管理协议，它的核心作用是<strong>自动地为网络中的设备分配 IP 地址及其他相关网络配置参数</strong>。是网络 IP 分配的常用技术。</p><p>也就是说，用户的 IP 地址是随时变化的，IP 与用户不是一一对应的关系，这可能会使不蒜子将一个用户识别为多个用户，UV 算法准确度降低。您目前在网站上看到的统计量是 PV 算法的。</p><h3 id="怎么配置？"><a href="#怎么配置？" class="headerlink" title="怎么配置？"></a>怎么配置？</h3><p>通用的办法是，在这个数字要显示的地方（比如模板）嵌入统计代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//api.busuanzi.cc/static/3.6.9/busuanzi.min.js&quot;</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">本站总访问量 <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_site_pv&quot;</span>&gt;</span>加载中...<span class="tag">&lt;/<span class="name">span</span>&gt;</span> 次</span><br><span class="line">本站总访客数 <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_site_uv&quot;</span>&gt;</span>加载中...<span class="tag">&lt;/<span class="name">span</span>&gt;</span> 人</span><br><span class="line">本页总阅读量 <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_page_pv&quot;</span>&gt;</span>加载中...<span class="tag">&lt;/<span class="name">span</span>&gt;</span> 次</span><br><span class="line">本页总访客数 <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_page_uv&quot;</span>&gt;</span>加载中...<span class="tag">&lt;/<span class="name">span</span>&gt;</span> 人</span><br><span class="line"></span><br><span class="line">本站今日访问量 <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_today_site_pv&quot;</span>&gt;</span>加载中...<span class="tag">&lt;/<span class="name">span</span>&gt;</span> 次</span><br><span class="line">本站今日访客数 <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_today_site_uv&quot;</span>&gt;</span>加载中...<span class="tag">&lt;/<span class="name">span</span>&gt;</span> 人</span><br><span class="line">本页今日阅读量 <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_today_page_pv&quot;</span>&gt;</span>加载中...<span class="tag">&lt;/<span class="name">span</span>&gt;</span> 次</span><br><span class="line">本页今日访客数 <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_today_page_uv&quot;</span>&gt;</span>加载中...<span class="tag">&lt;/<span class="name">span</span>&gt;</span> 人</span><br></pre></td></tr></table></figure></p><p>如果使用的是 Butterfly 主题，可以更改<code>\theme\butterfly\layout\widget\card_webinfo.pug</code>：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">script.</span><br><span class="line">    function checkPv()&#123; </span><br><span class="line">        var init_pv = parseInt(!&#123;theme.busuanzi.init_pv&#125;)</span><br><span class="line">        var pv = document.getElementById(&quot;busuanzi_value_site_pv&quot;)</span><br><span class="line">        if (pv.innerText === &#x27;&#x27;)&#123;</span><br><span class="line">        setTimeout(checkPv, 100)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            pv.innerText = parseInt(pv.innerText) + init_pv</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">script checkPv()</span><br><span class="line"></span><br><span class="line">script.</span><br><span class="line">    function checkUv()&#123; </span><br><span class="line">        var init_uv = parseInt(!&#123;theme.busuanzi.init_uv&#125;)</span><br><span class="line">        var uv = document.getElementById(&quot;busuanzi_value_site_uv&quot;)</span><br><span class="line">        if (uv.innerText === &#x27;&#x27;)&#123;</span><br><span class="line">        setTimeout(checkUv, 100)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            uv.innerText = parseInt(uv.innerText) + init_uv</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">script checkUv()</span><br></pre></td></tr></table></figure></p><blockquote><p>注意：要把原有代码全部注释。VSCode 批量注释/批量去注释快捷键 <code>Ctrl + /</code>。</p></blockquote><p>这样，PV 统计量就出现在“浏览量”的位置上了。</p><h2 id="Request-for-Comments"><a href="#Request-for-Comments" class="headerlink" title="Request for Comments"></a>Request for Comments</h2><p>有些说法是我查的，有些说法是我 AI 的，有些说法是我疑？悟！的。如有谬误，欢迎指正。</p>]]></content>
      
      
      <categories>
          
          <category> 本站 </category>
          
          <category> 更新 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网站源库开发日志</title>
      <link href="/2025/09/28/25-9-28-1_HexoDev-log/"/>
      <url>/2025/09/28/25-9-28-1_HexoDev-log/</url>
      
        <content type="html"><![CDATA[<blockquote><p>注意：</p><ol><li>这是网站源代码库的日志，不是网站部署库的日志。</li><li>本日志关注网站功能的添加、删除、更改与问题修复，与文章内容的增减无关。</li></ol></blockquote><h3 id="Source-1-0-0"><a href="#Source-1-0-0" class="headerlink" title="Source 1.0.0"></a>Source 1.0.0</h3><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Date</td><td>Sept. 28, 2025</td></tr><tr><td>Description</td><td>The first formal version of <a href="/">remy-campanella.github.io</a>. Basic functions are ready and <code>hexo clean</code>ed.</td></tr></tbody></table></div><h3 id="Source-1-0-1"><a href="#Source-1-0-1" class="headerlink" title="Source 1.0.1"></a>Source 1.0.1</h3><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Date</td><td>Sept. 28, 2025</td></tr><tr><td>Description</td><td>Fixed “the wrong user directed by “Follow me” button” problem.</td></tr></tbody></table></div><h3 id="Source-1-1-0"><a href="#Source-1-1-0" class="headerlink" title="Source 1.1.0"></a>Source 1.1.0</h3><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Date</td><td>Sept. 30, 2025</td></tr><tr><td>Description</td><td>Added Busuanzi page view statistics.</td></tr><tr><td>Artical Report</td><td><a href="/2025/9/30/busuanzi/">【新功能特辑】不蒜子访问量统计</a></td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 本站 </category>
          
          <category> 更新 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> log </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/09/27/hello-world/"/>
      <url>/2025/09/27/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 本站 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
