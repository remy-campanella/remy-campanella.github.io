<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【计算机组成原理】 复习要点</title>
      <link href="/2026/01/05/25-12-16-1-CompOrg-10-review/"/>
      <url>/2026/01/05/25-12-16-1-CompOrg-10-review/</url>
      
        <content type="html"><![CDATA[<h2 id="题型">题型</h2><p>简答题、计算题。</p><p>选一些计算题练习，课后习题。</p><p>闭卷考试。</p><p>实验报告：期末之前。</p><h2 id="难度">难度</h2><p>较难，低于考研。</p><h2 id="第一章-概论">第一章 概论</h2><ol type="1"><li><p>冯 · 诺伊曼计算机</p></li><li><p>计算机基本组成</p></li></ol><h2 id="第二章-数据的机器层次表示">第二章 数据的机器层次表示</h2><ol type="1"><li><p>原码补码反码真值，互相转换</p></li><li><p>定点数、浮点数范围与典型值</p></li><li><p>浮点数进制与格式转换（IEEE 754）</p></li><li><p>字符编码</p></li><li><p>十进制数编码</p></li><li><p>奇偶校验</p></li></ol><h2 id="第三章-指令系统">第三章 指令系统</h2><ol type="1"><li><p>指令格式</p></li><li><p>寻址方式</p></li><li><p>扩展操作码</p></li><li><p>自底向上的堆栈</p></li></ol><h2 id="第四章-数值的及其运算">第四章 数值的及其运算</h2><ol type="1"><li><p><strong>8 种加减法</strong></p></li><li><p>溢出检测</p></li><li><p>先行进位加法器的原理推导与设计</p></li><li><p>十进制数的加减法运算原理</p></li></ol><h2 id="第五章-存储系统和结构">第五章 存储系统和结构</h2><ol type="1"><li><p>RAM、ROM 的概念与类型</p></li><li><p>数据在主存中的存放方法</p></li><li><p><strong>主存储器的连接、控制、寻址、扩展、刷新</strong></p></li><li><p>主存的校验</p></li><li><p>存储系统的扩展</p></li></ol><h2 id="第六章-中央处理器">第六章 中央处理器</h2><ol type="1"><li><p>控制器的基本组成</p></li><li><p>时序系统</p></li><li><p>指令执行的过程</p></li><li><p>微程序的执行过程</p></li><li><p>取指周期的微操作，CPU 的数据通路图</p></li></ol><h2 id="第七章-总线">第七章 总线</h2><ol type="1"><li><p>总线仲裁</p></li><li><p>总线定时控制</p></li></ol><h2 id="第八章-外部设备">第八章 外部设备</h2><ol type="1"><li><strong>滚木</strong></li></ol><h2 id="第九章-输入输出系统">第九章 输入输出系统</h2><ol type="1"><li>I/O 控制方式</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【计算机组成原理】 第九章 输入输出系统</title>
      <link href="/2026/01/05/25-12-2-2-CompOrg-9-io-sys/"/>
      <url>/2026/01/05/25-12-2-2-CompOrg-9-io-sys/</url>
      
        <content type="html"><![CDATA[<h2 id="主机与外部设备的连接">9.1 主机与外部设备的连接</h2><h3 id="输入输出接口">9.1.1 输入输出接口</h3><p>主机与外设的连接方式有辐射型连接、总线型连接等。书记与外设各有自己的工作特点，必须通过 I/O 接口进行信息交换。</p><h3 id="接口的功能与基本组成">9.1.2 接口的功能与基本组成</h3><ol type="1"><li><p><strong>接口的功能</strong></p><ul><li>实现主机与外设的通信联络控制。</li><li>进行地址译码与设备选择。</li><li>实现数据缓冲。</li><li>数据格式的变换。</li><li>传递控制命令和状态信息。</li></ul></li><li><p><strong>接口的基本组成</strong><br />端口是接口电路中<strong>可以直接被 CPU 访问的寄存器</strong>。一个接口一般包含<strong>数据端口</strong>、<strong>命令端口</strong>和<strong>状态端口</strong>。<br /><img src="/image/25-12-2-2-CompOrg-9-io-sys/1764682361532.webp" alt="1764682361532" /><br />为了节省硬件，状态信息和控制信息可共用一个端口。</p></li><li><p><strong>接口的类型</strong></p><ul><li><strong>按数据传送方式</strong><ul><li>串行接口</li><li>并行接口</li></ul></li><li><strong>按主机访问 I/O 设备的控制方式分类</strong><ul><li>程序查询式接口</li><li>程序中断接口</li><li>DMA 接口</li><li>复杂通道控制器</li></ul></li><li><strong>按功能选择的灵活性分类</strong><ul><li>可编程接口</li><li>不可编程接口</li></ul></li><li><strong>按通用性分类</strong><ul><li>通用接口：可供多种外设使用的标准接口。</li><li>专用接口：为某类用途或外设专门设计。</li></ul></li><li><strong>按输入输出的信号分类</strong><ul><li>数字接口</li><li>模拟接口</li></ul></li><li><strong>按应用分类</strong><ul><li>运行辅助接口</li><li>用户交互接口</li><li>传感接口</li><li>控制接口</li></ul></li></ul></li></ol><h3 id="外设的识别与端口寻址">9.1.3 外设的识别与端口寻址</h3><ol type="1"><li><strong>端口地址编址方式</strong><ul><li><strong>独立编址</strong><br />另设 I/O 读写控制线，设置专门的 I/O 指令。</li><li><strong>统一编址</strong><br />I/O 端口与主存统一编址，不设置专门的 I/O 指令。</li></ul></li><li><strong>独立编址方式的端口访问</strong><br />80x86 的专用 I/O 指令 <code>IN</code> 和 <code>OUT</code> 有<strong>直接寻址</strong>和<strong>间接寻址</strong>两种类型 。</li></ol><h3 id="输入输出信息的控制方式">9.1.4 输入输出信息的控制方式</h3><ol type="1"><li><p><strong>程序查询方式</strong><br />一旦某一外设被选中并启动之后，主机将查询这个外设的某些状态位，看其是否准备就绪？若外设未准备就绪，主机将再次查询；若外设已准备就绪，则执行一次 I/O 操作。</p><p>外设和主机不能同时工作，各外设也不能同时工作，</p></li><li><p><strong>程序中断方式</strong><br />外设在做好输入输出准备时，向主机发中断请求，主机接到请求后就暂时中止原来执行的程序，转去执行中断服务程序对外部请求进行处理，在中断处理完毕后返回原来的程序继续执行。</p></li><li><p><strong>直接存储器读取（DMA）方式</strong><br />在主存与外设件开辟直接的数据通路，无需 CPU 介入。</p></li><li><p><strong>I/O 通道控制方式</strong><br />执行 I/O 操作时，执行启动相关通道，通道执行通道程序。通道时一个育有特殊功能的从属于 CPU 的<strong>专用处理器</strong>。</p></li></ol><p>目前，小型和微型计算机大多采用程序查询方式、程序中断方式和 DMA 方式；大型和中型计算机多采用通道方式。</p><h2 id="程序查询方式及其接口">9.2 程序查询方式及其接口</h2><p>程序查询方式的核心问题在于需要不断地查询 I/O 设备是否准备就绪。</p><h3 id="程序查询方式">9.2.1 程序查询方式</h3><ol type="1"><li><p><strong>程序查询的基本思想</strong><br />由 CPU 执行一段<strong>输入输出程序</strong>来实现主机与外设之间数据传送的方式称为程序直接控制方式。根据外设的不同性质，这种传送方式又可分为<strong>无条件传送</strong>和<strong>程序查询方式</strong>两种。</p></li><li><p><strong>工作流程</strong></p><ul><li>预置传送参数</li><li>向外设接口发出命令字</li><li>从外设接口取回状态字</li><li>查询外设标志<ul><li>如果外设未准备就绪，CPU 踏步等待，执行第 3 步，直至设备就绪。</li></ul></li><li>传送数据</li><li>修改传送参数</li><li>判断传送是否结束<ul><li>如果传送个数计数器不为 0，回到第 3 步，继续传送，直到计数器为 0。</li></ul></li></ul></li></ol><h3 id="程序查询方式接口">9.2.2 程序查询方式接口</h3><p>接口中至少有两个寄存器</p><ul><li>数据缓冲寄存器（数据端口）</li><li>设备状态寄存器（状态端口）</li></ul><ol type="1"><li><p><strong>输入接口</strong><br /><img src="/image/25-12-2-2-CompOrg-9-io-sys/1765280779564.webp" alt="1765280779564" /></p></li><li><p><strong>输出接口</strong></p></li></ol><h2 id="中断系统和程序中断方式">9.3 中断系统和程序中断方式</h2><h3 id="中断的基本概念">9.3.1 中断的基本概念</h3><ol type="1"><li><p><strong>中断的提出</strong><br />一旦外设完成数据传送的准备工作（输入设备的数据准备好或输出设备的数据缓冲器空）时，便主动向 CPU 发出一个中断请求。在可以响应中断的条件下，CPU <strong>暂时中止</strong>正在执行的程序，转去执行中断服务程序为中断请求者服务，在中断服务程序中完成一次主机与外设之间的数据传送，传送完成后，CPU 仍返回原来的程序，从断点处继续执行。</p><p>中断系统是计算机实现中断功能的软、硬件总称。<br /><img src="/image/25-12-2-2-CompOrg-9-io-sys/1765282785172.webp" alt="1765282785172" /></p></li><li><p><strong>程序中断与调用子程序的区别</strong></p><table><thead><tr class="header"><th>区别</th><th>子程序调用</th><th>中断服务程序</th></tr></thead><tbody><tr class="odd"><td>触发</td><td>由程序员安排</td><td>由随机中断事件引起</td></tr><tr class="even"><td>控制</td><td>主程序或上层子程序</td><td>与现行程序无关系</td></tr><tr class="odd"><td>并行性</td><td>一般不能同时调用多个</td><td>多个外设同时请求 CPU 服务是可能的</td></tr></tbody></table></li><li><p><strong>中断的类型</strong></p><ul><li><strong>自愿中断和强迫中断</strong></li><li><strong>程序中断和简单中断（DMA 方式）</strong></li><li><strong>内中断和外中断</strong></li><li><strong>向量中断和非向量中断</strong></li><li><strong>单重中断和多重中断</strong></li></ul></li></ol><h3 id="中断请求和中断判优">9.3.2 中断请求和中断判优</h3><ol type="1"><li><p><strong>中断源与中断请求信号</strong><br />中断源即引起计算机中断的事件。可采用具有存储功能的<strong>中断请求触发器（INTR）</strong>。</p></li><li><p><strong>中断请求信号的传送</strong></p><ul><li><strong>独立请求线</strong><br /></li><li><strong>公共请求线</strong><br /></li><li><strong>二维结构</strong></li></ul></li><li><p><strong>中断优先级与判优方法</strong></p><ul><li>对那些提出中断请求后<strong>需要立刻处理</strong>，否则就会<strong>造成严重后果</strong>的中断源规定为最高的优先级。</li><li>而对那些可以延迟响应和处理的中断源规定为较低的优先级。</li></ul><p>故障中断一般优先级较高，其次是简单中断，接着是 I/O 中断。</p><ul><li><p><strong>软件判优法</strong><br />CPU 接到中断请求后，逐个检测中断请求寄存器的各位状态。检测顺序按优先级大小排列，最先检测的中断源具有最高优先级。</p></li><li><p><strong>硬件判优法</strong><br />采用硬件判优电路。优先级别高的中断请求将封锁优先级别低的中断请求处理。</p></li></ul></li></ol><h3 id="中断响应与中断处理">9.3.3 中断响应与中断处理</h3><ol type="1"><li><p><strong>CPU 响应中断的条件</strong></p><ul><li><strong>CPU 收到中断信号</strong></li><li><strong>CPU 允许中断</strong><br />中断允许触发器 <code>EINT = 0</code>，由开中断指令置位，关中断指令或硬件复位。</li><li><strong>一条指令执行完毕</strong></li></ul></li><li><p><strong>中断隐指令</strong><br />CPU 响应中断后转到中断服务程序由硬件实现。中断隐指令<strong>不是真正的指令</strong>，<strong>无操作码</strong>，<strong>不可能由用户使用</strong>。</p><p>中断隐指令的作用：</p><ul><li><strong>保存断点</strong><br /></li><li><strong>暂不允许中断</strong><br />即关中断。为保护中断现场期间<strong>不被新的中断打断</strong>。</li><li><strong>引出中断服务程序</strong></li></ul></li><li><p><strong>中断周期</strong></p></li><li><p><strong>进入中断服务程序</strong></p><ul><li><strong>软件方法</strong></li><li><strong>硬件向量中断法</strong><ul><li>向量地址是中断服务程序的入口地址。</li><li>向量地址是中断服务表的指针。</li></ul></li></ul></li><li><p><strong>中断现场的保护与恢复</strong></p></li></ol><h3 id="多重中断与中断屏蔽">9.3.4 多重中断与中断屏蔽</h3><ol type="1"><li><p><strong>中断嵌套</strong><br />中断嵌套的层次可以有多层，越在<strong>里层</strong>的中断请求越急迫，优先级越高，因此优先得到 CPU 的服务。</p><p>计算机需要能<strong>保护多个断点</strong>。在 CPU 进入某个中断服务程序时，系统必须处于<strong>开中断状态</strong>。</p></li><li><p><strong>允许与禁止中断</strong></p><ul><li><strong>开中断的情况</strong><br /></li><li><strong>关中断的情况</strong></li></ul></li><li><p><strong>中断屏蔽</strong><br />中断可以用程序方式有选择地封锁部分中断。如果给每个中断源都相应地配备一个中断屏蔽触发器（MASK），则每个中断请求信号在送往判优电路之前，还要受到屏蔽触发器的控制。当<code>MASK = 1</code>，表示对应中断源的请求被屏蔽，可见中断请求触发器和中断屏蔽触发器是成对出现的，只有当 <code>INTR = 1</code>（中断源有中断请求），<code>MASK = 0</code>（该级中断未被屏蔽）时，才充许对应的中断请求送往 CPU。</p></li><li><p><strong>中断升级</strong><br />中断响应次序由硬件决定，但中断处理次序可由屏蔽码改变。</p></li></ol><h3 id="中断全过程">9.3.5 中断全过程</h3><p>这里所说的中断全过程，指的是从中断源发出中断请求开始，CPU 响应这个请求，现行程序被中断，转至中断服务程序，直到中断服务程序执行完毕，CPU 再返回原来的程序继续执行的整个过程。</p><h2 id="dma-方式及其接口">9.4 DMA 方式及其接口</h2><h3 id="dma-方式的基本概念">9.4.1 DMA 方式的基本概念</h3><ol type="1"><li><p><strong>DMA 方式的特点</strong><br />直接存储器访问（Direct Memory Access，DMA）方式是在外设和主存之间开辟一条“直接数据通道”，在<strong>不需要 CPU 干预</strong>也<strong>不需要软件介入</strong>的情况下在两者之间进行的<strong>高速数据传送</strong>方式。</p><p>在 DMA 传送方式中，对数据传送过程进行控制的硬件称为 <strong>DMA 控制器</strong>。设置通过 DMA 控制器项 CPU 发出请求，CPU 响应之后<strong>让出系统总线</strong>给 DMA 控制器。</p><ul><li>主存可被 CPU 与外设访问。</li><li>数据块传送时，主存地址的确定、传送数据的计数等由<strong>硬件</strong>实现。</li><li>主存中有<strong>专用缓冲区</strong>，调配主存与外设的速度。</li><li>CPU 与外设并行，提高效率。</li><li>传送前需要程序<strong>预处理</strong>，结束通过<strong>中断</strong>进行<strong>后处理</strong>。</li></ul></li><li><p><strong>DMA 与中断的区别</strong></p><table><thead><tr class="header"><th>区别</th><th>DMA</th><th>中断</th></tr></thead><tbody><tr class="odd"><td>资源</td><td>程序切换、现场</td><td></td></tr><tr class="even"><td>CPU 干预</td><td>无需</td><td>需要</td></tr><tr class="odd"><td>响应</td><td>每个机器周期结束</td><td>每条指令执行完毕</td></tr><tr class="even"><td>优先级</td><td>更高</td><td>更低</td></tr><tr class="odd"><td>能力</td><td>可处理异常事件</td><td>只能传送数据块 I/O</td></tr></tbody></table></li><li><p><strong>DMA 方式的应用</strong><br />DMA 方式一般应用于<strong>主存</strong>与<strong>高速外设</strong>间的<strong>简单数据传送</strong>。</p></li></ol><h3 id="dma-接口">9.4.2 DMA 接口</h3><ol type="1"><li><p><strong>DMA 控制器的功能</strong><br />控制系统总线的能力，像 CPU 一样输出地址信号，收发控制、数据信号。</p><ul><li>接受 DMA 请求，发出总线请求。</li><li>CPU 响应总线请求，发出响应信号。</li><li>确定传送数据的主存单元地址和传送长度自动修改地址计数与传送长度计数。</li><li>规定数据在主存与外设间的传送方向执行数据传送。</li><li>向 CPU 报告 DMA 操作结束。</li></ul></li><li><p><strong>DMA 控制器的基本组成</strong></p><ul><li>主存地址计数器</li><li>传送长度计数器</li><li>数据缓冲寄存器</li><li>DMA 请求触发器</li><li>控制状态逻辑</li><li>中断机构</li></ul></li><li><p><strong>DMA 控制线的引出线</strong></p><ul><li>地址总线</li><li>数据总线</li><li>控制数据传送方式的信号线<ul><li>存储器读 <span class="math inline">\(\overline{MEMR}\)</span></li><li>存储器写 <span class="math inline">\(\overline{MEMW}\)</span></li><li>外设读 <span class="math inline">\(\overline{IOR}\)</span></li><li>外设写 <span class="math inline">\(\overline{IOW}\)</span></li></ul></li><li>控制器与外设间的联络信号线<ul><li>DMA 请求信号 DREQ</li><li>DMA 响应信号 DACK</li></ul></li><li>控制器与 CPU 间的联络信号线<ul><li>总线请求信号 HRQ</li><li>总线响应信号 HLDA</li></ul></li></ul></li><li><p><strong>DMA 控制器的连接与传送</strong><br /><img src="/image/25-12-2-2-CompOrg-9-io-sys/1765886352149.webp" alt="1765886352149" /></p></li></ol><h3 id="dma-传送方法与传送过程">9.4.3 DMA 传送方法与传送过程</h3><ol type="1"><li><strong>DMA 传送方法</strong><ul><li><p><strong>CPU 停止访问主存法</strong><br />使用 DMA 信号迫使 CPU 让出总线。</p></li><li><p><strong>存储器分时法</strong><br />把原来的存储周期分为两个时间片，一个给 CPU，一个给 DMA。</p></li><li><p><strong>周期挪用法</strong></p><ul><li>当外部无 DMA 请求时，CPU 按程序要求访问主存。</li><li>有 DMA 请求时，CPU 让出一个周期给 DMA。</li><li>高速主机常用。</li></ul></li></ul></li><li><strong>DMA 传送过程</strong><ul><li><p><strong>DMA 预处理</strong><br />CPU 执行 I/O 指令测试外设状态、寄存器置初值、规定传送方向、启动外设等。</p></li><li><p><strong>数据传送</strong><br /></p></li><li><p><strong>DMA 后处理</strong><br />长度计数器为 0 时，DMA 控制器向 CPU 发出中断请求。</p></li></ul></li></ol><h2 id="通道控制方式">9.5 通道控制方式</h2><ol type="1"><li><p><strong>与 DMA 的区别</strong></p><table><thead><tr class="header"><th>区别</th><th>通道</th><th>DMA</th></tr></thead><tbody><tr class="odd"><td>本质</td><td>具有特殊功能的处理器</td><td>纯硬件控制逻辑</td></tr><tr class="even"><td>能力</td><td>许多设备</td><td>少数设备</td></tr></tbody></table></li><li><p><strong>通道的功能</strong></p><ul><li>接收 CPU I/O 指令，与外设进行联系。</li><li>取出通道程序通道指令，译码后向设备与设备控制器发送命令。</li><li>实施主存与外设间数据传送。</li><li>从外设获取状态信息，形成并保存通道状态信息，送到主存指定单元供 CPU 使用。</li><li>报告外设与通道的中断次序给 CPU。</li></ul></li></ol><h3 id="通道类型与结构">9.5.2 通道类型与结构</h3><ol type="1"><li><p><strong>通道类型</strong></p><table><thead><tr class="header"><th>类型</th><th>特点</th></tr></thead><tbody><tr class="odd"><td>结合型通道</td><td>与 CPU 共用某些设备</td></tr><tr class="even"><td>独立型通道</td><td>与 CPU 独立，功能更强，更昂贵</td></tr></tbody></table><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th>类型</th><th>特点</th></tr></thead><tbody><tr class="odd"><td>字节多路通道</td><td>连接与管理多台低速设备，以<strong>字节交叉方式</strong>传输信息</td></tr><tr class="even"><td>选择通道</td><td>在一段时间内通道只能选择<strong>一台设备</strong>进行数据传送</td></tr><tr class="odd"><td>数组多路通道</td><td>当某设备进行数据传送时，通道只为该设备服务；当设备在执行辅助操作时，通道暂时断开与这个设备的连接，<strong>挂起该设备的通道程序</strong>，去为其他设备服务</td></tr></tbody></table></li><li><p><strong>通道的结构</strong></p><table><colgroup><col style="width: 33%" /><col style="width: 33%" /><col style="width: 33%" /></colgroup><thead><tr class="header"><th>结构</th><th>作用</th><th>CPU 类似部件</th></tr></thead><tbody><tr class="odd"><td>CCWR（通道命令字寄存器）</td><td>存放 CCW（通道命令字）</td><td>IR</td></tr><tr class="even"><td>CAWR（通道地址字寄存器）</td><td>指出 CCW 在主存中的地址</td><td>MAR</td></tr><tr class="odd"><td>CSWR（通道状态字寄存器）</td><td>记录通道程序执行后的通道与响应设备信息，称为 CSW（通道状态字）</td><td>PSWR</td></tr></tbody></table></li></ol><h3 id="通道程序">9.5.3 通道程序</h3><h3 id="通道工作过程">9.5.4 通道工作过程</h3><ul><li>用户使用访管指令进入管道程序，CPU 通过管理程序启动一个通道程序，启动通道。</li><li>通道执行通道程序，完成指定数据输入输出。</li><li>程序结束后向 CPU 发出中断请求，CPU 响应后进入操作系统调用管理程序。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【计算机组成原理】 第八章 外部设备</title>
      <link href="/2026/01/05/25-12-2-2-CompOrg-8-ext-device/"/>
      <url>/2026/01/05/25-12-2-2-CompOrg-8-ext-device/</url>
      
        <content type="html"><![CDATA[<h2 id="外部设备概述">8.1 外部设备概述</h2><h3 id="外部设备的分类">8.1.1 外部设备的分类</h3><ol type="1"><li><p><strong>输入输出设备</strong><br />如键盘、鼠标、显示器、打印机等。此外还有复合型的输入输出设备。</p></li><li><p><strong>辅助存储器</strong><br />如硬盘。</p></li><li><p><strong>终端设备</strong><br />由输入设备、输出设备、终端控制器组成。可进行输入输出，与计算机通信线路通信，有的可进行数据处理。</p></li><li><p><strong>过程控制设备</strong><br />如 AD/DA 与相应检测设备。</p></li></ol><h2 id="外部设备的地位和作用">8.1.2 外部设备的地位和作用</h2><p>教材 232 / 250 页慢走不送~ ¯\_(ツ)_/¯</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【计算机组成原理】 第七章 总线</title>
      <link href="/2026/01/05/25-11-25-1-CompOrg-7-bus/"/>
      <url>/2026/01/05/25-11-25-1-CompOrg-7-bus/</url>
      
        <content type="html"><![CDATA[<h2 id="总线概述">7.1 总线概述</h2><p>总线是一组能为多个部件分时共享的公共信息传送线路。</p><dl><dt><strong>共享</strong></dt><dd>总线上可挂载多个部件</dd><dt><strong>分时</strong></dt><dd>同一时刻总线上只能有一个部件发送信息。</dd></dl><h3 id="总线的基本概念">7.1.1 总线的基本概念</h3><ol type="1"><li><p><strong>分时共享的过程</strong></p><ul><li>总线空闲，所有部件处于高阻态。</li><li>通信时，</li></ul></li><li><p><strong>三态门和总线电路</strong><br />三态门有逻辑 0、逻辑 1、高阻态（开路）三态。三态门有一个控制端 <span class="math inline">\(G\)</span>/<span class="math inline">\(\bar{G}\)</span>，控制端有效时功能正常，否则为高阻态。</p></li><li><p><strong>总线事务</strong><br />总线上一对设备间一次信息交换称为一次总线事务。</p></li><li><p><strong>总线使用权</strong></p></li></ol><h3 id="总线的分类">7.1.2 总线的分类</h3><ol type="1"><li><p><strong>按功能层次分类</strong></p></li><li><p><strong>按数据线的多少分类</strong></p><ul><li>并行总线</li><li>串行总线</li></ul></li></ol><h3 id="总线的组成与性能指标">7.1.3 总线的组成与性能指标</h3><ol type="1"><li><p><strong>总线结构</strong></p><ul><li>单总线</li><li>双总线</li><li>三总线</li></ul></li><li><p><strong>总线特性</strong></p></li><li><p><strong>总线的性能指标</strong></p><ul><li><p><strong>总线宽度</strong><br />总线的线数，影响地址线与数据线的数量。</p></li><li><p><strong>总线带宽</strong><br />最大数据传输速率（字节/秒）。<br /><span class="math display">\[B = \frac{WF}{N}\]</span></p><p><span class="math inline">\(W\)</span>—数据总线宽度；<span class="math inline">\(F\)</span>—时钟频率；<span class="math inline">\(N\)</span>—一次数据传输的时钟周期数。</p></li><li><p><strong>总线负载</strong></p></li><li><p><strong>总线复用</strong><br />总线分时复用</p></li><li><p><strong>总线猝发传输</strong><br />在一个总线周期中传输地址连续的多个数据。</p></li></ul></li></ol><h2 id="总线仲裁">7.2 总线仲裁</h2><p>总线上的模块可作主作从。为保证同一时刻只有一个申请者使用总线，需按照一定优先次序决定哪个部件首先使用总线。</p><h3 id="集中仲裁方式">7.2.1 集中仲裁方式</h3><ol type="1"><li><p><strong>链式查询方式</strong><br />总线控制器使用<strong>总线请求</strong>（BR）、<strong>总线忙</strong>（BS）、<strong>总线批准</strong>（BG）三根控制线与所有部件相连。</p><figure><img src="/image/25-11-25-1-CompOrg-7-bus/1764675710167.webp" alt="1764675710167" /><figcaption aria-hidden="true">1764675710167</figcaption></figure><table><thead><tr class="header"><th>控制线</th><th>有效时的含义</th></tr></thead><tbody><tr class="odd"><td>BR</td><td>至少有一个部件要求使用总线</td></tr><tr class="even"><td>BS</td><td>总线正被使用</td></tr><tr class="odd"><td>BG</td><td>总线控制器响应请求</td></tr></tbody></table><ul><li><strong>优点</strong>：线路少、<strong>易扩展</strong>。</li><li><strong>缺点</strong>：对<strong>查询链路故障</strong>敏感。</li></ul></li><li><p><strong>计数器定时查询方式</strong><br />部件通过公共 BR 线发出请求。当 <span class="math inline">\(BR = 0\)</span>，计时器计数，定时查询各部件确定发出请求的部件；当计数值与部件号一致时，部件使 <span class="math inline">\(BR = 1\)</span>，获得使用权，终止计数查询，用完后撤销 BR 信号。<br /><img src="/image/25-11-25-1-CompOrg-7-bus/1764676502089.webp" alt="1764676502089" /></p></li><li><p><strong>独立请求方式</strong><br />每一个共享总线的部件均有一堆控制线 BR<sub>i</sub>、BG<sub>i</sub>，总线控制器有排队电路，进行调度。<br /><img src="/image/25-11-25-1-CompOrg-7-bus/1764676765373.webp" alt="1764676765373" /></p><ul><li><strong>优点</strong>：更灵活，响应时间快。</li><li><strong>缺点</strong>：线路较多。</li></ul></li></ol><h3 id="分布仲裁方式">7.2.2 分布仲裁方式</h3><p>分布仲裁方式无需中央总线控制器，而是分布在总线上的各设备中。</p><p>主方启动一个总线周期，从方响应请求。</p><h2 id="总线定时控制">7.3 总线定时控制</h2><p>解决主机与外设的时间配合与动作协调。</p><h3 id="同步定时方式">7.3.1 同步定时方式</h3><p>系统采用一个<strong>统一的时钟</strong>协调收发双方的传送定时关系，在规定的时间内进行 I/O 操作，发送者不等待接收者响应。</p><p>同步方式时钟频率需适应总线<strong>最长延迟</strong>与<strong>最慢接口</strong>，时间效率较低，时间利用不合理，也不知道外设是否响应，<strong>可靠性低</strong>。</p><h3 id="异步定时方式">7.3.2 异步定时方式</h3><p>亦作应答方式。依靠传送双方的“<strong>握手</strong>”实现定时控制。</p><p>注射内提出交换信息<strong>请求</strong>，从设备将这设备发出<strong>回答</strong>。操作时间由<strong>操作实际时间</strong>决定，十分灵活。</p><p>异步方式根据“请求”和“回答”信号的撤销是否互锁，有以下 3 种情况。</p><ul><li>不互锁：请求与回答均有自己的时间宽度。</li><li>半互锁：请求的撤销取决于收到回答信号。</li><li>全互锁：请求的撤销取决于收到回答信号，回答信号的撤销由取决于请求型号的撤销。</li></ul><figure><img src="/image/25-11-25-1-CompOrg-7-bus/1764678392273.webp" alt="1764678392273" /><figcaption aria-hidden="true">1764678392273</figcaption></figure><h2 id="总线标准">7.4 总线标准</h2><h3 id="系统总线标准">7.4.1 系统总线标准</h3><p>包括总线接口引脚定义、传输速率、驱动能力、信号电平、时序安排、信息格式等。</p><ol type="1"><li><strong>PC/XT</strong></li><li><strong>ISA</strong></li><li><strong>MCA</strong></li><li><strong>EISA</strong></li><li><strong>VL（VESA 局部总线）</strong></li><li><strong>PCI 局部总线</strong></li><li><strong>AGP（图形加速端口）</strong></li><li><strong>PCI-Express（PCI-E）</strong></li></ol><h3 id="外部总线标准">7.4.2 外部总线标准</h3><ol type="1"><li><p><strong>串口和并口</strong></p><ul><li><strong>串口（通信口或 COM 口）</strong><br />数据逐位传送。</li><li><strong>并口</strong><br />并行传送数据，一般有 8 位，如打印机。</li></ul></li><li><p><strong>USB（通用串行总线）</strong><br />一种外设总线标准，使计算机外设可以即插即用。</p></li><li><p><strong>IEEE-1394（i-Link，Fire Wire）</strong><br />支持外设插拔与供电。优点为不要求连接微机，可以直接将数字视频摄像机连接 DV-VCR 进行磁带复制与编辑。</p></li><li><p><strong>eSATA 接口（External Serial ATA）</strong><br />连接外部的 SATA 设备。速度与 USB 3.0 相近，但仅作数据传输，不能供电。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【计算机组成原理】 第六章 中央处理器</title>
      <link href="/2026/01/05/25-11-11-1-CompOrg-6-cpu/"/>
      <url>/2026/01/05/25-11-11-1-CompOrg-6-cpu/</url>
      
        <content type="html"><![CDATA[<h2 id="中央处理器的功能和组成">6.1 中央处理器的功能和组成</h2><h3 id="cpu-的功能">6.1.1 CPU 的功能</h3><p>程序运行过程中，在计算机的各部分之间流动的指令和数据形成<strong>指令流</strong>和<strong>数据流</strong>。</p><ul><li><strong>指令流</strong>：CPU 的指令序列。</li><li><strong>数据流</strong>：根据指令操作要求依次存取的数据的序列。</li></ul><h3 id="cpu-中的主要寄存器">6.1.2 CPU 中的主要寄存器</h3><ol type="1"><li><strong>通用寄存器</strong><ul><li><strong>累加寄存器（Acc）</strong><br />Acc 用于暂时存放 ALU 运算的结果信息。</li></ul></li><li><strong>专用寄存器</strong><ul><li><strong>程序计数器（PC）</strong><ul><li>顺序执行时，PC 内容每次<strong>自增（自动或运算器实现）</strong>。</li><li>改变执行顺序时，将转移的<strong>目标地址</strong>送往寄存器。有时还要<strong>保留改变前的内容</strong>，以便返回时使用。</li></ul></li><li><strong>指令寄存器（IR）</strong><br />存放从存储器中取出的指令。<br />执行指令时，IR 内容<strong>不可变</strong>。</li><li><strong>存储器数据寄存器（MDR）</strong><br />暂存由主存储器读出（或将写入主存）的一条指令或数据字。</li><li><strong>存储器地址寄存器（MAR）</strong><br />当前 CPU 访问的主存单元地址。CPU 与主存有速度差别，MAR 可用于调和速度差异。</li><li><strong>程序状态字寄存器（状态标志寄存器，PSWR）</strong><br />存放<strong>程序状态字（PSR）</strong>。PSR 的位数往往等于机器字长。</li></ul></li></ol><h3 id="cpu-的组成">6.1.3 CPU 的组成</h3><p><img src="/image/25-11-11-1-CompOrg-6-cpu/1762861580587.webp" /></p><ul><li><strong>控制器</strong><ul><li>从主存中取一条指令，指出下一条指令位置。</li><li>译码或测试指令，产生操作控制信号。</li><li>控制 CPU、主存和 IO 设备的数据流方向。</li></ul></li><li><strong>运算器</strong><ul><li>算数运算。</li><li>逻辑运算与测试。</li></ul></li></ul><h3 id="cpu-的主要技术参数">6.1.4 CPU 的主要技术参数</h3><ol type="1"><li><p><strong>字长</strong><br />单位时间内同时处理的二进制数据的位数。</p></li><li><p><strong>内部工作频率（内频、主频）</strong><br />CPU 内<strong>数字脉冲信号</strong>震荡的速度，一般为 MHz、GHz 级。与 CPU 性能存在一定关系，但不绝对。</p></li><li><p><strong>外部工作频率</strong><br /><strong>主板</strong>为 CPU 提供的<strong>基准时钟</strong>频率，百 MHz 级。随着工艺发展，CPU 与其他设备速度差距越来越明显，出现<strong>内部倍频技术</strong>。<br /><span class="math display">\[\text{内频} = \text{外频} \times \text{倍频}\]</span></p></li><li><p><strong>前端总线（FSB）频率</strong><br />前端总线是 CPU 与外界芯片（北桥）交换数据的通道，连接吞吐率高的部件。随着计算机发展，前端总线频率需要高于外屏，采用 QDR 等技术。<br /><span class="math display">\[数据带宽 = 总线频率 \times 数据位宽 \div 8\]</span></p><p>FSB 速度一般为百至千 MHz 级。</p></li><li><p><strong>QPI 数据传输速率</strong><br />QPI 是基于包传输的高速点到点连接技术，MT/s 至 GT/s 级（T/s 为 transfer per sec），用于取代 FSB。<br />基本 QPI 数据包为 80 位，分四次传输，有效数据 16 位，循环冗余校验 4 位。</p></li><li><p><strong>DMI 数据传输速率</strong><br />DMI 是直接媒体接口，基于 PCI-E，用于取代 FSB。<br />DMI 总线带宽<br /><span class="math display">\[理论最大带宽 = 传输速率 \times 编码率 \times 通道数 \div 8\]</span></p></li><li><p><strong>片内 Cache 数量</strong><br />CPU Cache 分为三级。</p><ul><li><p><strong>L1 Cache</strong><br />位于 CPU 内核旁边，与 CPU结合最紧密。分为一级数据缓存（D-Cache）和一级指令缓存（I-Cache）。一般两个缓存容量相同。</p></li><li><p><strong>L2 Cache</strong><br />影响 CPU 性能关键因素之一。CPU 核心不变，增加 L2 可大幅提高性能。容量约为 1 MB。</p></li><li><p><strong>L3 Cache</strong><br />为读取 L2 未命中的数据设计。容量约几兆至几十兆字节。</p></li></ul></li><li><p><strong>工作电压</strong><br />CPU 正常工作所需电压，一般越低越好。</p></li><li><p><strong>地址总线宽度</strong><br />决定 CPU 可访问最大的物理地址空间。</p></li><li><p><strong>数据总线宽度</strong><br />决定 CPU 项外界镜像依次数据传输的最大信息量。</p></li><li><p><strong>TDP 功耗</strong><br />热设计功耗，一般为几瓦，当处理器达到最大负荷时所释放的热量功率。</p></li><li><p><strong>制造工艺</strong><br />线宽指芯片内电路间的距离。现款越小，芯片上的晶体管的数量越多，性能越高。一般为纳米级。</p></li></ol><h2 id="控制器的组成和实验方法">6.2 控制器的组成和实验方法</h2><h3 id="控制器的基本组成">6.2.1 控制器的基本组成</h3><figure><img src="/image/25-11-11-1-CompOrg-6-cpu/1762864206517.webp" alt="1762864206517" /><figcaption aria-hidden="true">1762864206517</figcaption></figure><ol type="1"><li><p><strong>指令部件</strong><br />完成取指令并分析指令。</p><ul><li><strong>程序计数器</strong></li><li><strong>指令寄存器</strong></li><li><strong>指令译码器（操作码译码器，指令功能分析器）</strong><br />对指令的操作码部分进行译码，公告产生控制信号给微操作信号发生器。</li><li><strong>地址形成部件</strong></li></ul></li><li><p><strong>时序部件</strong><br />产生时序信号，以保证各部件有节奏地进行信息传送。</p><ul><li><p><strong>脉冲源</strong><br />使用石英晶振为整个机器提供基准信号。</p></li><li><p><strong>启停控制逻辑</strong><br /></p></li><li><p><strong>节拍信号发生器</strong><br />将基准信号转换为各机器周期的节拍信号。</p></li></ul></li><li><p><strong>微操作信号发生器（控制单元，CU）</strong><br />将一条指令的取出和执行分为很多基本且不可再分割的微操作。</p></li><li><p><strong>中断控制逻辑</strong><br />控制中断处理的硬件逻辑。</p></li></ol><h3 id="控制器的硬件的实现方法">6.2.2 控制器的硬件的实现方法</h3><figure><img src="/image/25-11-11-1-CompOrg-6-cpu/1762865141743.webp" alt="1762865141743" /><figcaption aria-hidden="true">1762865141743</figcaption></figure><ol type="1"><li><strong>组合逻辑型控制器</strong><br />称为常规控制器或硬连线控制器，采用组合逻辑技术，由门电路实现。一般巨型机和 RISC 机使用。<ul><li>优点：速度快。</li><li>缺点：设计、调试、维修、更新困难。</li></ul></li><li><strong>存储逻辑型控制器</strong><br />称为微程序控制器，采用存储逻辑，将微操作信号代码化，将指令转化为微程序存入控制存储器，微操作信号由微指令产生。<ul><li>优点：设计、调试、维修、更新方便。</li><li>缺点：比组合逻辑型控制器慢。</li></ul></li><li><strong>组合逻辑与存储逻辑结合型控制器</strong><br />称为可编程逻辑阵列（PLA）控制器。PLA 实际上是组合逻辑控制器，但是可编程。</li></ol><h2 id="时序系统与控制方式">6.3 时序系统与控制方式</h2><h3 id="时序系统">6.3.1 时序系统</h3><ol type="1"><li><strong>指令周期和机器周期</strong><ul><li><p>指令周期：从取指令、分析取数到执行完成所需全部时间。</p></li><li><p>机器周期：亦作 CPU 周期。将一个指令周期划分为若干机器周期每个机器周期完成一个基本操作。</p><p><span class="math display">\[指令周期 = i \times 机器周期\]</span></p><p>不同指令周期的 <span class="math inline">\(i\)</span> 值差距很大。一条指令最短需要取指、执行两个周期。</p></li></ul></li></ol><p /><ul><li><strong>节拍</strong><br />将一个机器周期分为若干等时的节拍，每个节拍对应一个节拍点位信号。<ul><li><p><strong>统一节拍法</strong><br />以<strong>最复杂的机器周期</strong>为准定出节拍数，所有机器周期长度相等，称为<strong>定长 CPU 周期</strong>。</p></li><li><p><strong>分散节拍法</strong><br />机器周期需要多少节拍就发出多少节拍，称为<strong>不定长 CPU 周期</strong>。</p></li><li><p><strong>延长节拍法</strong><br />照顾多数机器周期要求的情况下，对某些较长机器周期延长一两个节拍。</p></li><li><p><strong>时钟周期插入法</strong><br />时序信号不设置节拍，直接使用时钟周期信号。一个机器周期基本时钟周期数确定后，还可不断插入等待时钟周期。</p></li></ul></li></ul><ol start="3" type="1"><li><p><strong>工作脉冲</strong><br />节拍内设置数个工作脉冲，处于<strong>节拍末尾</strong>，用于保证<strong>所有触发器都可靠、稳定翻转</strong>。</p></li><li><p><strong>多级时序系统</strong><br /><img src="/image/25-11-11-1-CompOrg-6-cpu/1762867517678.webp" alt="1762867517678" /><br />机器周期间、节拍间、工作脉冲间<strong>不允许重叠和空隙</strong>。</p></li><li><p><strong>节拍电位与工作脉冲的时间配合关系</strong></p></li></ol><h3 id="控制方式">6.3.2 控制方式</h3><ol type="1"><li><strong>同步控制方式</strong><br />各项操作由统一的时序信号控制。<ul><li>优点：设计简单，容易实现。</li><li>缺点：速度慢。</li></ul></li><li><strong>异步控制方式</strong><br />各项操作时序根据指令或部件的具体请况决定。这是一种“<strong>应答</strong>”的方式，和操作衔接由“结束—起始”信号实现。<ul><li>优点：提高效率。</li><li>缺点：控制复杂。</li></ul></li><li><strong>联合控制方式</strong><br />同步与异步相结合。在<strong>功能部件内部</strong>采用<strong>同步控制</strong>，在<strong>功能部件之间</strong>采用<strong>异步方式</strong>。</li></ol><h3 id="指令运行的基本过程">6.3.3 指令运行的基本过程</h3><ol type="1"><li><p><strong>取指令阶段</strong><br /><img src="/image/25-11-11-1-CompOrg-6-cpu/1762868462305.webp" alt="1762868462305" /><br />将现行指令从主存中取出并送至指令寄存器。</p><ul><li>将 PC 内容送入 MAR，并送入地址总线（AB）。</li><li>由 CU 经控制总线（CB）向存储器发读命令。</li><li>从主存中取出的指令通过数据总线（DB）送到存储器数据存储器（MDR）。</li><li>将 MDR 内容送进 IR。</li><li>PC 递增。</li></ul><p>以上操作为公共操作，所有指令必须执行。完成取指阶段任务的时间为取指周期。</p><ul><li>地址流动：PC &gt;&gt; MAR &gt;&gt; AB &gt;&gt; DRAM。</li><li>数据流动：主存 &gt;&gt; DB &gt;&gt; MDR &gt;&gt; IR &gt;&gt; 译码器（ID） &gt;&gt; CU。</li></ul></li><li><p><strong>分析取数阶段</strong><br />ID 可识别不同的指令类型（分析），此时计算机开始获取操作数（取数）。</p><ul><li><strong>无操作数指令</strong>：识别出指令后<strong>直接执行</strong>，无需此阶段。</li><li><strong>有操作数指令</strong>：先计算操作数的<strong>有效地址</strong>。<ul><li>若操作数位于<strong>通用寄存器</strong>，无需访问主存。</li></ul></li></ul><p>此阶段又可细分为<strong>间址周期</strong>、<strong>取数周期</strong>等。</p></li><li><p><strong>执行阶段</strong><br />完成指令规定的各种操作，形成稳定的运算结果并存储。</p><pre class="mermaid">   graph LRA["取指令"]B["取数"]A --> BB --> A</pre><p>这三个阶段将周而复始，直到遇见<strong>停机指令</strong>与<strong>外来干预</strong>。</p></li></ol><h3 id="指令的微操作序列">6.3.4 指令的微操作序列</h3><p>控制器在实现功能时需要将功能分解为一系裂<strong>时间上有先后顺序的</strong>、<strong>最基本</strong>、<strong>最简单</strong>的操作。不同的数据通路有不同的微操作序列。</p><figure><img src="/image/25-11-11-1-CompOrg-6-cpu/1762869350176.webp" alt="1762869350176" /><figcaption aria-hidden="true">1762869350176</figcaption></figure><ol type="1"><li><strong>加法指令 <code>ADD@R0, R1</code></strong><br /><span class="math display">\[((R_0)) + (R_1) \rightarrow (R_0)\]</span><br />把 <span class="math inline">\(R_0\)</span> 的内容作为地址送到主存作为操作数，再与 <span class="math inline">\(R_1\)</span> 内容相加，最后放回主存。<ul><li><strong>取指周期</strong><ul><li><span class="math inline">\(\rm PC_{out}\)</span> 与 <span class="math inline">\(\rm MAR_{in}\)</span> 有效，<span class="math inline">\(\rm PC \rightarrow MAR\)</span>。</li><li>通过控制总线向主存发读命令，<code>Read</code>。</li><li>存储器通过数据总线将 <span class="math inline">\(\rm MAR\)</span> 内容送至 <span class="math inline">\(\rm MDR\)</span>，<span class="math inline">\(\rm M(MAR) \rightarrow MDR\)</span>。</li><li><span class="math inline">\(\rm MDR_{out}\)</span> 和 <span class="math inline">\(\rm IR_{in}\)</span> 有效，将 MDR 内容送进 IR，<span class="math inline">\(\rm MDR \rightarrow IR\)</span>。</li><li><span class="math inline">\(\rm PC\)</span> 自增。</li></ul></li><li><strong>取数周期</strong><ul><li><span class="math inline">\(R_{0out}\)</span> 与 <span class="math inline">\(MAR_{in}\)</span> 有效，<span class="math inline">\((R_0) \rightarrow MAR\)</span>。</li><li><code>Read</code>。</li><li>存储器通过数据总线将 MAR 所指单元内容送至 MDR，同时 MDR<sub>out</sub> 与 Y<sub>in</sub> 有效，<span class="math inline">\(M(MAR) \rightarrow MDR \rightarrow Y\)</span>。</li></ul></li><li><strong>执行周期</strong><ul><li>R<sub>1out</sub> 与 ALU<sub>in</sub> 有效，CU 向 ALU 发 <code>ADD</code> 控制信号，结果送至寄存器 Z，<span class="math inline">\((R_1) + Y \rightarrow Z\)</span>。</li><li>Z<sub>out</sub> 与 MDR<sub>in</sub> 有效，<span class="math inline">\((Z) \rightarrow MDR\)</span>。</li><li>向主存发写命令，<code>Write</code>。</li></ul></li></ul></li></ol><h2 id="微程序控制原理">6.4 微程序控制原理</h2><p>将微操作的控制信号按一定规律进行编码，形成控制字，将微指令按时间先后排列构成微程序。</p><h3 id="微程序控制的概念">6.4.1 微程序控制的概念</h3><ol type="1"><li><p><strong>微程序设计的提出与发展</strong></p></li><li><p><strong>基本术语</strong></p><ul><li><strong>微命令与微操作</strong><ul><li>微操作</li><li>微命令：控制部件向执行部件发出的各种控制命令。<ul><li>兼容性：一些微命令可以同时产生，共同完成某些微操作。</li><li>互斥性：一些微命令不能同时出现。</li></ul></li></ul></li><li><strong>微指令与微地址</strong><ul><li>微指令：控制存储器一个单元的内容，是若干微命令的集合，包括<strong>操作控制（微操作码）字段</strong>、<strong>顺序控制（微地址码）字段</strong>。</li><li>微地址：微指令单元的地址。</li><li>垂直型微指令：接近于<strong>机器指令</strong>，只能完成一个基本微操作。</li><li>水平型微指令：并行执行基本微操作。</li></ul></li><li><strong>微周期</strong><br />从控制存储器读取一条微指令到执行完全部微命令。</li><li><strong>微程序</strong><br />一系列微指令的<strong>有序集合</strong>。每一条机器指令对友一个微程序。</li></ul></li></ol><blockquote><p>注意：微程序和程序的区别。</p></blockquote><table style="width:100%;"><colgroup><col style="width: 11%" /><col style="width: 11%" /><col style="width: 11%" /><col style="width: 11%" /><col style="width: 11%" /><col style="width: 11%" /><col style="width: 11%" /><col style="width: 11%" /><col style="width: 11%" /></colgroup><tbody><tr class="odd"><td>编程人员</td><td>计算机</td><td>CPU</td><td>主存</td><td>程序</td><td>指令</td><td>周期</td><td>地址</td><td>微指令</td></tr><tr class="even"><td>设计人员</td><td>CPU</td><td>控制器</td><td>控制存储器</td><td>微程序</td><td>微指令</td><td>微周期</td><td>微地址</td><td>微命令</td></tr></tbody></table><figure><img src="/image/25-11-11-1-CompOrg-6-cpu/1763470913467.webp" alt="1763470913467" /><figcaption aria-hidden="true">1763470913467</figcaption></figure><h3 id="微指令编码法">6.4.2 微指令编码法</h3><ol type="1"><li><strong>直接控制法（不译码法）</strong><br />操作控制字段直接控制计算机，每一位代表一个微命令，<code>0</code> 为无效，<code>1</code> 为有效。<ul><li>优点：结构简单，并行性强。</li><li>缺点：很长，有些微命令互斥。</li></ul></li><li><strong>最短编码法</strong><br />将所有微命令统一编码，微指令微命令一一对应。微命令总数 <span class="math inline">\(N\)</span>，操作控制字段长度 <span class="math inline">\(L\)</span> 满足<br /><span class="math display">\[L \geq \log_2 N\]</span><ul><li>优点：字长最短。</li><li>缺点：微命令数较多时译码器复杂，并行性差。</li></ul></li><li><strong>字段编码法</strong> <sub>666又是凉面派</sub><br />将操作控制字段分为若干小段，每段采用最短编码法。<ul><li><p><strong>字段直接编码法</strong><br />每一个小段独立定义一个微命令。<br /><img src="/image/25-11-11-1-CompOrg-6-cpu/1767449130189.webp" alt="1767449130189" /></p></li><li><p><strong>字段间接编码法</strong><br />微命令由多个小段联合定义。<br /><img src="/image/25-11-11-1-CompOrg-6-cpu/1767449146760.webp" alt="1767449146760" /></p></li><li><p><strong>分段原则</strong></p><ul><li>将互斥的微命令放在相同段，兼容的微命令放在不同段。</li><li>与数据通路结构适应。</li><li>每小段信息不能太多。</li><li>每小段留出一个状态，表示本字段不发出微命令，一般为全 0。</li></ul></li></ul></li></ol><h3 id="微程序控制器的组成与工作过程">6.4.3 微程序控制器的组成与工作过程</h3><ol type="1"><li><p><strong>基本组成</strong><br /><img src="/image/25-11-11-1-CompOrg-6-cpu/1763473031697.webp" alt="1763473031697" /></p><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th>部件</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>控制存储器（CM）</td><td>微程序控制器的<strong>核心部件</strong>，存放<strong>微程序</strong>。</td></tr><tr class="even"><td>微指令寄存器（μIR）</td><td>存放 CM 中取出的微指令，位数同<strong>微指令字长</strong>相等。</td></tr><tr class="odd"><td>微地址形成部件</td><td>产生<strong>初始微地址</strong>和<strong>后继微地址</strong>，保证<strong>连续执行</strong>。</td></tr><tr class="even"><td>微地址寄存器（μMAR）</td><td>接收微地址形成部件送来的<strong>微地址</strong>，为在 CM 读取微指令做准备。</td></tr></tbody></table></li><li><p><strong>工作过程（必考）</strong></p><ul><li><strong>取指令</strong>公共操作。</li><li>产生机器指令所对应的微程序的<strong>入口地址</strong>。</li><li>从 CM 中<strong>逐条取微指令并执行</strong>。</li><li>回到<strong>取指微程序</strong>入口地址，回到 1。</li></ul></li><li><p><strong>机器指令对应的微程序</strong></p><ul><li>通常一条机器指令对应一个微程序。</li><li>系统中有 <span class="math inline">\(n\)</span> 种指令，则控制存储器微程序数至少有 <span class="math inline">\(n + 1\)</span> 个。</li></ul></li></ol><h3 id="微程序入口地址的形成">6.4.4 微程序入口地址的形成</h3><ol type="1"><li><p><strong>一级功能转换</strong><br />如果机器指令操作码字段的位数与位置固定，可以直接使操作码与入口地址部分位相对应。</p></li><li><p><strong>二级功能转换</strong><br /><strong>同类</strong>机器指令操作码字段的位数与位置固定，不同类机器指令操作码字段的位数与位置不固定时，先区分<strong>指令属于哪类</strong>，再确定具体指令。</p></li><li><p><strong>PLA 电路实现功能转换</strong><br />机器指令操作码字段的位数与位置不固定，采用 <strong>PLA 电路</strong>进行翻译，转换速度较快。</p></li></ol><h3 id="后继微地址的形成">6.4.5 后继微地址的形成</h3><p>每条指令完成后需要形成后继微地址。</p><ol type="1"><li><p><strong>增量方式（顺序—转移型微地址）</strong><br />顺序执行时，后记微地址就是先行微地址<strong>加上增量</strong>（通常为 1），</p></li><li><p><strong>断定方式</strong><br />后继微地址可由微程序设计者指定，或根据微指令规定的测试结果直接决定后继微地址的全部与部分值。</p><ul><li>非测试段：可由<strong>设计者</strong>指定，一般是微地址的<strong>高位部分</strong>，指定后继微地址在 <strong>CM 某区域内</strong>。</li><li>测试段：</li></ul></li></ol><h3 id="微程序设计">6.4.6 微程序设计</h3><ol type="1"><li><p><strong>微程序设计方法</strong><br />应考虑尽量缩短微指令字长，减少微程序长度，提高微程序的执行速度。</p><table><colgroup><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /></colgroup><thead><tr class="header"><th>属性</th><th>水平型微指令、水平型微程序设计</th><th>垂直型微指令、垂直型微程序设计</th><th>混合型微指令</th></tr></thead><tbody><tr class="odd"><td>方法</td><td>微指令一次能定义并能并行执行多个微命令</td><td>微指令一次只能执行一个微命令的微指令</td><td>凉面派</td></tr><tr class="even"><td>并行能力、效率、灵活性</td><td>强</td><td>弱</td><td>凉面派</td></tr><tr class="odd"><td>难度</td><td>与机器指令差别大，不易掌握</td><td>与机器指令差别小，易掌握</td><td></td></tr></tbody></table></li></ol><h2 id="控制单元的设计">6.5 控制单元的设计</h2><h3 id="简单的-cpu-模型">6.5.1 简单的 CPU 模型</h3><figure><img src="/image/25-11-11-1-CompOrg-6-cpu/1767537579140.webp" alt="1767537579140" /><figcaption aria-hidden="true">1767537579140</figcaption></figure><ol type="1"><li><p><strong>非访存指令</strong></p></li><li><p><strong>访存指令</strong></p></li><li><p><strong>转移指令</strong></p></li></ol><h3 id="组合逻辑控制单元设计">6.5.2 组合逻辑控制单元设计</h3><ol type="1"><li><strong>微操作节拍安排</strong><br />应当注意：有些操作的次序不容改变；被控对象不同的操作尽量同一节拍完成；短时微操作在同一节拍完成，允许有先后顺序。<ul><li><p><strong>取值周期微操作的节拍安排</strong><br />在 3 个节拍内完成。</p><table><thead><tr class="header"><th>节拍</th><th>操作</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(T_0\)</span></td><td><span class="math inline">\(PC \to MAR\)</span>, Read</td></tr><tr class="even"><td><span class="math inline">\(T_1\)</span></td><td><span class="math inline">\(M(MAR) \to MDR\)</span>, <span class="math inline">\(PC++\)</span></td></tr><tr class="odd"><td><span class="math inline">\(T_2\)</span></td><td><span class="math inline">\((MDR) \to IR\)</span>, 也可继续完成 <span class="math inline">\(OP(IR) \to ID\)</span></td></tr></tbody></table></li><li><p><strong>间址周期微操作的节拍安排</strong></p><table><thead><tr class="header"><th>节拍</th><th>操作</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(T_0\)</span></td><td><span class="math inline">\((MAR) \to MAR\)</span>, Read</td></tr><tr class="even"><td><span class="math inline">\(T_1\)</span></td><td><span class="math inline">\(M(MAR) \to MDR\)</span></td></tr><tr class="odd"><td><span class="math inline">\(T_2\)</span></td><td><span class="math inline">\((MDR) \to MAR\)</span></td></tr></tbody></table></li><li><p><strong>执行周期微操作的节拍安排</strong></p><ul><li><p><strong>非访存指令</strong><br />在执行周期只有一个微操作，按同步控制原则，可安排在 <span class="math inline">\(T_0 \sim T_2\)</span> 任一节拍内，其余留空。</p></li><li><p><strong>访存指令</strong></p></li><li><p><strong>转移类指令</strong></p></li></ul></li></ul></li></ol><h3 id="微程序控制单元设计">6.5.3 微程序控制单元设计</h3><ol type="1"><li><strong>微程序控制单元的设计步骤</strong><ul><li>确定微程序控制方式。</li><li>拟定微命令系统。</li><li>编制微程序。</li><li>微程序代码化。</li><li>写入控制存储器。</li></ul></li><li><strong>设计举例</strong></li></ol><h2 id="流水线技术">6.6 流水线技术</h2><h3 id="重叠控制">6.6.1 重叠控制</h3><p>如果顺序执行，假设取指、分析、执行时间相等，则顺序执行 <span class="math inline">\(n\)</span> 条指令所需时间为<br /><span class="math display">\[T = \sum (t_{取指} + t_{分析} + t_{执行}) = 3nt\]</span><br /><img src="/image/25-11-11-1-CompOrg-6-cpu/1764074468464.webp" alt="1764074468464" /></p><ul><li><p><strong>一次重叠</strong>：将“执行 <span class="math inline">\(K\)</span>”与“取指 <span class="math inline">\(K + 1\)</span>”重叠，时间为<br /><span class="math display">\[T = 3t + (n - 1) \cdot 2t = (2n + 1)t\]</span><br /><img src="/image/25-11-11-1-CompOrg-6-cpu/1764074379946.webp" alt="1764074379946" /></p></li><li><p><strong>二次重叠</strong>：将“分析 <span class="math inline">\(K\)</span>”“取指 <span class="math inline">\(K + 1\)</span>”重叠，“执行 <span class="math inline">\(K\)</span>”“分析 <span class="math inline">\(K + 1\)</span>”“取指 <span class="math inline">\(K + 2\)</span>”重叠，“执行 <span class="math inline">\(K + 1\)</span>”“分析 <span class="math inline">\(K + 2\)</span>”重叠，时间为<br /><span class="math display">\[T = 3t + (n - 1) \cdot t = (n + 2)t\]</span><br /><img src="/image/25-11-11-1-CompOrg-6-cpu/1764074394080.webp" alt="1764074394080" /></p></li></ul><h3 id="先行控制原理">6.6.2 先行控制原理</h3><p>实际上，三次操作的时间不是均等的。为了使各部件能连续地工作，提出了先行控制的方式，如图所示。虽然图中“分析”和“执行”阶段之间有等待的时间间隔<span class="math inline">\(\Delta t_i\)</span>，但它们各自的流程中却是连续的。先行控制的主要目的是使各阶段的专用控制部件不间断的工作，以提高设备的利用率及执行速度。<br /><img src="/image/25-11-11-1-CompOrg-6-cpu/1764075130907.webp" alt="1764075130907" /></p><h3 id="流水工作原理">6.6.3 流水工作原理</h3><ol type="1"><li><p><strong>流水线</strong><br />将一个较复杂的处理过程分成 <span class="math inline">\(m\)</span> 个复杂程度相当、时间大致相等的子过程。每个子过程有一个独立的功能部件来完成，处理对象在各子过程连成的线路上连续流动。同一时间，<span class="math inline">\(m\)</span> 个部件同时执行不同的操作，完成不同的对象处理。</p></li><li><p><strong>流水线分类</strong></p><ul><li><strong>按处理级别分类</strong><ul><li>操作部件级：拆分复杂算数逻辑运算为流水线。</li><li>指令级：拆分执行过程为流水线。</li><li>处理机级（宏流水线）：每个处理机对同意数据流的不同部分进行处理。</li></ul></li><li><strong>按功能分类</strong><ul><li>单功能</li><li>多功能</li></ul></li><li><strong>按工作方式分类</strong><ul><li>静态流水线</li><li>动态流水线</li></ul></li><li><strong>按流水线结构分类</strong><ul><li>线性流水线</li><li>非线性流水线</li></ul></li></ul></li><li><p><strong>指令流水线的相关性</strong></p><ul><li><p><strong>结构相关</strong><br />多条指令在同一时间争夺同一资源。</p></li><li><p><strong>数据相关</strong><br />后一指令还未获取前一指令的结果。</p><ul><li>RAW</li><li>WAR</li><li>WAW</li></ul></li><li><p><strong>控制相关</strong><br />控制相关主要由<strong>转移指令</strong>引起。在无法确定该把哪一段程序放在转移指令之后的局面称为<strong>控制相关</strong>，又称<strong>指令相关</strong>。</p></li></ul></li></ol><h2 id="精简指令系统计算机risc">6.7 精简指令系统计算机（RISC）</h2><p>Reduced Instruction Set Computer.</p><h3 id="risc-的特点和优势">6.7.1 RISC 的特点和优势</h3><ol type="1"><li><p><strong>RISC 的主要特点</strong></p><ul><li>指令总数较少</li><li>基本寻址方式种类少</li><li>指令格式少</li><li>除存取数指令外，大部分指令在单周期内完成。</li><li>除存取数指令外，其他指令均只在寄存器间进行。</li><li>CPU 内通用寄存器多。</li><li>指令执行大多采用硬连线实现，不或少用微程序。</li><li>采用优化的编译技术，以简单的方式支持高级语言</li></ul></li><li><p><strong>RISC 的优势</strong><br />计算机执行一个程序所用时间<br /><span class="math display">\[t = ICT\]</span></p><table><thead><tr class="header"><th>变量</th><th>含义</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(I\)</span></td><td>高级语言编译后在机器上执行的机器指令的总数</td></tr><tr class="even"><td><span class="math inline">\(C\)</span></td><td>执行每条机器指令所需的平均周期数</td></tr><tr class="odd"><td><span class="math inline">\(T\)</span></td><td>每个周期执行时间</td></tr></tbody></table><p>相比 CISC，RISC 的 <span class="math inline">\(I\)</span> 较大，<span class="math inline">\(C\)</span>、<span class="math inline">\(T\)</span> 较小。</p></li></ol><h3 id="risc-基本技术">6.7.2 RISC 基本技术</h3><ol type="1"><li><p><strong>RISC 寄存器管理技术</strong><br />RISC II 使用重叠寄存器窗口，设计一个较大的寄存器堆，划分为很多窗口。</p></li><li><p><strong>流水线技术</strong></p></li><li><p><strong>延时转移技术</strong><br />遇到转移指令时，流水线可能断流。</p><ul><li>延迟转移方法</li><li>优化转移方法</li></ul></li></ol><h2 id="微处理器中的新技术">6.8 微处理器中的新技术</h2><h3 id="超标量与超流水线技术">6.8.1 超标量与超流水线技术</h3><p>提高指令并行性，在每个时钟周期内解释多条指令。</p><h3 id="epic-的指令级并行处理">6.8.2 EPIC 的指令级并行处理</h3><p>使用智能化的软件指挥硬件，实现指令集的并行计算。</p><h3 id="超线程技术ht">6.8.3 超线程技术（HT）</h3><p>将一个物理 CPU 当成两个逻辑 CPU 使用，使 CPU 执行多线程。</p><h3 id="双核与多核技术">6.8.4 双核与多核技术</h3><p>在一个处理器上集成两个或多个运算核心，提高运算能力。</p><h3 id="睿频加速技术">6.8.5 睿频加速技术</h3>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【软件工程学习】 第七章 实现</title>
      <link href="/2026/01/04/26-1-4-2-SoftEng-7-real/"/>
      <url>/2026/01/04/26-1-4-2-SoftEng-7-real/</url>
      
        <content type="html"><![CDATA[<h2 id="编码">7.1 编码</h2><h3 id="选择程序设计语言">7.1.1 选择程序设计语言</h3><ol type="1"><li><strong>选择适宜的程序设计语言的原因</strong><ul><li>根据设计去完成编码时，困难最少；</li><li>可以减少需要的程序测试量；</li><li>可以得到更容易阅读和更容易维护的程序。</li></ul></li><li><strong>高级语言优于汇编语言</strong><ul><li>汇编语言编码需要把软件设计翻译成机器操作的序列，既困难又容易出差错；</li><li>高级语言写程序比用汇编语言写程序生产率可以提高好几倍；</li><li>用高级语言写的程序容易阅读、容易测试、容易调试、容易维护。</li></ul></li></ol><h3 id="编码风格">7.1.2 编码风格</h3><ol type="1"><li><strong>程序内部文档</strong><ul><li>标识符：含义鲜明的名字、缩写规则一致、为名字加注解；</li><li>注解：正确性，简要描述模块的功能、主要算法、接口特点、重要数据以及开发简史或解释包含这段代码的必要性；</li><li>视觉组织：适当的阶梯形式使程序的层次结构清晰明显。</li></ul></li><li><strong>数据说明</strong><br />数据说明的次序应该标准化；<ul><li>当多个变量名在一个语句中说明时，应该按字母顺序排列这些变量；</li><li>如果设计时使用了一个复杂的数据结构，则应该用注解说明用程序设计语言实现这个数据结构的方法和特点。</li></ul></li><li><strong>语句构造</strong><ul><li>不要为了节省空间而把多个语句写在同一行；</li><li>尽量避免复杂的条件测试；</li><li>尽量减少对“非”条件的测试；</li><li>避免大量使用循环嵌套和条件嵌套；<br />利用括号使逻辑表达式或算术表达式的运算次序清晰直观。</li></ul></li><li><strong>输入输出</strong><ul><li>对所有输入数据都进行检验；</li><li>检查输入项重要组合的合法性；</li><li>保持输入格式简单；</li><li>使用数据结束标记，不要要求用户指定数据的数目；</li><li>明确提示交互式输入的请求，详细说明可用的选择或边界数值；</li><li>程序设计语言对格式有严格要求时，应保持输入格式一致；</li><li>设计良好的输出报表；</li><li>给所有输出数据加标志。</li></ul></li><li><strong>效率</strong><ul><li>程序运行时间</li><li>存储器效率</li><li>输入输出效率</li></ul></li></ol><h2 id="软件测试基础">7.2 软件测试基础</h2><h3 id="软件测试的目标">7.2.1 软件测试的目标</h3><p>测试的正确定义是“为了发现程序中的错误而执行程序的过程”。应该认识到<strong>测试决不能证明程序是正确的</strong>。即使经过了最严格的测试之后，仍然可能还有没被发现的错误潜藏在程序中。另外，在综合测试阶段通常由其他人员组成测试小组来完成测试工作。</p><h3 id="软件测试准则">7.2.2 软件测试准则</h3><p>主要的软件测试准则如下：</p><ul><li>所有测试都应该能追溯到<strong>用户需求</strong>；</li><li>应该远在测试开始之前就制定出<strong>测试计划</strong>；</li><li>把 <strong>Pareto 原理</strong>应用到软件测试中；</li><li>应该从“<strong>小规模</strong>”测试开始，并逐步进行“大规模”测试；</li><li>穷举测试是不可能的；</li><li>为了达到最佳的测试效果，应该由<strong>独立的第三方</strong>从事测试工作。</li></ul><h3 id="测试方法">7.2.3 测试方法</h3><ol type="1"><li><p><strong>黑盒测试</strong><br />黑盒测试（又称<strong>功能测试</strong>）把程序看作一个黑盒子，完全不考虑程序的内部结构和处理过程。黑盒测试是在<strong>程序接口</strong>进行的测试，只检查程序功能是否<strong>能按照规格说明书的规定正常使用</strong>，程序是否能<strong>适当地接收输入数据并产生正确的输出信息</strong>，程序运行过程中<strong>能否保持外部信息（例如数据库或文件）的完整性</strong>。</p></li><li><p><strong>白盒测试</strong><br />白盒测试（又称<strong>结构测试</strong>）是把程序看成装在一个透明的白盒子里，测试者完全知道程序的结构和处理算法。这种方法按照程序内部的逻辑测试程序，检测程序中的<strong>主要执行通路是否都能按预定要求正确工作</strong>。</p></li></ol><h3 id="测试步骤">7.2.4 测试步骤</h3><ol type="1"><li><p><strong>模块测试</strong><br />把<strong>每个模块</strong>作为一个单独的实体来测试，而且通常比较容易设计检验模块正确性的测试方案。</p><p>模块测试的目的是保证<strong>每个模块作为一个单元能正确运行</strong>，所以模块测试通常又称为<strong>单元测试</strong>。在这个测试步骤中所发现的往往是<strong>编码和详细设计</strong>的错误。</p></li><li><p><strong>子系统测试</strong><br />子系统测试是把经过单元测试的模块放在一起<strong>形成一个子系统</strong>来测试。<strong>模块相互间的协调和通信</strong>是这个测试过程中的主要问题，因此，这个步骤着重测试<strong>模块的接口</strong>。</p></li><li><p><strong>系统测试</strong><br />系统测试是把经过测试的子系统装配成<strong>一个完整的系统</strong>来测试。在这个过程中不仅应该发现<strong>设计和编码</strong>的错误，还应该验证系统<strong>确实能提供需求说明书中指定的功能</strong>，而且系统的<strong>动态特性</strong>也符合预定要求。在这个测试步骤中发现的往往是<strong>软件设计</strong>中的错误，也可能发现<em>需求说明</em>中的错误。</p></li></ol><p>子系统测试和系统测试，都兼有检测和组装两重含义，通常称为<strong>集成测试</strong>。</p><ol start="4" type="1"><li><p><strong>验收测试</strong><br />验收测试把软件系统作为<strong>单一的实体</strong>进行测试，测试内容与系统测试基本类似，但是它是在<strong>用户积极参与</strong>下进行的，而且可能主要使用<strong>实际数据</strong>（系统将来要处理的信息）进行测试。</p><p>验收测试的目的是验证<strong>系统确实能够满足用户的需要</strong>，在这个测试步骤中发现的往往是<strong>系统需求说明书</strong>中的错误。验收测试也称为<strong>确认测试</strong>。</p></li></ol><h3 id="测试阶段的信息流">7.2.5 测试阶段的信息流</h3><figure><img src="/image/26-1-4-2-SoftEng-7-real/1767511042534.webp" alt="1767511042534" /><figcaption aria-hidden="true">1767511042534</figcaption></figure><h2 id="单元测试">7.3 单元测试</h2><h3 id="测试重点">7.3.1 测试重点</h3><ol type="1"><li><p><strong>模块接口</strong></p><ul><li><strong>测试对象</strong><br />通过模块接口的数据流</li><li><strong>检查方面</strong><ul><li>参数的数目、次序、属性或单位系统与变元是否一致；</li><li>是否修改了只作输入用的变元；</li><li>全局变量的定义和用法在各个模块中是否一致。</li></ul></li></ul></li><li><p><strong>局部数据结构</strong></p><ul><li>局部数据说明</li><li>初始化</li><li>默认值</li></ul></li><li><p><strong>重要执行通路</strong><br />由于通常不可能进行穷尽测试，因此，在单元测试期间选择<strong>最有代表性、最可能发现错误</strong>的执行通路进行测试就是十分关键的。</p><p>应该设计测试方案用来发现由于错误的计算、不正确的比较或不适当的控制流而造成的错误。</p></li><li><p><strong>出错处理通路</strong></p></li><li><p><strong>边界条件</strong><br />使用刚好小于、刚好等于和刚好大于最大值或最小值的数据结构、控制量和数据值的测试方案，非常可能发现软件中的错误。</p></li></ol><h3 id="代码审查">7.3.2 代码审查</h3><h3 id="计算机测试">7.3.3 计算机测试</h3><p>模块并不是一个独立的程序，因此必须为每个单元测试开发驱动软件和（或）存根软件。</p><ol type="1"><li><p><strong>驱动程序</strong><br />通常驱动程序也就是一个“主程序”，它接收测试数据，把这些数据<strong>传送给被测试的模块</strong>，并且印出有关的结果。</p></li><li><p><strong>存根程序</strong><br />存根程序代替被测试的模块所调用的模块。因此存根程序也可以称为“虚拟子程序”。它使用<strong>被它代替的模块的接口</strong>，可能做最少量的数据操作，印出对入口的检验或操作结果，并且把控制归还给调用它的模块。</p></li></ol><h2 id="集成测试">7.4 集成测试</h2><h3 id="模块组装成程序的方法">7.4.1 模块组装成程序的方法</h3><ol type="1"><li><p><strong>非渐增式测试</strong><br />一种方法是先<strong>分别测试每个模块</strong>，再把所有模块按设计要求放在一起结合成所要的程序。<br /><img src="/image/26-1-4-2-SoftEng-7-real/1767511695289.webp" alt="1767511695289" /></p></li><li><p><strong>渐增式测试</strong><br />另一种方法是把<strong>下一个要测试的模块</strong>同<strong>已经测试好的那些模块</strong>结合起来进行测试，测试完以后再把下一个应该测试的模块结合进来测试。这种每次增加一个模块的方法称为渐增式测试，这种方法实际上<strong>同时完成单元测试和集成测试</strong>。<br /><img src="/image/26-1-4-2-SoftEng-7-real/1767511760037.webp" alt="1767511760037" /></p></li></ol><p>目前在进行集成测试时普遍采用渐增式测试方法。</p><ol start="3" type="1"><li><strong>渐增方式的集成策略</strong><ul><li>自顶向下：从主控制模块开始，沿着程序的控制层次向下移动，逐渐把各个模块结合起来。不需要驱动程序。<ul><li>深度优先：先组装在软件结构的一条主控制通路上的所有模块。</li><li>广度优先：沿软件结构水平地移动，把处于同一个控制层次上的所有模块组装起来。</li></ul></li><li>自底向上：从“叶子”模块（即在软件结构最低层的模块）开始组装和测试。<strong>不需要存根程序。</strong></li></ul></li></ol><h3 id="自底向上的结合策略">7.4.2 自底向上的结合策略</h3><ol type="1"><li><p>把低层模块组合成实现某个特定的子功能的族；</p></li><li><p>写一个驱动程序，协调测试数据的输入和输出；</p></li><li><p>对由模块组成的子功能族进行测试；</p></li><li><p>去掉驱动程序，沿软件结构自下向上移动，把子功能族组合起来形成更大的子功能族。</p></li><li><p>重复第 1 到第 4 步。</p></li></ol><figure><img src="/image/26-1-4-2-SoftEng-7-real/1767512185358.webp" alt="1767512185358" /><figcaption aria-hidden="true">1767512185358</figcaption></figure><h3 id="不同集成测试策略的比较">7.4.3 不同集成测试策略的比较</h3><ol type="1"><li><p><strong>自顶向下测试方法</strong></p><ul><li>优点：不需要测试驱动程序，能够在测试阶段的早期实现并验证系统主要功能，发现上层模块接口错误。</li><li>缺点：需要<strong>存根程序</strong>，低层关键模块中的错误发现较晚，不能充分展开人力。</li></ul></li><li><p><strong>自底向上测试方法的优缺点</strong><br />优缺点与自顶向下测试方法相反。</p></li><li><p><strong>混合策略</strong></p><ul><li>1<ul><li>主要使用自顶向下的测试方法</li><li>早期使用自底向上的方法测试软件中的少数关键模块。</li></ul></li><li>2<ul><li>较上层使用自顶向下</li><li>较下层使用自底向上</li></ul></li></ul></li></ol><h3 id="回归测试">7.4.4 回归测试</h3><ol type="1"><li><p><strong>定义</strong><br />回归测试是指<strong>重新执行</strong>已经做过的测试的某个子集（<strong>回归测试集</strong>），以保证上述这些变化<strong>没有带来非预期的副作用</strong>。</p></li><li><p><strong>方法</strong></p><ul><li>通过重新执行全部测试用例的一个子集人工地进行</li><li>也可以使用自动化的捕获回放工具自动进行。</li></ul></li><li><p><strong>回归测试集种类</strong></p><ul><li>检测软件全部功能的代表性测试用例；</li><li>专门针对可能受修改影响的软件功能的附加测试；</li><li>针对被修改过的软件成分的测试。</li></ul></li></ol><h2 id="确认测试">7.5 确认测试</h2><h3 id="定义">7.5.1 定义</h3><p>确认测试也称为验收测试，它的目标是<strong>验证软件的有效性</strong>。</p><h3 id="过程">7.5.2 过程</h3><figure><img src="/image/26-1-4-2-SoftEng-7-real/1767512630095.webp" alt="1767512630095" /><figcaption aria-hidden="true">1767512630095</figcaption></figure><h3 id="alpha-测试和-beta-测试">Alpha 测试和 Beta 测试</h3><ol type="1"><li><p><strong>Alpha 测试</strong><br />Alpha 测试由用户在<strong>开发者的场所</strong>进行，并且在开发者对用户的“指导”下进行测试。开发者负责记录发现的错误和使用中遇到的问题。总之，Alpha 测试是在<strong>受控的</strong>环境中进行的。</p></li><li><p><strong>Beta 测试</strong><br />Beta测试由软件的最终用户们在一个或多个<strong>客户场所</strong>进行。Beta 测试是软件在开发者不能控制的环境中的“真实”应用。</p></li></ol><h2 id="白盒测试技术">7.6 白盒测试技术</h2><h3 id="逻辑覆盖">7.6.1 逻辑覆盖</h3><p>有选择地执行程序中某些最有代表性的通路是对穷尽测试的惟一可行的替代办法。逻辑覆盖是对<strong>一系列测试过程的总称</strong>，这组测试过程逐渐进行<strong>越来越完整的通路测试</strong>。</p><ol type="1"><li><p><strong>语句覆盖</strong><br />选择足够多的测试数据，使被测程序中每个语句<strong>至少执行一次</strong>。</p></li><li><p><strong>判定覆盖</strong><br />又称<strong>分支覆盖</strong>，不仅每个语句必须至少执行一次，而且<strong>每个判定的每种可能的结果</strong>都应该<strong>至少执行一次</strong>。</p></li><li><p><strong>条件覆盖</strong><br />不仅每个语句至少执行一次，而且使判定表达式中的<strong>每个条件</strong>都取到<strong>各种可能的结果</strong>。</p></li><li><p><strong>判定/条件覆盖</strong><br />同时满足这两种覆盖标准的逻辑覆盖。选取足够多的测试数据，使得判定表达式中的每个条件都取到各种可能的值，而且每个判定表达式也都取到各种可能的结果。</p><blockquote><p>有时判定/条件覆盖也并不比条件覆盖更强。</p></blockquote></li><li><p><strong>条件去组合覆盖</strong><br />选取足够多的测试数据，使得<strong>每个判定表达式中条件</strong>的<strong>各种可能组合</strong>都至少出现一次。但是，满足条件组合覆盖标准的测试数据并不一定能使程序中的<strong>每条路径</strong>都执行到。</p></li><li><p><strong>点覆盖</strong><br />选取足够多的测试数据，使得程序执行路径至少经过<strong>流图</strong>的每个结点一次。<strong>点覆盖标准和语句覆盖标准是相同的。</strong></p></li><li><p><strong>边覆盖</strong><br />选取足够多测试数据，使得程序执行路径至少经过<strong>流图</strong>中每条边一次。<strong>边覆盖和判定覆盖是一致的。</strong></p></li><li><p><strong>路径覆盖</strong><br />选取足够多测试数据，使程序的<strong>每条可能路径</strong>都至少执行一次（如果程序图中有环，则要求<strong>每个环</strong>至少经过一次）。</p></li></ol><h3 id="控制结构测试">7.6.2 控制结构测试</h3><ol type="1"><li><p><strong>基本路径测试</strong><br />至少引入程序的一个新处理语句集合或一个新条件的路径，用流图术语描述，独立路径至少包含一条在定义该路径之前<strong>不曾用过的边</strong>。<br /><img src="/image/26-1-4-2-SoftEng-7-real/1767513445244.webp" alt="1767513445244" /></p><ul><li>首先计算程序的<strong>环形复杂度</strong>，</li><li>用该复杂度为指南定义<strong>执行路径的基本集合</strong>，</li><li>从该基本集合导出的测试用例可以保证<strong>程序中的每条语句至少执行一次</strong>，而且<strong>每个条件在执行时都将分别取真、假两种值</strong>。</li></ul></li><li><p><strong>独立路径</strong><br />至少引入程序的一个新处理语句集合或一个新条件的路径，用流图术语描述，独立路径至少包含一条在定义该路径之前不曾用过的边。</p><p>使用基本路径测试法设计测试用例时，<strong>程序的环形复杂度决定了程序中独立路径的数量</strong>，而且这个数是确保程序中<strong>所有语句至少被执行一次所需的测试数量的上界</strong>。</p></li><li><p><strong>条件测试</strong></p><ul><li><p><strong>分支测试</strong><br />对于复合条件 C 来说，C 的<strong>真分支</strong>和<strong>假分支</strong>以及 C 中的<strong>每个简单条件</strong>，都应该<strong>至少执行一次</strong>。</p></li><li><p><strong>域测试</strong><br />要求对一个关系表达式执行 3 个或 4 个测试。</p></li><li><p><strong>布尔表达式测试（穷举法）</strong><br />包含 <span class="math inline">\(n\)</span> 个变量的布尔表达式需要 <span class="math inline">\(2^n\)</span> 个（每个变量分别取真或假这两个可能值的组合数）测试。这个策略可以发现布尔算符、变量和括弧的错误，但是，该策略仅在 <span class="math inline">\(n\)</span> 很小时才是实用的。</p></li><li><p><strong>BRO（Branch and Rational Operator）测试</strong></p></li></ul></li><li><p><strong>循环测试</strong></p></li></ol><h2 id="黑盒测试技术">7.7 黑盒测试技术</h2><h3 id="等价划分">7.7.1 等价划分</h3><p>把程序的输入域划分成<strong>若干个数据类</strong>，据此导出测试用例。一个理想的测试用例能<strong>独自发现一类错误</strong>。</p><h3 id="边界值分析">7.7.2 边界值分析</h3><p>通常输入等价类和输出等价类的边界，就是应该着重测试的程序边界情况。</p><p>选取的测试数据应该刚好等于、刚刚小于和刚刚大于边界值。</p><h3 id="错误推测">7.7.3 错误推测</h3><p>错误推测法在很大程度上靠直觉和经验进行。它的基本想法是列举出程序中可能有的错误和容易发生错误的特殊情况，并且根据它们选择测试方案。</p><h2 id="调试">7.8 调试</h2><h3 id="调试过程">7.8.1 调试过程</h3><p>调试（也称为纠错）作为成功测试的后果出现，也就是说，调试是在测试<strong>发现错误之后排除错误</strong>的过程。</p><h3 id="调试途径">7.8.2 调试途径</h3><ol type="1"><li><p><strong>蛮干法</strong><br />大量打印信息。</p></li><li><p><strong>回溯法</strong><br />从发现症状的地方开始，人工<strong>沿程序的控制流</strong>往回追踪分析源程序代码，直到找出错误原因为止。</p></li><li><p><strong>原因排除法</strong></p><ul><li><p>对分查找法：如果已经知道每个变量在程序内若干个关键点的正确值，则可以用赋值语句或输入语句在程序中点附近“<strong>注入</strong>”<strong>这些变量的正确值</strong>，然后运行程序并检查所得到的输出。如果输出结果是正确的，则错误原因在程序的前半部分；反之，错误原因在程序的后半部分。</p></li><li><p>归纳法：首先把和错误有关的数据组织起来进行分析，以便发现可能的错误原因。然后导出对错误原因的<strong>一个或多个假设</strong>，并利用已有的数据来证明或排除这些假设。</p></li><li><p>演绎法：首先设想出<strong>所有可能的出错原因</strong>，然后试图用测试来排除每一个假设的原因。如果测试表明某个假设的原因可能是真的原因，则对数据进行<strong>细化</strong>以准确定位错误。</p></li></ul></li></ol><h2 id="软件可靠性">7.9 软件可靠性</h2><h3 id="定义-1">7.9.1 定义</h3><ol type="1"><li><p><strong>定义</strong><br />软件可靠性是程序在<strong>给定的时间间隔内</strong>，按照规格说明书的规定<strong>成功地运行</strong>的概率。</p></li><li><p><strong>软件的可用性</strong><br />软件可用性是程序在<strong>给定的时间点</strong>，按照规格说明书的规定，成功地运行的概率。</p></li></ol><h3 id="估算平均无故障时间-mttf-的方法">7.9.2 估算平均无故障时间 MTTF 的方法</h3><ol type="1"><li><p><strong>公式</strong><br />在估算 MTTF 的过程中使用下述符号表示有关的数量：</p><ul><li><span class="math inline">\(E_T\)</span>——测试之前程序中错误总数；</li><li><span class="math inline">\(I_T\)</span>——程序长度（机器指令总数）；</li><li><span class="math inline">\(\tau\)</span>——测试（包括调试）时间；</li><li><span class="math inline">\(E_d(\tau)\)</span>——在 0 至 <span class="math inline">\(\tau\)</span> 期间发现的错误数；</li><li><span class="math inline">\(E_c(\tau)\)</span>——在 0 至 <span class="math inline">\(\tau\)</span> 期间改正的错误数。</li></ul><p><span class="math display">\[MTTF = \frac{1}{K(\frac{E_T}{I_T} - \frac{E_c(\tau)}{I_T})}\]</span></p></li><li><p><strong>基本假定</strong><br />通常<br /><span class="math display">\[-0.5 \times 10^{-2} \leq \frac{E_T}{I_T} \leq 2 \times 10^{-2}\]</span></p><p>也就是说，在测试之前每 1000 条指令中大约有 5～20 个错误。</p></li><li><p><strong>估算平均无故障时间</strong><br />一般取 <span class="math inline">\(K = 200\)</span>.<br /><span class="math display">\[E_c = E_T - \frac{I_T}{K \cdot MTTF}\]</span></p></li><li><p><strong>估计错误总数的方法</strong></p><ul><li>植入错误法：在测试之前由专人在程序中随机地植入一些错误，测试之后，根据测试小组发现的错误中原有的和植入的两种错误的比例，来估计程序中原有错误的总数 <span class="math inline">\(E_T\)</span>。</li><li>分别测试法：随机地把程序中一部分原有的错误加上标记，根据测试过程中发现的有标记错误和无标记错误的比例，估计程序中的错误总数。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【软件工程学习】 第六章 详细设计</title>
      <link href="/2026/01/04/25-10-22-1-SoftEng-6-detailed-design/"/>
      <url>/2026/01/04/25-10-22-1-SoftEng-6-detailed-design/</url>
      
        <content type="html"><![CDATA[<h2 id="结构程序设计">6.1 结构程序设计</h2><h3 id="程序结构设计概念">6.1.1 程序结构设计概念</h3><ol type="1"><li><p><strong>程序结构设计概念的提出</strong><br />1966 年 Böhm 和 Jacopini 证明，使用“顺序”、“选择”、“循环”可实现单入口单出口的程序。实际上“顺序”与“循环”可以实现“选择”，故使用“顺序”、“循环”可实现单入口单出口的程序。</p></li><li><p><strong>结构程序设计定义</strong><br />如果一个程序的代码块仅仅通过顺序、选择和循环这3种基本控制结构进行连接，并且每个代码块只有一个入口和一个出口，则称这个程序是结构化的。</p><p>结构程序设计是尽可能少用 <code>GO TO</code> 语句的程序设计方法。最好仅在检测出错误时才使用 <code>GO TO</code> 语句，而且应该总是使用前向 <code>GO TO</code> 语句。</p></li><li><p><strong>结构程序设计的分类</strong></p><ul><li>如果只允许使用顺序、<code>IF-THEN-ELSE</code> 型分支和<code>DO-WHILE</code> 型循环这 3 种基本控制结构，则称为<strong>经典的结构程序设计</strong>。</li><li>如果除了上述 3 种基本控制结构之外，还允许使用 <code>DO-CASE</code> 型多分支结构和 <code>DO-UNTIL</code> 型循环结构，则称为<strong>扩展的结构程序设计</strong>。</li><li>如果再允许使用 <code>LEAVE</code>（或 <code>BREAK</code>）结构，则称为<strong>修正的结构程序设计</strong>。</li></ul></li></ol><h3 id="程序的几种结构">6.2.2 程序的几种结构</h3><ol type="1"><li><p><strong>什么是好的程序结构？</strong><br />结构清晰、易于读写、易于验证、可靠性好、可维护性高。</p></li><li><p><strong>结构程序</strong><br />只包含三种基本控制结构，且程序块均只有一个入口和一个出口。</p><ul><li><strong>序列结构（开型结构）</strong><br /><pre class="mermaid">     graph LRI(("IN"))A["A"]B["B"]O(("OUT"))I --> A --> B --> O</pre></li><li><strong>选择结构（开型结构）</strong><br /><pre class="mermaid">     flowchart LRI(("IN"))A["A"]B["B"]D{"Decision"}O(("OUT"))I --> D --> A --> OD --> B --> O</pre></li></ul></li></ol><ul><li><strong>循环结构（闭型结构）</strong><br /><pre class="mermaid">    flowchart LRI(("IN"))A["A"]B["B"]D{"Decision"}O(("OUT"))P((" "))D --> A --> PI --> P --> B --> D --> O</pre></li></ul><h2 id="人机界面设计">6.2 人机界面设计</h2><h3 id="设计问题">6.2.1 设计问题</h3><ol type="1"><li><p><strong>系统响应时间</strong><br />系统响应时间指用户完成某个控制动作到软件给出预期的响应的时间。</p><ul><li><p><strong>长度</strong><br />如果系统响应时间过长，用户可能会感到焦急。但是，当用户工作速度由人机界面决定时，过短的系统响应时间会加快用户工作节奏，导致出错。</p></li><li><p><strong>易变性</strong><br />系统响应时间相对平均响应时间的偏差。不稳定的系统响应时间会打乱用户工作节奏，时用户怀疑系统工作出错。</p></li></ul></li><li><p><strong>用户帮助设施</strong></p><ul><li><p>在用户与系统交互期间，<strong>是否任何时刻都能获取帮助</strong>？<br />提供部分帮助信息与提供全部帮助信息。</p></li><li><p><strong>用户怎样请求帮助？</strong><br />帮助菜单、特殊功能键、HELP 命令等。</p></li><li><p><strong>怎样显示帮助信息？</strong><br />独立窗口、指出参考某文档（不理想）、屏幕固定位置简短提示等。</p></li><li><p><strong>用户怎样返回正常工作？</strong></p></li><li><p><strong>怎样组织帮助信息？</strong><br />平面结构、层次结构、超文本结构等。</p></li></ul></li><li><p><strong>出错信息处理</strong><br />一般来讲，交互式系统给出的错误与警告信息，应该</p><ul><li>用用户可以理解的语言描述问题。</li><li>提供从错误中恢复的建设性意见。</li><li>指出错误可能导致哪些负面后果。</li><li>伴随听觉或视觉上的提示。</li><li>不能带有指责色彩。</li></ul></li><li><p><strong>命令交互</strong><br />提供命令交互功能时，必须考虑</p><ul><li>是否每个菜单都有对应命令？</li><li>采用何种命令形式？</li><li>学习和记忆命令的难度有多大？忘记了命令怎么办？</li><li>是否可以定制和缩写？</li></ul></li></ol><h3 id="设计过程">6.2.2 设计过程</h3><p>用户界面设计是一个<strong>迭代</strong>的过程，通常先创建<strong>设计模型</strong>，再用<strong>原型</strong>实现这个设计模型，并由用户<strong>试用和评估</strong>，然后根据用户意见进行<strong>修改</strong>。</p><ol type="1"><li><strong>工具</strong><ul><li>用户界面工具箱</li><li>用户界面开发系统</li><li><strong>作用</strong><br />为简化窗口、菜单、设备交互、出错信息、命令及交互环境的许多其他元素的创建，提供了各种例程或对象。</li><li><strong>方式</strong><ul><li>用基于语言的方式</li><li>基于图形的方式</li></ul></li></ul></li><li><strong>用户界面的评估</strong><ul><li><strong>非正式评估</strong><br />例如，用户即兴发表一些反馈意见；</li><li><strong>正式评估</strong><br />例如，运用统计学方法评价全体终端用户填写的调查表。</li></ul></li></ol><h3 id="人机界面设计指南">6.2.3 人机界面设计指南</h3><ol type="1"><li><p><strong>一般交互指南</strong><br />一般交互指南涉及信息显示、数据输入和系统整体控制，因此，这类指南是全局性的，忽略它们将承担较大风险。</p><p>一个交互界面应该做到</p><ul><li><p><strong>保持一致性</strong><br />菜单选择、命令输入、数据显示等应使用已知的功能。</p></li><li><p><strong>提供有意义的反馈</strong></p></li><li><p><strong>在执行有较大破坏性的操作前应要求用户确认</strong></p></li><li><p><strong>允许取消（回退）绝大多数操作</strong><br /></p></li><li><p><strong>减少两次操作器件需要记忆的信息</strong></p></li><li><p><strong>提高对话、移动、思考的效率</strong></p></li><li><p><strong>允许犯错</strong><br />保护自己不受严重错误的破坏。</p></li><li><p><strong>按功能对动作分类，据此设计屏幕布局</strong></p></li><li><p><strong>提供对用户工作内容敏感的帮助设施</strong></p></li><li><p><strong>用简单的动词短语作为命令名</strong></p></li></ul></li><li><p><strong>信息显示指南</strong></p><ul><li>只显示与当前工作内容有关的信息。</li><li>不要用数据淹没用户，应该用便于用户迅速吸取信息的方式来表示数据。</li><li>使用一致的标记、标准的缩写和可预知的颜色。</li><li>允许用户保持可视化的语境。</li><li>产生有意义的出错信息。</li><li>使用大小写、缩进和文本分组以帮助理解。</li><li>使用窗口分隔不同类型的信息。</li><li>使用“模拟”显示方式表示信息，以使信息更容易被用户提取。</li><li>高效率地使用显示屏。</li></ul></li><li><p><strong>数据输入指南</strong></p><ul><li>尽量减少用户的输入动作。</li><li>保持信息显示和数据输入之间的一致性。</li><li>允许用户自定义输入。</li><li>交互应该是灵活的，并且可调整成用户最喜欢的输入方式。</li><li>使在当前动作语境中不适用的命令不起作用。</li><li>让用户控制交互流。</li><li>对所有输入动作都提供帮助</li><li>消除冗余的输入。</li></ul></li></ol><h2 id="过程设计的工具">6.3 过程设计的工具</h2><h3 id="程序流程图">6.3.1 程序流程图</h3><p>图例<br /><img src="/image/25-10-22-1-SoftEng-6-detailed-design/1761095660399.webp" alt="1761095660399" /></p><h3 id="盒图">6.3.2 盒图</h3><p>盒图是一种不违背结构程序设计精神的图形工具。它有下述特点</p><ul><li>功能域（即一个特定控制结构的作用域）明确，可以从盒图上一眼就看出来。</li><li>不可能任意转移控制。</li><li>很容易确定局部和全程数据的作用域。</li><li>很容易表现嵌套关系，也可以表示模块的层次结构。</li></ul><figure><img src="/image/25-10-22-1-SoftEng-6-detailed-design/1761096060061.webp" alt="1761096060061" /><figcaption aria-hidden="true">1761096060061</figcaption></figure><h3 id="pad-图">6.3.3 PAD 图</h3><p>PAD 图使用二维树形结构表示程序流程，使将图翻译位代码操作较为容易。<br /><img src="/image/25-10-22-1-SoftEng-6-detailed-design/1761096203817.webp" alt="1761096203817" /><br /><img src="/image/25-10-22-1-SoftEng-6-detailed-design/1761096281557.webp" alt="1761096281557" /></p><h3 id="判定表">6.3.4 判定表</h3><p>判定表能够清晰地表示复杂的条件组合与应做的动作之间的对应关系。<br /><img src="/image/25-10-22-1-SoftEng-6-detailed-design/1761096416216.webp" alt="1761096416216" /></p><h3 id="判定树">6.3.5 判定树</h3><p>判定树是判定表的变种，它也能清晰地表示复杂的条件组合与应做的动作之间的对应关系。判定树的优点在于，它的形式简单到不需任何说明，一眼就可以看出其含义，因此易于掌握和使用。<br /><img src="/image/25-10-22-1-SoftEng-6-detailed-design/1761096520552.webp" alt="1761096520552" /></p><h3 id="过程设计语言">6.3.6 过程设计语言</h3><p>过程设计语言（PDL）也称为<strong>伪码</strong>，这是一个笼统的名称，现在有许多种不同的过程设计语言在使用。它是用正文形式表示数据和处理过程的设计工具。</p><p>PDL 应该具有下述特点。</p><ul><li>关键字的固定语法，它提供了结构化控制结构、数据说明和模块化的特点。</li><li>自然语言的自由语法，它描述处理特点。</li><li>数据说明的手段。</li><li>模块定义和调用的技术，应该提供各种接口描述模式。</li></ul><p>PDL 作为一种设计工具有如下一些优点。</p><ul><li>可以作为注释直接插在源程序中间。</li><li>可以使用普通的正文编辑程序或文字处理系统，很方便地完成 PDL 的书写和编辑工作。</li><li>已经有自动处理 PDL 的程序存在，而且可以自动由 PDL 生成程序代码。</li></ul><h2 id="面向数据结构的设计方法">6.4 面向数据结构的设计方法</h2><p>面向数据结构的设计方法的最终目标是得出对程序处理过程的描述。这种设计方法并不明显地使用软件结构的概念，模块是设计过程的副产品，对于模块独立原理也没有给予应有的重视。因此，这种方法最适合于在详细设计阶段使用，也就是说，在完成了软件结构设计之后，可以使用面向数据结构的方法来设计每个模块的处理过程。</p><h3 id="jackson-图">6.4.1 Jackson 图</h3><figure><img src="/image/25-10-22-1-SoftEng-6-detailed-design/1767507960183.webp" alt="1767507960183" /><figcaption aria-hidden="true">1767507960183</figcaption></figure><h3 id="改进的-jackson-图">6.4.2 改进的 Jackson 图</h3><figure><img src="/image/25-10-22-1-SoftEng-6-detailed-design/1767508003246.webp" alt="1767508003246" /><figcaption aria-hidden="true">1767508003246</figcaption></figure><h3 id="jackson-法">6.4.3 Jackson 法</h3><p>Jackson 结构程序设计方法基本上由下述 5 个步骤组成。</p><ol type="1"><li><p>分析并确定输入数据和输出数据的逻辑结构，并用 Jackson 图描绘这些数据结构。</p></li><li><p>找出输入数据结构和输出数据结构中有对应关系的数据单元。</p></li><li><p>用下述 3 条规则从描绘数据结构的 Jackson 图导出描绘程序结构的 Jackson 图。</p><ul><li>为每对有对应关系的数据单元，按照它们在数据结构图中的层次在程序结构图的相应层次画一个处理框。</li><li>根据输入数据结构中剩余的每个数据单元所处的层次，在程序结构图的相应层次分别为它们画上对应的处理框。</li><li>根据输出数据结构中剩余的每个数据单元所处的层次，在程序结构图的相应层次分别为它们画上对应的处理框。</li></ul></li><li><p>列出所有操作和条件（包括分支条件和循环结束条件），并且把它们分配到程序结构图的适当位置。</p></li><li><p>用伪码表示程序。<br />Jackson方法中使用的伪码和Jackson图是完全对应的。</p></li></ol><h2 id="程序复杂度的定量度量">6.5 程序复杂度的定量度量</h2><h3 id="mccabe-方法">6.5.1 McCabe 方法</h3><ol type="1"><li><p><strong>流图</strong><br />McCabe 方法根据程序控制流的复杂程度定量度量程序的复杂程度，这样度量出的结果称为<strong>程序的环形复杂度</strong>。</p><p>流图实质上是“退化了的”程序流程图，描绘程序的控制流程，<strong>不表现对数据的具体操作以及分支或循环的具体条件</strong>。</p><figure><img src="/image/25-10-22-1-SoftEng-6-detailed-design/1767508343735.webp" alt="1767508343735" /><figcaption aria-hidden="true">1767508343735</figcaption></figure></li><li><p><strong>计算环形复杂度</strong></p><ul><li>流图中线性无关的区域数等于环形复杂度。</li><li>流图 <span class="math inline">\(G\)</span> 的环形复杂度 <span class="math inline">\(V(G)=E-N+2\)</span>，其中，<span class="math inline">\(E\)</span> 是流图中边的条数，<span class="math inline">\(N\)</span> 是结点数。</li><li>流图 <span class="math inline">\(G\)</span> 的环形复杂度 <span class="math inline">\(V(G)=P+1\)</span>，其中，<span class="math inline">\(P\)</span> 是流图中判定结点的数目。</li></ul></li><li><p><strong>环形复杂度的原理</strong><br /><code>if</code>、<code>for</code>、<code>while</code> 语句都是判定语句。如果程序只有顺序语句，程序不会形成封闭区域，计其复杂度为 1。判定语句会形成封闭的区域，<strong>每增加 1个判定语句，增加一个区域，复杂度 +1</strong>。</p></li><li><p><strong>环形复杂度的用途</strong><br />对测试难度的一种定量度量，也能对软件最终的可靠性给出某种预测。实践表明，模块规模以 <span class="math inline">\(V(G) \leq 10\)</span> 为宜。</p></li></ol><h3 id="halstead-方法">6.5.2 Halstead 方法</h3><p>根据程序中运算符和操作数的总数来度量程序的复杂程度。</p><p>令 <span class="math inline">\(N_1\)</span> 为程序中运算符出现的总次数，<span class="math inline">\(N_2\)</span> 为操作数出现的总次数，程序长度 <span class="math inline">\(N\)</span> 定义为：<br /><span class="math display">\[N=N_1+N_2\]</span></p><p>程序中使用的不同运算符（包括关键字）的个数 <span class="math inline">\(n_1\)</span>，以及不同操作数（变量和常数）的个数 <span class="math inline">\(n_2\)</span>。Halstead 给出预测程序长度的公式如下：<br /><span class="math display">\[H = n_1 \log_2n_1+n_2 \log_2n_2\]</span></p><p>多次验证都表明，预测的长度 <span class="math inline">\(H\)</span> 与实际长度 <span class="math inline">\(N\)</span> 非常接近。</p><p>Halstead 还给出了预测程序中包含错误的个数的公式如下：<br /><span class="math display">\[E = \frac{N \log_2(n_1+n_2)}{3000}\]</span></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【软件工程学习】 第五章 总体设计</title>
      <link href="/2026/01/04/26-1-4-1-SoftEng-5-general-dgn/"/>
      <url>/2026/01/04/26-1-4-1-SoftEng-5-general-dgn/</url>
      
        <content type="html"><![CDATA[<h3 id="一-总体设计概述">一、 总体设计概述</h3><ol type="1"><li><strong>定义与目的</strong>：<ul><li>总体设计（又称概要设计或初步设计）的基本目的是回答“概括地说，系统应该如何实现”这个问题。</li><li>核心任务是设计软件结构，确定系统由哪些模块组成以及模块间的关系。</li></ul></li><li><strong>设计过程</strong>：<ul><li>包含两个阶段：<strong>系统设计</strong>（从技术角度考虑最佳方案）和<strong>结构设计</strong>（确定程序结构）。</li><li>典型步骤包括：设想供选择的方案、选取合理方案、推荐最佳方案、功能分解、设计软件结构、设计数据库、制定测试计划、书写文档、审查和复审。<br />### 二、 设计原理</li></ul></li><li><strong>模块化</strong>：<ul><li>模块是由边界元素限定的程序元素序列（如过程、函数、对象）。模块化是将系统划分为独立命名的模块。</li><li>虽然增加模块数量可以降低单个模块成本，但会增加接口成本，因此存在一个使总成本最小的最佳模块数目。</li><li><strong>优势</strong>：结构清晰、易于理解、测试调试方便、提高可靠性和可修改性、便于组织管理。</li></ul></li><li><strong>抽象</strong>：<ul><li>抽象是抽出事物的本质特性而忽略细节。软件工程的每一步都是对解法抽象层次的精化。</li></ul></li><li><strong>逐步求精</strong>：<ul><li>为了集中精力解决主要问题，尽量推迟对细节的考虑。这是自顶向下的设计策略，与模块化紧密相关。</li></ul></li><li><strong>信息隐藏和局部化</strong>：<ul><li><strong>信息隐藏</strong>：一个模块内的信息（过程和数据）对于不需要它的模块是不可访问的。</li><li><strong>局部化</strong>：把关系密切的软件元素物理上靠近放置。</li></ul></li><li><strong>模块独立</strong>：<ul><li>这是核心设计目标。独立的模块易于开发、测试和维护。</li><li>衡量标准有两个：<strong>内聚</strong>（模块内部元素的紧密程度）和<strong>耦合</strong>（模块之间的互连程度）。</li><li><strong>目标</strong>：<strong>高内聚、低耦合</strong>。<br />### 三、 耦合与内聚的类型</li></ul></li><li><strong>耦合（由低到高）</strong>：<ul><li><strong>数据耦合</strong>：仅通过参数交换数据（最好）。</li><li><strong>控制耦合</strong>：传递控制信息（开关标志）。</li><li><strong>特征耦合</strong>：传递整个数据结构但只用一部分。</li><li><strong>公共环境耦合</strong>：通过全局变量、共享内存等进行通信。</li><li><strong>内容耦合</strong>：一个模块直接访问另一个模块内部（应避免）。</li></ul></li><li><strong>内聚（由低到高）</strong>：<ul><li><strong>偶然内聚</strong>：模块内任务无关系。</li><li><strong>逻辑内聚</strong>：逻辑上相似的任务（如不同类型的输入）。</li><li><strong>时间内聚</strong>：同一时间段内执行的任务（如初始化）。</li><li><strong>过程内聚</strong>：特定次序执行的任务。</li><li><strong>通信内聚</strong>：使用相同输入/输出数据的操作。</li><li><strong>顺序内聚</strong>：前一步的输出是后一步的输入。</li><li><strong>功能内聚</strong>：所有元素共同完成单一功能（最好）。<br />### 四、 启发式设计规则<br />为了获得良好的软件结构，设计时应遵循以下规则：</li></ul></li><li><strong>改进软件结构提高模块独立性</strong>：降低耦合，提高内聚。</li><li><strong>模块规模适中</strong>：通常以一页纸（约60行）为宜。</li><li><strong>深度、宽度、扇出、扇入适当</strong>：<ul><li>扇出（调用下级模块数）通常控制在3-4个，扇入（被上级调用数）越大越好。</li></ul></li><li><strong>模块的作用域应在控制域之内</strong>：受判定影响的模块应从属于做出判定的模块。</li><li><strong>降低模块接口的复杂程度</strong>：接口应简单且与模块功能一致。</li><li><strong>设计单入口单出口的模块</strong>：避免内容耦合。</li><li><strong>模块功能应该可以预测</strong>。<br />### 五、 描绘软件结构的图形工具</li><li><strong>层次图</strong>：用于描绘软件的层次结构，矩形框代表模块，方框间的连线表示调用关系。</li><li><strong>HIPO图</strong>（层次图+输入/处理/输出图）：由IBM公司发明，增加了IPO图以描述每个模块的输入、处理和输出。</li><li><strong>结构图</strong>：<ul><li>方框代表模块，箭头表示调用关系。</li><li>附加符号：空心圆表示传递数据，实心圆表示传递控制信息，菱形表示判断调用，箭头加环表示循环调用。<br />### 六、 面向数据流的设计方法<br />这是将数据流图（DFD）映射成软件结构的方法。信息流主要分为两种：</li></ul></li><li><strong>变换流</strong>：信息沿输入通路进入，经过变换中心处理，再沿输出通路离开。<ul><li><strong>变换分析步骤</strong>：复查基本系统模型 -&gt; 复查并精化DFD -&gt; 确定边界（输入流、变换中心、输出流）-&gt; 第一级分解（顶层控制、输入控制、变换控制、输出控制）-&gt; 第二级分解（将处理映射为模块）-&gt; 精化。</li></ul></li><li><strong>事务流</strong>：数据沿输入通路到达一个事务中心，根据输入类型选择执行某一动作序列。<ul><li><strong>事务分析</strong>：软件结构包含接收分支和发送分支。<br />### 七、 设计优化</li></ul></li></ol><ul><li>在不牺牲清晰度的前提下，对软件结构进行精化。</li><li>对时间起决定性作用的模块，可在详细设计阶段进行算法优化，必要时用低级语言重写核心代码。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【软件工程学习】 第三章 需求分析</title>
      <link href="/2026/01/02/25-12-3-1-SoftEng-3-demand-aly/"/>
      <url>/2026/01/02/25-12-3-1-SoftEng-3-demand-aly/</url>
      
        <content type="html"><![CDATA[<p>需求分析是软件定义时期的最后一个阶段，它的基本任务是准确地回答“系统必须做什么”这个问题。</p><h2 id="需求分析的任务">3.1 需求分析的任务</h2><h3 id="确定对系统的综合要求">3.1.1 确定对系统的综合要求</h3><p>通常对软件系统有下述几方面的综合要求。</p><ul><li><p><strong>功能需求</strong><br />指定系统必须提供的服务。</p></li><li><p><strong>性能需求</strong><br />指定系统必须满足的定时约束或容量约束。</p></li><li><p><strong>可靠性和可用性需求</strong><br />定量地指定系统的可靠性。可用性与可靠性密切相关，它量化了用户可以使用系统的程度。</p></li><li><p><strong>出错处理需求</strong><br />系统对环境错误应该怎样响应。</p></li><li><p><strong>接口需求</strong><br />应用系统与它的环境通信的格式。</p></li><li><p><strong>约束</strong><br />在设计或实现应用系统时应遵守的限制条件。</p></li><li><p><strong>逆向需求</strong><br />软件系统不应该做什么。</p></li><li><p><strong>将来可能提出的要求</strong><br />虽然不属于当前系统开发范畴，但是据分析将来很可能会提出来的要求。</p></li></ul><h3 id="分析系统的数据要求">3.1.2 分析系统的数据要求</h3><p>任何一个软件系统本质上都是信息处理系统，系统必须处理的信息和系统应该产生的信息在很大程度上决定了系统的面貌，对软件设计有深远影响。</p><p>复杂的数据由许多基本的数据元素组成，数据结构表示数据元素之间的逻辑关系。利用数据字典可以全面准确地定义数据，但是数据字典的缺点是不够形象直观。为了提高可理解性，常常利用图形工具辅助描绘数据结构。</p><h3 id="导出系统的逻辑模型">3.1.3 导出系统的逻辑模型</h3><p>综合上述两项分析的结果可以导出系统的详细的逻辑模型，通常用数据流图、实体联系图、状态转换图、数据字典和主要的处理算法描述这个逻辑模型。</p><h3 id="修正系统开发计划">3.1.4 修正系统开发计划</h3><p>根据在分析过程中获得的对系统的更深入更具体的了解，可以比较准确地估计系统的成本和进度，修正以前制定的开发计划。</p><h2 id="与用户沟通获取需求的方法">3.2 与用户沟通获取需求的方法</h2><h3 id="访谈">3.2.1 访谈</h3><h3 id="面向数据流自顶向下求精">3.2.2 面向数据流自顶向下求精</h3><p>结构化分析方法就是面向数据流自顶向下逐步求精进行需求分析的方法。通过可行性研究已经得出了目标系统的高层数据流图，需求分析的目标之一就是把数据流和数据存储定义到元素级。</p><p>为了达到这个目标，通常从数据流图的输出端着手分析，这是因为系统的基本功能是产生这些输出，输出数据决定了系统必须具有的最基本的组成元素。</p><p><strong>数据流图的输出端分析方法</strong></p><ul><li>输出数据是由哪些元素组成的呢？</li><li>每个输出数据的元素是从哪里来的呢？</li></ul><h3 id="建议的应用规格说明技术">3.2.3 建议的应用规格说明技术</h3><p>简易的应用规格说明技术是为了解决使用传统的访谈或面向数据流自顶向下求精方法定义需求时，用户处于被动地位而且往往有意无意地与开发者区分“彼此”。</p><ol type="1"><li><p><strong>规格说明文档或规约（Specifications）</strong><br />明确描述产品<strong>功能</strong>，列出产品要满足的任何<strong>约束</strong>，包括输入输出。</p><ul><li>这是正规的有法律效力的文档，不能包括不严密的术语。</li><li>对于测试与维护都是必需的。</li></ul></li><li><p><strong>规格测试一定要避免</strong></p><ul><li>不明确、二义性（Ambigous）</li><li>不完整（Incomplete）</li><li>矛盾（Contradictory）</li></ul></li><li><p><strong>需求分析规格说明书</strong></p><ul><li>系统规格说明<ul><li>系统概貌</li><li>功能、性能、运行要求</li><li>可增加的要求</li><li>DFD</li><li>IPO</li></ul></li><li>数据要求<ul><li>DD</li><li>Hierarchy 或 Warnier Diagram</li></ul></li><li>用户系统描述——初步用户手册：从用户的观点考虑系统<ul><li>系统功能、性能</li><li>使用与步骤等</li></ul></li><li>修正的开发计划<ul><li>系统功能、性能</li><li>资源使用计划</li><li>进度计划</li></ul></li></ul></li></ol><h3 id="快速建立软件原型">3.2.4 快速建立软件原型</h3><p>为了快速地构建和修改原型，通常使用下述 3 种方法和工具。</p><ul><li><p>第四代技术</p><blockquote><p><strong>4GL</strong></p><p>第四代语言（Fourth-Generation Language, 以下简称 4GL）在 80 年代初期出现，这一类语言由于具有“<strong>面向问题</strong>”、“<strong>非过程化程度高</strong>”等特点。</p><p>4GL 以数据库管理系统所提供的功能为核心，进一步构造了开发高层软件系统的开发环境，如报表生成、多窗口表格设计、菜单生成系统、图形图象处理系统和决策支持系统，为用户提供了一个良好的应用开发环境。它提供了功能强大的非过程化问题定义手段，<strong>用户只需告知系统做什么，而无需说明怎么做</strong>，因此可大大提高软件生产率。</p><p>进入 90 年代，大量基于数据库管理系统的 4GL 商品化软件已在计算机应用开发领域中获得广泛应用，成为了面向数据库应用开发的主流工具，如 Oracle 应用开发环境、Informix－4GL、SQL Windows、Power Builder 等。</p></blockquote></li><li><p>可重用的软件构件</p><ul><li>构件/组件: Component, 是一个<strong>功能相对独立</strong>的具有<strong>可复用性</strong>的软件单元。是软件系统可替换的、物理的组成部分， 他封装了实现体（实现某个功能），并提供了一组接口的实现方法。</li></ul><blockquote><p><strong>常用构件标准（COM/DCOM/COM+、CORBA和EJB）</strong></p><ul><li>Microsoft 微软：COM: 构件对象模型 Component Object Model DCOM: 分布式构件对象模型 Distributed Component Object Model COM+: COM+是COM、DCOM和MTS(Microsoft Transaction Server)的集成,形成一个全新的、功能强大的组件体系结构. 微软的分布式DCOM扩展了COM,使其能够支持在局域网、广域网、Internet上不同计算机的对象之间的通信。 DCOM具有语言无关性，任何语言都可以用来创建COM构件。</li><li>CMG(Object Management Group,对象管理集团)： CORBA: 公共对象请求代理 Common Object Request Broker Architecture,</li><li>Sun: EJB: Enterprise JavaBean, 企业JavaBean EJB是用于开发和部署多层结构的、分布式的、面向对象的JAVA应用系统的跨平台的构件架构。</li></ul></blockquote></li><li><p>形式化规格说明和原型环境</p></li></ul><p>快速原型就是快速建立起来的旨在演示目标系统主要功能的可运行的程序，快速原型应该具备的特性：</p><ul><li>快速</li><li>易修改</li></ul><h2 id="分析建模与规格说明">3.3 分析建模与规格说明</h2><h3 id="分析建模">3.3.1 分析建模</h3><p>模型，就是为了理解事物而对事物作出的一种抽象，是对事物的一种无歧义的书面描述。</p><p>为了开发复杂的系统，应从不同角度（模型）抽象出目标系统的特性（<strong>数据模型、功能模型、行为模型</strong>）</p><h3 id="软件需求规格说明">3.3.2 软件需求规格说明</h3><p>软件需求规格说明是<strong>需求分析阶段</strong>得出的<strong>最主要的文档</strong>。</p><p>通常用自然语言完整、准确、具体地描述系统的数据要求、功能需求、性能需求、可靠性和可用性要求、出错处理需求、接口需求、约束、逆向需求以及将来可能提出的要求。</p><h2 id="实体联系图">3.4 实体联系图</h2><p>数据模型中包含 3 种相互关联的信息：<strong>数据对象</strong>、数据对象的<strong>属性</strong>及数据对象彼此间<strong>相互连接的关系</strong>。</p><figure><img src="/image/25-12-3-1-SoftEng-3-demand-aly/1767358033145.webp" alt="1767358033145" /><figcaption aria-hidden="true">1767358033145</figcaption></figure><h3 id="数据对象">3.4.1 数据对象</h3><p>数据对象是对软件必须理解的<strong>复合信息的抽象</strong>。</p><p>数据对象可以是外部实体、事物、行为、事件、角色、单位、地点或结构等。总之，<strong>可以由一组属性来定义的实体</strong>都可以被认为是数据对象。</p><h3 id="属性">3.4.2 属性</h3><p>属性定义了数据对象的<strong>性质</strong>。</p><p>必须把一个或多个属性定义为“<strong>标识符</strong>”，也就是说，当人们希望找到数据对象的一个实例时，用标识符属性作为“关键字”（通常简称为“<strong>键</strong>”）。</p><h3 id="联系">3.4.3 联系</h3><p>数据对象彼此之间相互连接的方式称为联系，也称为关系。</p><ul><li>一对一联系（1∶1）</li><li>一对多联系（1∶N）</li><li>多对多联系（M∶N）</li></ul><h3 id="实体联系图的符号">3.4.4 实体联系图的符号</h3><p>ER 图中包含了<strong>实体</strong>即数据对象、<strong>关系</strong>和<strong>属性</strong> 3 种基本成分，通常用<strong>矩形框</strong>代表实体，用连接相关实体的<strong>菱形框</strong>表示关系，用<strong>椭圆形或圆角矩形</strong>表示实体（或关系）的属性，并用<strong>直线</strong>把实体（或关系）与其属性连接起来（有时需标明联系的数量关系）。</p><h3 id="数据规范化">3.5 数据规范化</h3><p>为<strong>减少数据冗余</strong>，<strong>避免出现插入异常或删除异常</strong>，<strong>简化修改数据的过程</strong>，通常需要把数据结构规范化。</p><p>通常用“范式（normal forms）”定义消除数据冗余的程度。</p><ul><li><strong>第一范式</strong> 每个属性值都<strong>必须是原子值</strong>，即仅仅是一个简单值而不含内部结构。</li><li><strong>第二范式</strong> 满足第一范式条件，而且每个非关键字属性都<strong>由整个关键字决定</strong>（而不是由关键字的一部分来决定）。</li><li><strong>第三范式</strong> 符合第二范式的条件，每个非关键字属性都仅由关键字决定，而且一<br />个非关键字属性不能仅仅是对另一个非关键字属性的进一步描述（即<strong>一个非关键字属性值不依赖于另一个非关键字属性值</strong>）。</li></ul><h3 id="状态转换图">3.6 状态转换图</h3><p>状态转换图（简称为状态图）通过描绘系统的状态及引起系统状态转换的事件，来表示系统的行为。此外，状态图还指明了作为特定事件的结果系统将做哪些动作。</p><h3 id="状态">3.6.1 状态</h3><p>状态是<strong>任何可以被观察到的系统行为模式</strong>，一个状态代表系统的一种行为模式。状态规定了系统对事件的响应方式。</p><p>在状态图中定义的状态主要有：初态（即初始状态）、终态（即最终状态）和中间状态。在一张状态图中<strong>只能有一个初态</strong>，而终态则可以有 0 至多个。</p><p>状态图既可以表示系统循环运行过程，也可以表示系统单程生命期。</p><h3 id="事件">3.6.2 事件</h3><p>事件是在某个特定时刻发生的事情，它是对引起系统做动作或（和）从一个状态转换到另一个状态的外界事件的抽象。</p><h3 id="符号">3.6.3 符号</h3><p>在状态图中，初态用<strong>实心圆</strong>表示，终态用<strong>一对同心圆（内圆为实心圆）</strong>表示。</p><p>中间状态用圆角矩形表示，可以用两条水平横线把它分成上、中、下 3 个部分。上面部分为<strong>状态的名称</strong>，这部分是必须有的；中间部分为<strong>状态变量的名字和值</strong>，这部分是可选的；下面部分是<strong>活动表</strong>，1 这部分也是可选的。</p><p>活动表的语法格式如下：</p><p>事件名(参数表)/动作表达式其中，“事件名”可以是任何事件的名称。</p><p>在活动表中经常使用下述3种标准事件：entry，exit 和 do。</p><table><thead><tr class="header"><th>事件</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>entry</td><td>进入该状态的动作</td></tr><tr class="even"><td>exit</td><td>退出该状态的动作</td></tr><tr class="odd"><td>do</td><td>在该状态下的动作</td></tr></tbody></table><p>需要时可以为事件指定参数表。活动表中的动作表达式描述应做的具体动作。</p><p>状态图中两个状态之间带箭头的连线称为<strong>状态转换</strong>，箭头指明了转换方向。状态变迁通常是由事件触发的，在这种情况下应在表示状态转换的箭头线上标出触发转换的事件表达式；如果在箭头线上未标明事件，则表示在源状态的内部活动执行完之后自动触发转换。</p><ul><li>事件表达式的语法：<code>事件说明［守卫条件］／动作表达式</code></li><li>事件说明的语法为：<code>事件名(参数表)</code></li></ul><figure><img src="/image/25-12-3-1-SoftEng-3-demand-aly/1767359495508.webp" alt="1767359495508" /><figcaption aria-hidden="true">1767359495508</figcaption></figure><p>下图是人们非常熟悉的电话系统的状态图。</p><figure><img src="/image/25-12-3-1-SoftEng-3-demand-aly/1767359514309.webp" alt="1767359514309" /><figcaption aria-hidden="true">1767359514309</figcaption></figure><h2 id="其他图形工具">3.7 其他图形工具</h2><h3 id="层次方框图">3.7.1 层次方框图</h3><p>层次方框图用树形结构的一系列多层次的矩形框描绘数据的层次结构。</p><figure><img src="/image/25-12-3-1-SoftEng-3-demand-aly/1767359649542.webp" alt="1767359649542" /><figcaption aria-hidden="true">1767359649542</figcaption></figure><h3 id="warnier-图">3.7.2 Warnier 图</h3><p>用 Warnier 图可以表明信息的逻辑组织，也就是说，它可以指出一类信息或一个信息元素是重复出现的，也可以表示特定信息在某一类信息中是有条件地出现的。</p><figure><img src="/image/25-12-3-1-SoftEng-3-demand-aly/1767359709688.webp" alt="1767359709688" /><figcaption aria-hidden="true">1767359709688</figcaption></figure><h3 id="ipo-图">3.7.3 IPO 图</h3><p>IPO 图是输入、处理、输出图的简称，它是由美国 IBM 公司发展完善起来的一种图形工具，能够方便地描绘输入数据、对数据的处理和输出数据之间的关系。</p><figure><img src="/image/25-12-3-1-SoftEng-3-demand-aly/1767359816216.webp" alt="1767359816216" /><figcaption aria-hidden="true">1767359816216</figcaption></figure><h2 id="验证软件需求">3.8 验证软件需求</h2><h3 id="从哪些方面验证软件需求的正确性">3.8.1 从哪些方面验证软件需求的正确性</h3><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><tbody><tr class="odd"><td>一致性</td><td>所有需求必须是一致的，任何一条需求不能和其他需求互相矛盾。</td></tr><tr class="even"><td>完整性</td><td>需求必须是完整的，规格说明书应该包括用户需要的每一个功能或性能。</td></tr><tr class="odd"><td>现实性</td><td>指定的需求应该是用现有的硬件技术和软件技术基本上可以实现的。</td></tr><tr class="even"><td>有效性</td><td>必须证明需求是正确有效的，确实能解决用户面对的问题。</td></tr></tbody></table><h3 id="验证软件需求的方法">3.8.2 验证软件需求的方法</h3><ol type="1"><li><p><strong>验证需求的一致性</strong><br /><strong>形式化的描述软件需求的方法</strong>。为了验证需求的现实性，分析员应该<strong>参照以往开发类似系统的经验</strong>，分析用现有的软、硬件技术实现目标系统的<strong>可能性</strong>。必要的时候应该采用<strong>仿真或性能模拟技术</strong>，辅助分析软件需求规格说明书的现实性。</p></li><li><p><strong>验证需求的完整性和有效性</strong><br />只有目标系统的用户才真正知道软件需求规格说明书是否完整、准确地描述了他们的需求。因此，检验需求的完整性，特别是证明系统确实满足用户的实际需要，只有在用户的密切合作下才能完成。</p></li></ol><h3 id="用于需求分析的软件工具">3.8.3 用于需求分析的软件工具</h3><p>为了更有效地保证软件需求的正确性，特别是为了保证需求的一致性，需要有适当的软件工具支持需求分析工作。这类软件工具应该满足下列要求。</p><ul><li>必须有<strong>形式化的语法（或表）</strong>，因此可以用计算机自动处理使用这种语法说明的内容。</li><li>使用这个软件工具能够<strong>导出详细的文档</strong>。</li><li>必须提供<strong>分析（测试）规格说明书的不一致性和冗余性的手段</strong>，并且应该能够产生一组报告指明<strong>对完整性分析的结果</strong>。</li><li>使用这个软件工具之后，应该能够<strong>改进通信状况</strong>。</li></ul><p><strong>PSL/PSA 系统</strong>是 CADSAT（计算机辅助设计和规格说明分析工具）的一部分。其中</p><ul><li>PSL 是用来描述系统的形式语言</li><li>PSA 是处理 PSL 描述的分析程序。</li></ul><p>PSL/PSA 系统的功能主要有</p><ul><li>描述<strong>任何应用领域</strong>的信息系统。</li><li>创建一个<strong>数据库</strong>保存对该信息系统的<strong>描述符</strong>。</li><li>对描述符施加<strong>增加、删除和更改</strong>等操作。</li><li>产生<strong>格式化的文档</strong>和关于规格说明书的各种<strong>分析报告</strong>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【COMPSCI 220】 Lecture 22 Flow Network</title>
      <link href="/2025/12/26/25-11-20-1-COMPSCI220-22-flow-net/"/>
      <url>/2025/12/26/25-11-20-1-COMPSCI220-22-flow-net/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Special thanks to Zekun Lin.</p></blockquote><h1 id="part-i-basic-terminology">Part I: Basic Terminology</h1><h2 id="a-shipping-problem">A Shipping Problem</h2><h2 id="flow-network">Flow Network</h2><dl><dt><strong>Source Node</strong></dt><dd>A source node in a <strong>directed graph</strong> is a node with no incoming edges.</dd><dt><strong>Sink Node</strong></dt><dd>A sink node in a <strong>directed graph</strong> is a node with no outgoing edges.</dd><dt><strong>Flow Network</strong></dt><dd>A flow network is a directed graph (<span class="math inline">\(V, E, c, s, t\)</span>) where (<span class="math inline">\(V, E, c\)</span>) forms <strong>a weighted graph</strong> with <strong>positive</strong> edge weights, <span class="math inline">\(s \in V\)</span> is a source node and <span class="math inline">\(t \in V\)</span> is a sink node.</dd><dt><strong>Flow</strong></dt><dd>A flow in a flow network is a <strong>function</strong> <span class="math inline">\(f : E \to N\)</span> such that <span class="math inline">\(f(u, v) \leq c(u, v)\)</span> for every <span class="math inline">\((u, v) \in E\)</span> and for any node <span class="math inline">\(u\)</span> that is <strong>not <span class="math inline">\(s\)</span> nor <span class="math inline">\(t\)</span></strong>, we have<br /><span class="math display">\[\sum_{(u, x) \in E}f(u, x) = \sum_{(y, u) \in E}f(y, u)\]</span></dd></dl><blockquote><p>This means “all in” equals to “all out”.</p></blockquote><p>Intuitively, a flow defines a way to send oil from <span class="math inline">\(s\)</span> to <span class="math inline">\(t\)</span> <strong>without exceeding the pipeline capacity</strong>, and <strong>without any leak</strong> on the way.</p><blockquote><p>Here <span class="math inline">\(c(u, v)\)</span> stands for <strong>capacity</strong>, <em>i.e.</em> weight.</p></blockquote><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th>Capacity(Weight)</th><th>Flow</th></tr></thead><tbody><tr class="odd"><td><img src="/image/25-11-20-1-COMPSCI220-22-flow-net/1766752224454.webp" alt="1766752224454" /></td><td><img src="/image/25-11-20-1-COMPSCI220-22-flow-net/1766752236262.webp" alt="1766752236262" /></td></tr></tbody></table><dl><dt><strong>Size of a Flow</strong></dt><dd>The size of a flow <span class="math inline">\(f\)</span> in a flow network is <span class="math inline">\(size(f) =\sum \{f(s, u) | (s, u) \in E\}\)</span>. In other words, it is the <strong>total quantity of stuff</strong> sent from <span class="math inline">\(s\)</span> to <span class="math inline">\(t\)</span>.</dd></dl><blockquote><p>Also the sum of the weight of edges(flow diagraph, <em>i.e.</em> the right one) depart from <span class="math inline">\(s\)</span>.</p></blockquote><h2 id="maximal-flows-in-a-flow-network">Maximal Flows in a Flow Network</h2><dl><dt><strong>Maximal Flow</strong></dt><dd>A flow in a flow network is maximal if it has maximal size.</dd></dl><h2 id="cuts-in-a-flow-network">Cuts in a Flow Network</h2><dl><dt><strong>Cut</strong></dt><dd>A cut in a graph is a set <span class="math inline">\(C\)</span> of <strong>edges</strong> such that removing them would <strong>disconnect</strong> the graph into <span class="math inline">\(left(C)\)</span> (nodes reachable from <span class="math inline">\(s\)</span>) and the right part <span class="math inline">\(right(C)\)</span> (nodes that may reach <span class="math inline">\(t\)</span>).</dd><dt><strong>Capacity of Cut</strong></dt><dd>The capacity of a cut <span class="math inline">\(C\)</span> in a flow network is the sum of the capacity of edges that goes from left to right:<br /><span class="math display">\[capacity(C) = \sum \{c(u, v) | (u, v) \in E, u \in left(C), v \in right(C)\}\]</span><br />A minimal cut is a cut with <strong>minimal capacity</strong>.</dd></dl><blockquote><p>The sum of weights of edges cross from left to right.</p></blockquote><dl><dt><strong>Net Flow of a Cut</strong></dt><dd>Let <span class="math inline">\(C\)</span> be a cut in a network <span class="math inline">\(G\)</span> and <span class="math inline">\(f\)</span> be a flow. The <strong>net flow</strong> of <span class="math inline">\(f\)</span> over <span class="math inline">\(C\)</span><br /><span class="math display">\[f(C) = \sum \{f(u, v) | (u, v) \in E\} - \sum \{f(v, u) | (v, u) \in E\} \\u \in left(C), v \in right(C)\]</span></dd></dl><h2 id="flow-and-cut">Flow and Cut</h2><ol type="1"><li><p>For any cut <span class="math inline">\(C\)</span> and flow <span class="math inline">\(f\)</span>,<br /><span class="math display">\[f(C) = size(f)\]</span></p><blockquote><p>All flow depart from <span class="math inline">\(s\)</span> should cross <span class="math inline">\(C\)</span>.</p></blockquote></li><li><p>For any flow network <span class="math inline">\(G\)</span>,<br /><span class="math display">\[size(f_{max}) \leq capacity(C_{min})\]</span></p><blockquote><p>A cumulative conclusion of <span class="math inline">\(f(u, v) \leq c(u, v)\)</span>.</p></blockquote></li></ol><h1 id="part-2-max-flow-min-cut">Part 2: Max-Flow Min-Cut</h1><h2 id="problems">Problems</h2><ul><li><strong>Max Flow Problem</strong>: Find the maximal flow(maximal quantity could be sent from <span class="math inline">\(s\)</span> to <span class="math inline">\(t\)</span>).</li><li><strong>Min-cut Problem</strong>: Find the minimal cut(bottleneck of the network).</li></ul><blockquote><p>These are two same problems.</p></blockquote><h2 id="residual-network">Residual Network</h2><dl><dt><strong>Residual Network</strong></dt><dd>Let <span class="math inline">\(G = (V, E, c,s, t)\)</span> be a flow network and <span class="math inline">\(f\)</span> be a flow in <span class="math inline">\(G\)</span>. The residual network <span class="math inline">\(G_f\)</span> of <span class="math inline">\(G\)</span> and <span class="math inline">\(F\)</span> is another flow network <span class="math inline">\((V, E_f, c_f, s, t)\)</span></dd></dl><ul><li>If <span class="math inline">\((u, v) \in E\)</span>, <span class="math inline">\(f(u, v) &lt; c(u, v)\)</span>, put <span class="math inline">\((u, v)\)</span> into <span class="math inline">\(E_f\)</span> and set <span class="math inline">\(c_f(u, v) = c(u, v) - f(u, v)\)</span>.</li><li>If <span class="math inline">\(f(u, v) &gt; 0\)</span>, put <span class="math inline">\((v, u)\)</span> into <span class="math inline">\(E_f\)</span> and set <span class="math inline">\(c_f(v, u) = f(u, v)\)</span>.</li></ul><table><colgroup><col style="width: 33%" /><col style="width: 33%" /><col style="width: 33%" /></colgroup><thead><tr class="header"><th>Network(Capacity)</th><th>Flow</th><th>Residual Network</th></tr></thead><tbody><tr class="odd"><td><img src="/image/25-11-20-1-COMPSCI220-22-flow-net/1766752993668.webp" alt="1766752993668" /></td><td><img src="/image/25-11-20-1-COMPSCI220-22-flow-net/1766753038513.webp" alt="1766753038513" /></td><td><img src="/image/25-11-20-1-COMPSCI220-22-flow-net/1766753049808.webp" alt="1766753049808" /></td></tr></tbody></table><h2 id="combining-flows">Combining Flows</h2><p>Let <span class="math inline">\(f\)</span> be a flow in <span class="math inline">\(G\)</span>, <span class="math inline">\(g\)</span> be a flow in <span class="math inline">\(G_f\)</span>, then an another flow of <span class="math inline">\(h\)</span> in <span class="math inline">\(G\)</span> is<br /><span class="math display">\[h(u, v) = f(u, v) + g(u, v) - g(v, u), (u, v) \in E\]</span></p><p><strong>Note</strong>: <span class="math inline">\(h\)</span> is larger than <span class="math inline">\(f\)</span>.</p><p><img src="/image/25-11-20-1-COMPSCI220-22-flow-net/1766753206729.webp" alt="1766753206729" /><br /><img src="/image/25-11-20-1-COMPSCI220-22-flow-net/1766753220452.webp" alt="1766753220452" /></p><h2 id="ford-fulkerson-algorithm-solving-max-flow-problem">Ford-Fulkerson Algorithm Solving Max-Flow Problem</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">algo FF(G)</span><br><span class="line">    flow = new Flow(G)</span><br><span class="line">    rn = new ResidualNetwork(G, f) // Full residual network.</span><br><span class="line"></span><br><span class="line">    while(there exists any single-path flow)</span><br><span class="line">        spf = rn.pickSinglePath() // Pick a single path flow.</span><br><span class="line">        Combine(spf, flow)</span><br><span class="line">        rn.Update()</span><br></pre></td></tr></table></figure><h2 id="max-flow-min-cut">Max-Flow Min-Cut</h2><dl><dt><strong>Max-Flow Min-Cut Theorem</strong></dt><dd>In any flow network, the <strong>size</strong> of the <strong>maximal flow</strong> equals the <strong>capacity</strong> of the <strong>minimal cut</strong>.</dd></dl><p>Obvoiusly, Ford-Fulkerson algorithm finds a maximal flow, as well as a minimal cut in a network.</p><p><br /><br /></p><font size="4"><br /><center>***</center><center><i>Elegance is not a dispensable luxury but a factor that decides between success and failure.</i></center></font><br /><p style="text-align: right;">E. W. Dijkstra(1999)</p><font size="4"><br /><center>***</center><p></font></p><p><br /></p><figure><img src="/image/25-11-20-1-COMPSCI220-22-flow-net/1766754907755.webp" alt="1766754907755" /><figcaption aria-hidden="true">1766754907755</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> COMPSCI 220 Algorithms and Data Structures </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 奥克兰大学—西南大学合作课程 </tag>
            
            <tag> 外文 </tag>
            
            <tag> 算法分析与设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【COMPSCI 220】 Lecture 21a Practical Exercises of Dynamic Programming</title>
      <link href="/2025/12/26/25-12-26-3-COMPSCI220-21a-practical-dyn-prog/"/>
      <url>/2025/12/26/25-12-26-3-COMPSCI220-21a-practical-dyn-prog/</url>
      
        <content type="html"><![CDATA[<h2 id="tower-of-babylon">Tower of Babylon</h2><h3 id="problem">Problem</h3><p>You are <span class="math inline">\(n\)</span> given different types of rectangular blocks. There is an unlimited supply of each type. The <span class="math inline">\(i\)</span>-th type of block has dimensions<br /><span class="math display">\[(x_i, y_i, z_i)\]</span></p><p>A block can be rotated: any two dimensions can be chosen as the base, and the remaining dimension is the height.</p><p>You want to build the tallest possible tower by stacking blocks under the following rule: A block can be placed on top of another block only if both sides of its base are strictly smaller than the corresponding sides of the block beneath it.</p><p>Therefore, blocks with identical base dimensions cannot be stacked. Your task is to compute the maximum possible height of the tower.</p><p><strong>Input</strong><br />The input contains multiple test cases. For each test case:</p><ul><li>The first line contains an integer <span class="math inline">\(n\)</span>, the number of block types, where <span class="math inline">\(n &gt; 30\)</span>.</li><li>The next <span class="math inline">\(n\)</span> lines each contain three integers <span class="math inline">\(x_i, y_i, z_i\)</span>.</li><li>Input ends when <span class="math inline">\(n = 0\)</span>.</li></ul><p><strong>Output</strong><br />For each test case, output one line containing the case number (starting from 1) and the maximum possible tower height.</p><p>The output format must be:<br /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Case case: maximum height = height</span><br></pre></td></tr></table></figure></p><p>where case is the test case index and height is the computed maximum height.</p><h3 id="analysis">Analysis</h3><ol type="1"><li><p><strong>Preloading</strong><br />Generate all possible block placements. To simplify the comparison, we let <span class="math inline">\(x_i &gt; y_i\)</span>. Now these block can be seen as unrotatable.</p></li><li><p><strong>Sort</strong><br />Sort the blocks by length(<span class="math inline">\(x_i\)</span>) in decreasing order. For blocks with the same length, sort them by width(<span class="math inline">\(y_i\)</span>) in decreasing order. Now if block A can be placed on block B, then B must be in front of A.</p></li><li><p><strong>Status Definition</strong><br />Let <span class="math inline">\(dp[i]\)</span> be the biggest height of the tower which the top is the <span class="math inline">\(i\)</span>-th block.</p></li><li><p><strong>Recurrence</strong><br />If block <span class="math inline">\(i\)</span> is placed on block <span class="math inline">\(j\)</span>, it should be:</p><ul><li><span class="math inline">\(j &lt; i\)</span>.</li><li><span class="math inline">\(x_i &lt; x_j\)</span>, <span class="math inline">\(y_i &lt; y_j\)</span>.</li></ul><p><span class="math display">\[dp[i] = \max\{z_i, \max\{dp[j] + z_j | 0 &lt; j &lt; i, x_i &lt; x_j, y_i &lt; y_j\}\}\]</span></p></li><li><p><strong>Base Case</strong><br />Every block can form a tower itself.<br /><span class="math display">\[dp[i] = z_i\]</span></p></li><li><p><strong>Answer</strong><br /><span class="math display">\[\max\{dp[i] | 0 \leq i \leq n - 1\}\]</span></p></li></ol><h3 id="pseudocode">Pseudocode</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">algo babylon(blocks[0..n - 1][3])</span><br><span class="line">    // Generate all possible blocks.</span><br><span class="line">    allBlocks = new List2D(0, 3)</span><br><span class="line"></span><br><span class="line">    for block in blocks do</span><br><span class="line">        if(block[0] &gt; block[1]) then</span><br><span class="line">            allBlocks.append(block)</span><br><span class="line">        else</span><br><span class="line">            allBlocks.append(&#123;block[1], block[0], block[2]&#125;)</span><br><span class="line">        </span><br><span class="line">        if(block[1] &gt; block[2]) then</span><br><span class="line">            allBlocks.append(&#123;block[1], block[2], block[0]&#125;)</span><br><span class="line">        else</span><br><span class="line">            allBlocks.append(&#123;block[2], block[1], block[0]&#125;)</span><br><span class="line"></span><br><span class="line">        if(block[0] &gt; block[2]) then</span><br><span class="line">            allBlocks.append(&#123;block[0], block[2], block[1]&#125;)</span><br><span class="line">        else</span><br><span class="line">            allBlocks.append(&#123;block[2], block[0], block[1]&#125;)</span><br><span class="line"></span><br><span class="line">    // Sort the blocks.</span><br><span class="line">    sort(allBlocks.begin(), allBlocks.end(), cmpBlocks)</span><br><span class="line"></span><br><span class="line">    // Base case</span><br><span class="line">    dp = new Array()</span><br><span class="line">    for i in 0..n - 1 do</span><br><span class="line">        dp[i] = allBlocks[i][2]</span><br><span class="line">    </span><br><span class="line">    // Caculating dp.</span><br><span class="line">    for i in 0..n - 1 do</span><br><span class="line">        for j in 0..i - 1 do // Blocks which could be placed under allBlock[i] could only appear before allBlock[i].</span><br><span class="line">            if(allBlocks[j][0] &gt; allBlocks[i][0] &amp;&amp; allBlocks[j][1] &gt; allBlocks[i][1])</span><br><span class="line">                dp[i] = max(dp[i], dp[j] + allBlock[i][2])</span><br><span class="line"></span><br><span class="line">    return max(dp)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">algo cmpBlocks(a[3], b[3])</span><br><span class="line">    if(a[0] != b[0]) then</span><br><span class="line">        return a[0] &gt; b[0]</span><br><span class="line"></span><br><span class="line">    if(a[1] != b[1]) then</span><br><span class="line">        return a[1] &gt; b[1]</span><br></pre></td></tr></table></figure><h3 id="time-complexity">Time Complexity</h3><ol type="1"><li><p>Generate all possible blocks. <span class="math inline">\(O(n)\)</span>.</p></li><li><p>Sort the blocks. <span class="math inline">\(O(n \log n)\)</span>.</p></li><li><p>Base case. <span class="math inline">\(O(n)\)</span>.</p></li><li><p>Calculating <code>dp</code>. <span class="math inline">\(O(n^2)\)</span>.</p></li><li><p>Return <code>max(dp)</code>. <span class="math inline">\(O(n)\)</span>.</p></li></ol><p>So overall,<br /><span class="math display">\[T(n) = O(n^2)\]</span></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> COMPSCI 220 Algorithms and Data Structures </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 奥克兰大学—西南大学合作课程 </tag>
            
            <tag> 外文 </tag>
            
            <tag> 算法分析与设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【COMPSCI 220】 Lecture 21 Dynamic Programming</title>
      <link href="/2025/12/26/25-11-19-3-COMPSCI220-21-dyn-prog/"/>
      <url>/2025/12/26/25-11-19-3-COMPSCI220-21-dyn-prog/</url>
      
        <content type="html"><![CDATA[<h2 id="optimization">Optimization</h2><p>An optimisation problem contains a solution set where each solution has a value. The problem asks to find the solution with the <strong>maximal/minimal value</strong> (The <strong>optimal solution</strong>).</p><h2 id="dynamic-programming">Dynamic Programming</h2><p>Dynamic programming is a method for solving complex optimisation problems by breaking them down into <strong>simpler subproblems</strong>.</p><p>It is applicable to problems exhibiting the properties of overlapping subproblems and optimal substructure.</p><p>Dynamic programming solves the subproblems <strong>from small to large</strong> to <strong>avoid duplication</strong>.</p><h3 id="four-steps-of-dynamic-programming">Four Steps of Dynamic Programming</h3><ol type="1"><li><p><strong>Parameterize</strong> the problem.</p></li><li><p>Handle the <strong>base case</strong>.</p></li><li><p>Write a <strong>recurrence</strong> for larger subproblems</p></li><li><p>Fill the <strong>table of partial solutions</strong> in a bottom-up way.</p></li></ol><h2 id="example-1-single-source-shortest-path">Example 1: Single-Source Shortest Path</h2><p><a href="/2025/12/26/25-11-17-2-COMPSCI220-20-short-path/">【COMPSCI 220】 Lecture 20 Shortest Paths, Revisited</a></p><h2 id="example-2-all-pair-shortest-path">Example 2: All-Pair Shortest Path</h2><p><a href="/2025/12/26/25-11-17-2-COMPSCI220-20-short-path/">【COMPSCI 220】 Lecture 20 Shortest Paths, Revisited</a></p><h2 id="example-3-longest-increasing-subsequence">Example 3: Longest Increasing Subsequence</h2><h3 id="problem">Problem</h3><p>For an array of numbers <span class="math inline">\(a[1 \cdots n]\)</span>, find the length of subsequence of numbers<br /><span class="math display">\[a[i_1], a[i_2], \cdots, a[i_k]\]</span></p><p>where<br /><span class="math display">\[1 \leq i_1 &lt; i_2 &lt; \cdots &lt; i_k \leq n \\\\a[i_1] &lt; a[i_2] &lt; \cdots &lt; a[i_k]\]</span></p><h3 id="analysis">Analysis</h3><ol type="1"><li><p>Let each number represents a node, create an directed edge <span class="math inline">\((a[i], a[j])\)</span> if <span class="math inline">\(a[i] &lt; a[j]\)</span>.<br />Then the problem is compute the <strong>longest path</strong> of the graph.</p></li><li><p><strong>Subproblems</strong></p><ul><li>Let <span class="math inline">\(L(i)\)</span> be the length of longest path ends at <span class="math inline">\(a[i]\)</span>.</li><li>Then the length of the answer is <span class="math inline">\(\max\{L(i) | 1 \leq i \leq n\}\)</span>.</li></ul></li><li><p><strong>Base Case</strong><br /><span class="math inline">\(L(1) = 1\)</span>.</p></li><li><p><strong>Recurrence</strong><br /><span class="math display">\[L(i + 1) = \begin{cases} 1 &amp;, indegree(a[i + 1]) = 0 \\ 1 + \max\{L(j) | j &lt; i + 1, (a[j], a[i + 1]) \in E\} &amp;, \text{otherwise}\end{cases}\]</span></p><ul><li><span class="math inline">\(\max\{L(j) | j &lt; i + 1, (a[j], a[i + 1]) \in E\}\)</span>: The longest path who needs one more step to reach <span class="math inline">\(a[i + 1]\)</span>.</li></ul></li><li><p>Then <strong>compute</strong> from <span class="math inline">\(L(1)\)</span> to <span class="math inline">\(L(n)\)</span>.</p></li></ol><h3 id="pseudocode">Pseudocode</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">algo LIS(a[i..n])</span><br><span class="line">    // OUTPUT: The length of the length of subsequence of numbers.</span><br><span class="line">    L = new Array(n * 1)</span><br><span class="line"></span><br><span class="line">    for i in 2..n do</span><br><span class="line">        for j = 1..i - 1 do</span><br><span class="line">            if(a[j] &lt; a[i]) then // There is an edge between a[j] and a[i].</span><br><span class="line">                L[i] = max(L[i], L[j] + 1) // Which one is longer? The existing path(L[i]) or passing a[j](L[j] + 1)?</span><br><span class="line"></span><br><span class="line">    return max(L)</span><br></pre></td></tr></table></figure><h2 id="example-4-edit-distance">Example 4: Edit Distance</h2><blockquote><p>Special thanks to Sichen Wang and Zhibo Lin.</p><h3 id="problem-1">Problem</h3><p>Given two words <code>a[1..m]</code> and <code>b[1..n]</code>, compute the <strong>edit distance</strong> of<br />them.</p></blockquote><dl><dt><strong>Edit Distance</strong></dt><dd>The edit distance of two words is the smallest number of edits, that are insertion, deletion, and replacement of letters, needed to transform from one word to another.</dd></dl><h3 id="analysis-1">Analysis</h3><ol type="1"><li><p><strong>Subproblems</strong><br />Suppose <span class="math inline">\(a[1..m]\)</span>, <span class="math inline">\(b[1..n]\)</span>. Let <span class="math inline">\(E(i, j)\)</span> be the distance of <span class="math inline">\(a[1..i]\)</span> and <span class="math inline">\(b[1..j]\)</span>. We want to compute <span class="math inline">\(E(m, n)\)</span>.</p></li><li><p><strong>Base Case</strong><br />Undoubtly, <span class="math inline">\(E(0, j) = j\)</span>, <span class="math inline">\(E(i, 0) = i\)</span>.</p></li><li><p><strong>Recurrence</strong><br /><img src="/image/25-11-19-3-COMPSCI220-21-dyn-prog/1766741560957.webp" alt="1766741560957" /></p><p><span class="math display">\[E(i + 1, j + 1) = \min\{E(i, j + 1) + 1, E(i + 1, j) + 1, E(i, j) + k\}\]</span></p><p>where<br /><span class="math display">\[k = \begin{cases} 1 &amp;, a[i + 1] \neq b[j + 1] \\ 0 &amp;, a[i + 1] = b[j + 1]\end{cases}\]</span></p></li><li><p>Then <strong>fill the table</strong> row by row</p></li></ol><h3 id="pseudocode-1">Pseudocode</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">algo editDistance(a[1..m], b[1..n])</span><br><span class="line">    E = new Array2D((m, n))</span><br><span class="line"></span><br><span class="line">    for i = 0..m do</span><br><span class="line">        E[i][0] = i</span><br><span class="line"></span><br><span class="line">    for j = 0..n do</span><br><span class="line">        E[0][j] = j</span><br><span class="line"></span><br><span class="line">    for i = 1..m do</span><br><span class="line">        for j = 1..n do</span><br><span class="line">            k = (a[i] != b[j])</span><br><span class="line">            E[i][j] = min(E(i, j + 1) + 1, E(i + 1, j) + 1, E(i, j) + k)</span><br><span class="line">    </span><br><span class="line">    return E[m][n]</span><br></pre></td></tr></table></figure><h3 id="time-complexity">Time Complexity</h3><p><span class="math display">\[O(mn)\]</span></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> COMPSCI 220 Algorithms and Data Structures </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 奥克兰大学—西南大学合作课程 </tag>
            
            <tag> 外文 </tag>
            
            <tag> 算法分析与设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【COMPSCI 220】 Lecture 20a Practical Exercises of Graph</title>
      <link href="/2025/12/26/25-12-26-2-COMPSCI220-20a-practical-graph/"/>
      <url>/2025/12/26/25-12-26-2-COMPSCI220-20a-practical-graph/</url>
      
        <content type="html"><![CDATA[<h2 id="euler-trail">Euler Trail</h2><blockquote><p>Special thanks to Yuze Jiang.</p></blockquote><h3 id="problem">Problem</h3><p>There is a graph that has either exactly two vertices of odd degree or none. An Euler trail is a walk in the graph that starts from a vertex, visiting all edges in the graph, with no edge repeated. If the graph has an Euler circuit, start the traversal from the first vertex. If the graph has two vertices of odd degree, start the traversal from the vertex with the larger index. During the traversal, whenever you have a choice, always visit the vertex with the smaller index first.</p><dl><dt><strong>Input</strong></dt><dd>The first line contains two integers <span class="math inline">\(n\)</span> and <span class="math inline">\(e\)</span>, denoting a graph with <span class="math inline">\(n\)</span> vertices and <span class="math inline">\(e\)</span> edges.</dd></dl><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 5</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br><span class="line">5 1</span><br></pre></td></tr></table></figure><dl><dt><strong>Output</strong></dt><dd>Output a single line containing the Euler trail or Euler circuit.</dd></dl><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 5 4 3 2 1</span><br></pre></td></tr></table></figure><h3 id="analysis">Analysis</h3><ol type="1"><li><p><strong>Feasability</strong><br />Not every graph has Euler paths or Euler circut.</p><ul><li>The graph has Euler circuts <span class="math inline">\(\Leftrightarrow \forall v \in V, {\rm degree}(v)\)</span> is even.</li><li>The graph has Euler paths <strong>if and only if</strong> there are only 2 vertecies which <span class="math inline">\({\rm degree}(v)\)</span> is odd.</li></ul></li><li><p><strong>DFS(Hierholzer)</strong></p><ul><li>Maintain a stack to store the path.</li><li>Start DFS at the start vertex.<ul><li>For current node <span class="math inline">\(u\)</span>, sort the neighbour and visit the vertex with the smaller index first.</li><li>Marked the visited edge as “visited”.</li><li>When all neighbours of the node <span class="math inline">\(u\)</span> is visited, add <span class="math inline">\(u\)</span> to the stack.</li></ul></li><li>Pop the stack and get the path/circut.</li></ul></li></ol><h3 id="pseudocode">Pseudocode</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">algo eulerTrail(G, n, e)</span><br><span class="line">    graph = new AdjacencyList(G) // This list also contains node degrees.</span><br><span class="line"></span><br><span class="line">    sort(graph) // Sort the adjacency tables to meet the requirement of &quot;visit the vertex with the smaller index first&quot;.</span><br><span class="line"></span><br><span class="line">    // Find a vertex to start.</span><br><span class="line">    oddVerticesCount = 0</span><br><span class="line">    start = 1</span><br><span class="line">    for i in 1..n do</span><br><span class="line">        if(degree[i].isOdd = TRUE) do</span><br><span class="line">            oddVerticesCount++</span><br><span class="line">            start = i // Updated to the index with a large odd number of vertices.</span><br><span class="line">    </span><br><span class="line">    // See wether the graph has the answer.</span><br><span class="line">    if(oddVerticesCount != 0 &amp;&amp; oddVerticesCount != 2) do</span><br><span class="line">        return NULL</span><br><span class="line"></span><br><span class="line">    // DFS, Hierholzer</span><br><span class="line">    path = new Stack()</span><br><span class="line"></span><br><span class="line">    DFS(graph, start, path)</span><br><span class="line"></span><br><span class="line">    return popOrder(path)</span><br><span class="line"></span><br><span class="line">algo DFS(graph, u, path)</span><br><span class="line">    while(graph[u].isEmpty() == false) do</span><br><span class="line">        v = graph[u][0] // Get the node with the smallest key.</span><br><span class="line">        graph[u].remove(v) // This direction has been visited.</span><br><span class="line">        graph[v].remove(u) // This direction has been visited.</span><br><span class="line"></span><br><span class="line">        DFS(v)</span><br><span class="line">    </span><br><span class="line">    path.push(u)</span><br></pre></td></tr></table></figure><h3 id="time-complexity">Time Complexity</h3><p>The algorithm has three parts:</p><ol type="1"><li><p><strong>Constructing <code>new AdjacencyList(G)</code></strong>: The process is actually append all edges into serveral arrays. <span class="math inline">\(O(e)\)</span>.</p></li><li><p><strong>Sort Adjacency List</strong>: There are <span class="math inline">\(n\)</span> lists to be sorted. The sorted length is the biggest degree of the graph <span class="math inline">\(D\)</span>. <span class="math inline">\(O(n \log D)\)</span>.</p></li><li><p><strong>DFS(Hierholzer)</strong></p><ul><li>Delete an edge when it is visited. <span class="math inline">\(O(e)\)</span></li><li>Every node will be popped or pushed once. <span class="math inline">\(O(n)\)</span></li></ul><p>Overall <span class="math inline">\(O(n + e)\)</span>.</p></li></ol><p><span class="math display">\[T = O(n + e \log D)\]</span></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> COMPSCI 220 Algorithms and Data Structures </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 奥克兰大学—西南大学合作课程 </tag>
            
            <tag> 外文 </tag>
            
            <tag> 算法分析与设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【COMPSCI 220】 Lecture 20 Shortest Paths, Revisited</title>
      <link href="/2025/12/26/25-11-17-2-COMPSCI220-20-short-path/"/>
      <url>/2025/12/26/25-11-17-2-COMPSCI220-20-short-path/</url>
      
        <content type="html"><![CDATA[<h2 id="shortest-path-with-potentially-negative-edges">Shortest Path with Potentially Negative Edges</h2><p>Dijkstra’s algorithm does not work for weighted graph where the<br />weights could be <strong>negative</strong>.</p><p>If there is a “negative cycle” (a cycle whose total edge weight is negative), then the problem does not make sense. Greedy choice <strong>does not</strong> work here.</p><h2 id="paths-with-bounded-length">Paths with Bounded Length</h2><p>Let <span class="math inline">\(d_k(u)\)</span> denote the length of the shortest path from <span class="math inline">\(S\)</span> to <span class="math inline">\(u\)</span> that uses at most <span class="math inline">\(k\)</span> edges.</p><p>Suppose <span class="math inline">\(G\)</span> does not contain a negative cycle. Then the distance from <span class="math inline">\(S\)</span> to <span class="math inline">\(u\)</span> is <span class="math inline">\(d_{n−1}(u)\)</span> for every <span class="math inline">\(u \in V\)</span>.</p><h2 id="computing-distance">Computing Distance</h2><p>Computing distances is reduced to computing <span class="math inline">\(d_{n - 1}(u)\)</span>.</p><figure><img src="/image/25-11-17-2-COMPSCI220-20-short-path/1766729956789.webp" alt="1766729956789" /><figcaption aria-hidden="true">1766729956789</figcaption></figure><figure><img src="/image/25-11-17-2-COMPSCI220-20-short-path/1766730129313.webp" alt="1766730129313" /><figcaption aria-hidden="true">1766730129313</figcaption></figure><p><span class="math display">\[d_{k + 1}(u) = \min(d_k(u), \min\{d_k(v) + w(v, u) | (v, u) \in E\})\]</span></p><h2 id="bellman-ford-algorithm">Bellman-Ford Algorithm</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">algo bellmanFord(G, s)</span><br><span class="line">    // INPUT: A graph G (without negative cycle) and starting node s</span><br><span class="line">    // OUTPUT: d(u) for every node u denoting distance from s to u</span><br><span class="line">    d(s) = 0, d(v) = inf for all other v</span><br><span class="line">    for i = 1 to n − 1 do</span><br><span class="line">        for u in V do</span><br><span class="line">            d&#x27;(u) = d(u)</span><br><span class="line">            for (v, u) in E do</span><br><span class="line">                d&#x27;(u) = min&#123;d&#x27;(u), d(v) + w(v, u)&#125;</span><br><span class="line">            Replace d by d&#x27;</span><br></pre></td></tr></table></figure><h3 id="complexity">Complexity</h3><ul><li>There are <span class="math inline">\(n − 1\)</span> iterations</li><li>At each iteration, we process every incoming edge for every node. This means that we examine every edge in the graph (exactly once).<br />Therefore the total running time is <span class="math inline">\((n − 1) \times m\)</span>. (<span class="math inline">\(\Theta(nm)\)</span>)</li></ul><h2 id="all-pair-shortest-path">All-Pair Shortest Path</h2><p>Dijkstra’s and Bell-Ford algorithm both solves <strong>Single-Source Shortest Path Problem</strong>.</p><p>Compute the shortest distance between any pair of nodes in <span class="math inline">\(G\)</span>.</p><p>Run Single-Source Shortest Path Algorithm <span class="math inline">\(n\)</span> times: <span class="math inline">\(O(n^2m)\)</span>.</p><h2 id="floyd-warshall-algorithm">Floyd-Warshall Algorithm</h2><ul><li>Label all nodes using <span class="math inline">\(v_1, v_2, \cdots, v_n\)</span>.</li><li>Define <span class="math inline">\(f_k(i, j)\)</span> as the length of the shortest path between <span class="math inline">\(v_i, v_j\)</span> that uses only <span class="math inline">\(v_1, \cdots, v_k\)</span> as <strong>intermediate nodes</strong>.</li></ul><blockquote><p><span class="math inline">\(f_n(i, j)\)</span> is the distance from <span class="math inline">\(v_i\)</span> to <span class="math inline">\(v_j\)</span>.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// INPUT: A graph G without negative cycle.</span><br><span class="line">// OUTPUT: f(i, j)</span><br><span class="line">Create 2-dim array f, f&#x27;</span><br><span class="line">f(i, j) &lt;- w(vi, vj) for all i, j</span><br><span class="line">for k = 1 to n do</span><br><span class="line">    for i = 1 to n do</span><br><span class="line">        for j = 1 to n do</span><br><span class="line">            f&#x27;(i, j) &lt;- min&#123;f(i, j), f(i, k) + f(k, j)&#125;</span><br><span class="line">    f &lt;- f&#x27;</span><br></pre></td></tr></table></figure><p>Time Complexity: <span class="math inline">\(O(n^3)\)</span>.</p><h2 id="summary">Summary</h2><table><colgroup><col style="width: 33%" /><col style="width: 33%" /><col style="width: 33%" /></colgroup><thead><tr class="header"><th>Problem</th><th>Algorithm</th><th><span class="math inline">\(T(n)\)</span></th></tr></thead><tbody><tr class="odd"><td>Single Source, Positive Weights</td><td>Dijkstra</td><td><span class="math inline">\(O(n^2)\)</span>, <span class="math inline">\(O((n + m) \log n)\)</span>, <span class="math inline">\(O(n \log n + m)\)</span></td></tr><tr class="even"><td>Single Source, No Nagative Cycle</td><td>Bellman-Ford</td><td><span class="math inline">\(O(mn)\)</span></td></tr><tr class="odd"><td>All-pair, No Negative Cycle</td><td>Floyd-Warshall</td><td><span class="math inline">\(O(n^3)\)</span></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> COMPSCI 220 Algorithms and Data Structures </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 奥克兰大学—西南大学合作课程 </tag>
            
            <tag> 外文 </tag>
            
            <tag> 算法分析与设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【COMPSCI 220】 Lecture 19a Practical Exercises of Greedy Algorithms</title>
      <link href="/2025/12/26/25-12-26-1-COMPSCI220-19a-practical-greedy/"/>
      <url>/2025/12/26/25-12-26-1-COMPSCI220-19a-practical-greedy/</url>
      
        <content type="html"><![CDATA[<h2 id="woodsticks">Woodsticks</h2><blockquote><p>Special thanks to Bingxian Yang.</p></blockquote><h3 id="problem">Problem</h3><p>There are <span class="math inline">\(n\)</span> wooden sticks, each with a known length and weight. A woodworking machine is used to process these sticks one by one. During processing, the machine may require some <strong>setup time</strong>, which is used for cleaning the machine and adjusting tools and templates. The required setup time is defined as follows:</p><p>Before processing the first stick, the machine needs <strong>1 minute</strong> of setup time.</p><p>After processing a stick of length <span class="math inline">\(l\)</span> and weight <span class="math inline">\(w\)</span>, if the next stick has length <span class="math inline">\(l&#39;\)</span> and weight <span class="math inline">\(w&#39;\)</span> satisfying <span class="math inline">\(l&#39; \geq l\)</span> and <span class="math inline">\(w&#39; \geq w\)</span>, then no setup time is needed. Otherwise, <strong>1 minute</strong> of setup time is required.</p><p>Given <span class="math inline">\(n\)</span> sticks, you are to determine the <strong>minimum total setup time</strong> needed.</p><p>For example, suppose we have five sticks with <span class="math inline">\((length, weight)\)</span> pairs:</p><p><span class="math display">\[(4,9), (5,2), (2,1), (3,5), (1,4)\]</span></p><p>Then the minimum required setup time is 2 minutes, achieved by processing them in the order:</p><p><span class="math display">\[(1,4), (3,5), (4,9), (2,1), (5,2).\]</span></p><p>Design a <strong>greedy algorithm</strong> to solve this problem.</p><h3 id="analysis-and-solution">Analysis and Solution</h3><ol type="1"><li><p><strong>Why use greedy algorithm?</strong></p><blockquote><p>A global optimum could be achieved by series of local optimization value.</p></blockquote><p>In this question, we need to maximize arrays of woodsticks that do not need setups(both <span class="math inline">\(l\)</span> and <span class="math inline">\(w\)</span> are in increasing order). This can be achieved locally by keep appending a stick satisfying <span class="math inline">\(l&#39; \geq l\)</span> and <span class="math inline">\(w&#39; \geq w\)</span> but <span class="math inline">\(l&#39;\)</span> and <span class="math inline">\(w&#39;\)</span> are the smallest.</p><blockquote><p>The optimized solution of the problem includes the optimized solution of the subproblem.</p></blockquote><p>Look in the middle of the process. The subproblem is “Given a part of the sequence of sequenced sticks, and a set of open processing batches, each with its current minimum weight limit, calculate the minimum setup time required to process the remaining sticks.”</p></li><li><p><strong>How to solve?</strong></p><ul><li><p><strong>Sort the sticks.</strong></p><ul><li>Sort in the increasing order of <span class="math inline">\(l\)</span>.</li><li>For sticks with the same <span class="math inline">\(l\)</span>, sort in the increasing order of <span class="math inline">\(w\)</span>.</li></ul><p>Get a general array of all sticks.</p></li><li><p><strong>Greedy Choice</strong></p><ul><li>Start from the first stick.</li><li>Keep inspecting the next stick.<ul><li>If it is appendable without a setup(<span class="math inline">\(l&#39; \geq l\)</span>, <span class="math inline">\(w&#39; \geq w\)</span>), append it to the batch array.</li><li>If it can’t, skip it.</li></ul></li><li>When reaching the end, see whether the general array is empty.<ul><li>If not, start a new batch array, with 1 minute of setup, and repeat step 2.</li><li>If so, terminate.</li></ul></li></ul></li></ul></li></ol><h3 id="pseudocode">Pseudocode</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">algo woodstick(sticks[0..n - 1])</span><br><span class="line">    // INPUT: An array of woodsticks.</span><br><span class="line">    // OUTPUT: Minimal setup time.</span><br><span class="line"></span><br><span class="line">    sort(sticks.begin, sticks.end, cmpSticks)</span><br><span class="line"></span><br><span class="line">    setupTime = 0</span><br><span class="line"></span><br><span class="line">    for i in 0..n - 1 do</span><br><span class="line">        if(sticks[i].isVisited == true) then // If the stick is visited,</span><br><span class="line">            continue // Skip the stick.</span><br><span class="line">        </span><br><span class="line">        setupTime++ // Start a new batch.</span><br><span class="line">        stick[i].isProcessed = true // Mark the first stick in this batch is visited.</span><br><span class="line"></span><br><span class="line">        currentStick = stick[i] // Mark down the current stick.</span><br><span class="line"></span><br><span class="line">        for j in i + 1..n - 1 do</span><br><span class="line">            if(</span><br><span class="line">                stick[j].isProcessed == false &amp;&amp; </span><br><span class="line">                stick[j].length &gt;= currentStick.length &amp;&amp; </span><br><span class="line">                currentStick.weight &gt;= stick[i].weight</span><br><span class="line">            ) do // The unprocessed stick is processable without setup.</span><br><span class="line">                stick[j].isProcessed = true // Process the stick.</span><br><span class="line">                currentStick = stick[j] // Next choice should based on this stick.</span><br><span class="line">    </span><br><span class="line">    return setupTime</span><br><span class="line"></span><br><span class="line">algo cmpSticks(Stick a, Stick b)</span><br><span class="line">    if(a.length != b.length) then</span><br><span class="line">        return a.length &lt; b.length // Shorter stick goes first.</span><br><span class="line"></span><br><span class="line">    if(a.weight != b.weight) then</span><br><span class="line">        return a.weight &lt; b.weight // Lighter stick goes first.</span><br></pre></td></tr></table></figure><h3 id="time-complexity">Time Complexity</h3><ol type="1"><li><p><strong>Sorting(<span class="math inline">\(O(n \log n)\)</span>)</strong></p></li><li><p><strong>Choosing(<span class="math inline">\(O(n^2)\)</span>)</strong></p><ul><li>After starting a batch, we should visit all the sticks remaining. <span class="math inline">\(O(n)\)</span></li><li>Before starting a batch, sequetially find the first unprocessed sticks to start a batch. <span class="math inline">\(O(n)\)</span></li></ul></li></ol><p>Overall,<br /><span class="math display">\[T(n) = O(n \log n) + O(n^2) = O(n^2)\]</span></p><h2 id="knapsack-problem">Knapsack Problem</h2><blockquote><p>Special thanks to Chenghui Zhu.</p></blockquote><p><a href="/2025/12/26/25-11-17-1-COMPSCI220-19-greedy/">【COMPSCI 220】 Lecture 19 Greedy Algorithms</a></p><p>By the way, his file is corrupted. :(</p><h2 id="deleting-degits">Deleting Degits</h2><blockquote><p>Special thanks to Yanhong Cai.</p></blockquote><h3 id="problem-1">Problem</h3><p>There is a number <span class="math inline">\(K\)</span>. For this question, we would like to delete exactly <span class="math inline">\(N\)</span> digits from <span class="math inline">\(K\)</span> so that <strong>the remaining digits form the largest possible number</strong>(the relative order of the remaining digits must stay the same).</p><h3 id="analysis">Analysis</h3><ol type="1"><li><p><strong>Why use greedy algorithm?</strong></p><blockquote><p>A global optimum could be achieved by series of local optimization value.</p></blockquote><p>In this question, the local optimal choice is to delete the first “decreasing” number(delete <code>K[i]</code> when <code>K[i] &lt; K[i + 1]</code>).</p><blockquote><p>The optimized solution of the problem includes the optimized solution of the subproblem.</p></blockquote><p>If we remove a digit from <span class="math inline">\(K\)</span>, the subproblem is “deleting <span class="math inline">\(N - 1\)</span> digits in a string with <span class="math inline">\(K - 1\)</span> digits”. We still need to use the same algorithm to solve it.</p></li><li><p><strong>How to solve it?</strong><br />To ensure the result number is as big as possible, we should let big digits be as far forward as possible.</p><ul><li>Maintain a stack to store the result.</li><li>Iterate the digits.<ul><li>When encountered with a digit larger than the stack top and there are still chances to delete, then pop the stack top.</li><li>Push the digit into the stack.</li></ul></li></ul></li></ol><h3 id="pseudocode-1">Pseudocode</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">algo deleteDigits(K[0..n - 1], N)</span><br><span class="line">    result = new Stack()</span><br><span class="line"></span><br><span class="line">    for digit in K do</span><br><span class="line">        while(result.isEmpty() == false &amp;&amp; digit &gt;= K.top &amp;&amp; N != 0) then</span><br><span class="line">            result.pop()</span><br><span class="line">            N--</span><br><span class="line">        result.push(digit)</span><br></pre></td></tr></table></figure><p>When <span class="math inline">\(K = &quot;642893&quot;\)</span>, <span class="math inline">\(N = 3\)</span>,</p><table><thead><tr class="header"><th>Iteration</th><th><code>K[i]</code></th><th><span class="math inline">\(N\)</span></th><th><code>result(-&gt; top)</code></th></tr></thead><tbody><tr class="odd"><td>0</td><td>6</td><td>3</td><td>6</td></tr><tr class="even"><td>1</td><td>4</td><td>3</td><td>64</td></tr><tr class="odd"><td>2</td><td>2</td><td>3</td><td>642</td></tr><tr class="even"><td>3</td><td>8</td><td>2</td><td>64</td></tr><tr class="odd"><td>3</td><td>8</td><td>1</td><td>6</td></tr><tr class="even"><td>3</td><td>8</td><td>0</td><td></td></tr><tr class="odd"><td>3</td><td>8</td><td>0</td><td>8</td></tr><tr class="even"><td>4</td><td>9</td><td>0(no chance for deletion)</td><td>89</td></tr><tr class="odd"><td>5</td><td>3</td><td>0</td><td>893</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> COMPSCI 220 Algorithms and Data Structures </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 奥克兰大学—西南大学合作课程 </tag>
            
            <tag> 外文 </tag>
            
            <tag> 算法分析与设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【COMPSCI 220】 Lecture 19 Greedy Algorithms</title>
      <link href="/2025/12/26/25-11-17-1-COMPSCI220-19-greedy/"/>
      <url>/2025/12/26/25-11-17-1-COMPSCI220-19-greedy/</url>
      
        <content type="html"><![CDATA[<h2 id="dijkstra-prim-and-kruskal">Dijkstra, Prim and Kruskal</h2><p>All these algorithm can be seen as greedy monsters:<br />At each iteration, make a decision that seems best at this instance.</p><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th>Algorithm</th><th>Strategy</th></tr></thead><tbody><tr class="odd"><td>Dijkstra’s</td><td>Always choose the <strong>node</strong> with <strong>lowest estimated distance</strong>.</td></tr><tr class="even"><td>Prim’s</td><td>Always choose the <strong>edge</strong> with <strong>lowest weight</strong> and <strong>connected to the known region.</strong></td></tr><tr class="odd"><td>Kruskal’s</td><td>Always choose the <strong>edge</strong> with <strong>lowest weight</strong> and <strong>not form a cycle</strong>.</td></tr></tbody></table><h2 id="greedy-choice-property">Greedy Choice Property</h2><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th>Algorithm</th><th>Property</th></tr></thead><tbody><tr class="odd"><td>Dijkstra’s</td><td>A subtree <span class="math inline">\(X\)</span> is a partial shortest path tree if the distance from <span class="math inline">\(s\)</span> to any node in <span class="math inline">\(X\)</span> is optimised.</td></tr><tr class="even"><td>Prim’s</td><td>A subtree <span class="math inline">\(X\)</span> is a <strong>partial MST</strong> if it can be extended to an <strong>MST</strong>.</td></tr><tr class="odd"><td>Kruskal’s</td><td>A subgraph <span class="math inline">\(X\)</span> is a <strong>partial MSF</strong> if it can be extended to an <strong>MST</strong>.</td></tr></tbody></table><p>A greedy algorithm solves an optimisation problem by <strong>making a locally optimal choice</strong> at each time.</p><h3 id="properties">Properties</h3><dl><dt><strong>Global Optimisation Value</strong></dt><dd>This is a function used to <strong>evaluate a solution</strong>.</dd><dt><strong>Local Optimisation Value</strong></dt><dd>This is a function used to <strong>evaluate possible moves</strong> in a single step.</dd></dl><blockquote><p>A local opotimum is not necessarily a global optimum.</p></blockquote><h3 id="general-strategy">General Strategy</h3><p>Starting with an <strong>empty solution</strong>, repeat the following steps:</p><ol type="1"><li>Examine <strong>all ways</strong> to expand the current solution.</li><li><strong>Select</strong> the way that gives the <strong>best local optimisation value</strong>.</li></ol><p>The process stops when there is no way to expand the solution.</p><h2 id="example-1-fractional-knapsack-problem">Example 1: Fractional Knapsack Problem</h2><h3 id="problem">Problem</h3><p>Suppose the burglar enters a food store. Items are such things as milk, rice, flour, beans, <em>etc.</em> You may take a <strong>fraction</strong> of any items.</p><p><strong>INPUT</strong>: Values <span class="math inline">\(v_1, \cdots, v_n\)</span>, weights <span class="math inline">\(w_1, \cdots, w_n\)</span>, and capacity <span class="math inline">\(W\)</span>.<br /><strong>OUTPUT</strong>: A selection of <span class="math inline">\(S_i\)</span> amount of item <span class="math inline">\(i\)</span> for <span class="math inline">\(i = 1, \cdots, n\)</span> that maximises total value, but keep total weight within <span class="math inline">\(W\)</span>.</p><h3 id="solution">Solution</h3><ol type="1"><li><p><strong>Local Optimisation Value</strong><br />At each step, we optimise the value/weight ratio of items.</p></li><li><p><strong>Greedy Choice Property</strong></p><ul><li><p>Suppose <span class="math inline">\(S\)</span> is a partial optimal solution, we have <span class="math inline">\(W&#39;\)</span> kg left, and each item <span class="math inline">\(i\)</span> has <span class="math inline">\(w&#39;_i\)</span> kg left.</p></li><li><p>We make another greedy choice:</p><ul><li><p>Take the remaining item with highest <span class="math inline">\(\frac{value}{weight}\)</span> ratio, say <span class="math inline">\(j\)</span>.</p></li><li><p>Add <span class="math inline">\(\min(W&#39;, w&#39;_j)\)</span> kg item <span class="math inline">\(j\)</span>.</p></li></ul></li><li><p>Then the resulting solution <span class="math inline">\(S&#39;\)</span> is also a partial optimal solution.</p></li></ul></li></ol><blockquote><p>The solution suits the situations when the amount of items is <strong>continuous</strong>.</p><p>For situations when the amount of items is <strong>discret</strong>, use <strong>dynamic programming</strong>.</p></blockquote><p><strong>Correctness</strong><br />If a solution contains <span class="math inline">\(S\)</span> but does not contain <span><span class="math inline">\(\min\{W&#39;, w&#39;j\}\)</span></span> kg item <span class="math inline">\(j\)</span>, then we can increase its value by changing some other items to item <span class="math inline">\(j\)</span>.</p><h3 id="pseudocode">Pseudocode</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Algorithm FracKnapsack(v[1..n], w[1..n], W)</span><br><span class="line">    // INPUT: v[1..n],w[1..n], and capacity W</span><br><span class="line">    // OUTPUT: A set S of (i, Si) pairs indicating amount of item i to take</span><br><span class="line"></span><br><span class="line">    P = new PriorityQueue() // (for storing item-ratio pairs)</span><br><span class="line">    S = new Set() // (solution set for storing item-weight pairs)</span><br><span class="line">    </span><br><span class="line">    for i in 1..n do</span><br><span class="line">        P.add(i, v[i]/w[i])</span><br><span class="line"></span><br><span class="line">    while W &gt; 0 do</span><br><span class="line">        (i, r) = P.RemoveMin()</span><br><span class="line">        S.add((i, min&#123;W, w[i]&#125;))</span><br><span class="line">        W = W − min&#123;W, w[i]&#125;</span><br></pre></td></tr></table></figure><h2 id="example-2-activity-selection-problem">Example 2: Activity Selection Problem</h2><h3 id="problem-1">Problem</h3><p>Select the activities so that we <strong>maximize the number of activities</strong> to<br />attend, under the constraint that we <strong>do not attend two activities at the same time</strong> and we <strong>always attend an entire activity</strong>.</p><ul><li><strong>INPUT</strong>: Activities specified by <span class="math inline">\((s_i, f_i)\)</span> for <span class="math inline">\(i = 1, \cdots, n\)</span>, where <span class="math inline">\(s_i\)</span> is the starting time and <span class="math inline">\(f_i\)</span> the finishing time.</li><li><strong>OUTPUT</strong>: Set <span class="math inline">\(S\)</span> of activities that are not overlapping.</li></ul><h3 id="solution-1">Solution</h3><p><strong>Local Optimal Value</strong></p><ul><li>The finishing time of activities.</li><li>At each step, we choose the activity that <strong>finishes the earliest</strong>(among the remaining attendable activities).</li></ul><h3 id="pseudocode-1">Pseudocode</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Algorithm ActivitySelect(s[1..n], f[1..n])</span><br><span class="line">    // INPUT: starting times s[1..n], finishing times f[1..n]</span><br><span class="line">    // OUTPUT: A set S of activities from &#123;1, ..., n&#125;</span><br><span class="line"></span><br><span class="line">    I = new Set(&#123;1, ..., n&#125;)</span><br><span class="line">    P = new PriorityQueue() // (to store finishing times)</span><br><span class="line">    for i in 1..n do</span><br><span class="line">        P.Insert(i, f[i])</span><br><span class="line"></span><br><span class="line">    S = new Set()</span><br><span class="line"></span><br><span class="line">    while P.isEmpty() == false do</span><br><span class="line">        (x, e) = P.RemoveMin()</span><br><span class="line">        S.add(x)</span><br><span class="line">        for activity in P do</span><br><span class="line">            if activity.isOverlappedWith(x) do</span><br><span class="line">                P.Remove(activity)</span><br><span class="line">    return S</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> COMPSCI 220 Algorithms and Data Structures </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 奥克兰大学—西南大学合作课程 </tag>
            
            <tag> 外文 </tag>
            
            <tag> 算法分析与设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【COMPSCI 220】 Lecture 18 Kruskal&#39;s Algorithm and Disjoint Sets</title>
      <link href="/2025/12/25/25-11-13-2-COMPSCI220-18-kruskal-disjoint/"/>
      <url>/2025/12/25/25-11-13-2-COMPSCI220-18-kruskal-disjoint/</url>
      
        <content type="html"><![CDATA[<h2 id="cut-property-2.0">Cut Property 2.0</h2><p><a href="/2025/12/25/25-11-12-1-COMPSCI220-17-min-span-tree/">Revisit</a></p><p>Let <span class="math inline">\(G = (V, E, w)\)</span> be a weighted graph.</p><p>A <strong>partial MSF(Minimal Spanning Forest)</strong> if <span class="math inline">\(G\)</span> is subsets of edges that could lead to an MST.</p><ul><li>Suppose a partial MSF <span class="math inline">\(X\)</span>.</li><li>Let <span class="math inline">\(e\)</span> be the lightest edge across any two trees in this partial MSF.</li><li>Then <span class="math inline">\(X \cup \{e\}\)</span> is also a partial MSF.</li></ul><h2 id="kruskals-algorithm">Kruskal’s Algorithm</h2><p><strong>Simplify</strong> Prim’s algorithm</p><ul><li>We do not need to make a traversal.</li><li>In other words, we do not need to <strong>keep the known region connected</strong>.</li><li>Eventually, all the disconnected parts will <strong>link together</strong> to form an MST.</li></ul><p><strong>Idea</strong><br />Add edges into the MSF one-by-one:</p><ul><li>In <strong>increasing</strong> order of the <strong>weights</strong>.</li><li>Make sure <strong>no cycle</strong> is created.</li></ul><h3 id="data-structure">Data Structure</h3><p>Kruskal’s algorithm keeps a data structure for <strong>identifying forbidden edges.</strong></p><dl><dt><strong>Disjoint-sets Data Structure</strong></dt><dd>A data structure maintains a collection of <strong>disjoint sets</strong> such that <em>each set has a unique representative element</em> and supports the following operations:</dd></dl><ul><li><code>MakeSet(u)</code>: Make a new set containing element <span class="math inline">\(u\)</span>.</li><li><code>Union(u, v)</code>: Merge the sets containing <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span>.</li><li><code>Find(u)</code>: Return <strong>the representative element</strong> of the set that contains <span class="math inline">\(u\)</span>.</li></ul><h3 id="pseudocode">Pseudocode</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">algo MST_Kruskal(V, E, w)</span><br><span class="line">    SortedEdges = new List(sort(E, &quot;increase&quot;))</span><br><span class="line">    ds = new DisjointSets(V) // Initialize a disjoint-sets with each node a separate set.</span><br><span class="line">    X = new Set()</span><br><span class="line"></span><br><span class="line">    for (u, v) in SortedEdges do</span><br><span class="line">        if(Find(u) != Find(v)) then</span><br><span class="line">            X.add((u, v))</span><br><span class="line">            Union(u, v)</span><br><span class="line">    </span><br><span class="line">    return X</span><br></pre></td></tr></table></figure><h3 id="complexity">Complexity</h3><p>The running time of Kruskal’s algorithm depends on</p><ul><li>The complexity of the <strong>sorting algorithm</strong>.</li><li>The complexity of <strong>union-find operations</strong>.</li></ul><p>Define:</p><ul><li><span class="math inline">\(T_{sort}(x)\)</span> = time to sort <span class="math inline">\(x\)</span> elements</li><li><span class="math inline">\(T_{find}(x)\)</span> = time to find an element</li><li><span class="math inline">\(T_{union}(x)\)</span> = time to take the union of two sets</li></ul><p>Running time for MST Kruskal: <span class="math inline">\(O(T_{sort}(m) + T_{find}(x)m + T_{union}(x)n)\)</span></p><h3 id="implementation">Implementation</h3><ol type="1"><li><p><strong>Lists</strong><br />Each set is representated by an <strong>array</strong>, the representative is the <strong>first</strong> element. <span class="math inline">\(T_{sort}(m) + O(mn)\)</span>.<br /><img src="/image/25-11-13-2-COMPSCI220-18-kruskal-disjoint/1766666809228.webp" alt="1766666809228" /></p><ul><li><code>Union(u, v)</code>: <span class="math inline">\(O(1)\)</span>.</li><li><code>Find(u)</code>: Go through the list. <span class="math inline">\(O(n)\)</span>.</li></ul><p>Then Kruskal’s algorithm takes time <span class="math inline">\(T_{sort}(m) + O(mn)\)</span>.</p></li><li><p><strong>Tree</strong><br />Each set is represented by a tree. The representative is the <strong>root</strong>. Each node is associated with a rank, <em>i.e.</em>, the height of its subtree.</p><ul><li><code>Union(u, v)</code>: Link two trees; point the root with lower rank to the root with higher rank. <span class="math inline">\(O(1)\)</span>.</li><li><code>Find(u)</code>: Follow parent pointers to find the root. The complexity depends on the <strong>height</strong> of the tree.</li></ul><p><img src="/image/25-11-13-2-COMPSCI220-18-kruskal-disjoint/1766666948397.webp" alt="1766666948397" /><br /><img src="/image/25-11-13-2-COMPSCI220-18-kruskal-disjoint/1766666962284.webp" alt="1766666962284" /></p><blockquote><ol type="1"><li>A node with rank <span class="math inline">\(k\)</span> must have at least <span class="math inline">\(2^k\)</span> nodes in its subtree.</li><li>Let <span class="math inline">\(k\)</span> be the largest rank. There can be at most <span class="math inline">\(\frac{n}{2^k}\)</span> nodes of rank <span class="math inline">\(k\)</span>.</li></ol></blockquote><p>The largest rank <span class="math inline">\(k\)</span> is at most <span class="math inline">\(\log n\)</span>, <code>Find(u)</code> takes time <span class="math inline">\(O(\log n)\)</span>.</p><p>Then Kruskal’s algorithm takes time <span class="math inline">\(T_{sort}(m) + O(m \log n)\)</span>.</p></li><li><p><strong>Trees with Path Compression</strong><br /><span class="math display">\[T_{sort}(m) + O(\log^* n)\]</span></p><p>where <span class="math inline">\(\log^*\)</span> is <span class="math inline">\(\log \log \cdots \log\)</span>, the length is <span class="math inline">\(k\)</span>.</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> COMPSCI 220 Algorithms and Data Structures </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 奥克兰大学—西南大学合作课程 </tag>
            
            <tag> 外文 </tag>
            
            <tag> 算法分析与设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【COMPSCI 220】 Lecture 17 Minimal Spanning Tree</title>
      <link href="/2025/12/25/25-11-12-1-COMPSCI220-17-min-span-tree/"/>
      <url>/2025/12/25/25-11-12-1-COMPSCI220-17-min-span-tree/</url>
      
        <content type="html"><![CDATA[<h2 id="spanning-trees">Spanning Trees</h2><ul><li>A graph <span class="math inline">\(G\)</span> is <strong>connected</strong> if it is <strong>a connected component itself</strong>.</li><li>A spanning tree of <span class="math inline">\(G\)</span> is a <strong>connected subgraph</strong> that contains <strong>all nodes</strong> in <span class="math inline">\(V\)</span> and <strong>no cycles</strong>.</li><li>A minimal spanning tree of a weighted graph is a spanning tree whose <strong>total weight is minimal</strong>.</li></ul><blockquote><p><strong>Note</strong>: Minimal spanning trees may not be unique.</p></blockquote><h3 id="minimal-spanning-treemst-problem">Minimal Spanning Tree(MST) Problem</h3><ul><li><strong>INPUT</strong>: A weighted connected (undirected) graph <span class="math inline">\(G = (V, E, w)\)</span>.</li><li><strong>OUTPUT</strong>: A MST of <span class="math inline">\(G\)</span>.</li></ul><h2 id="optimisations-in-a-weighted-graph">Optimisations in a Weighted Graph</h2><dl><dt><strong>Optimisation Problem</strong></dt><dd>An optimization problem contains a solution set where <strong>each solution has a value</strong>. The problem asks to find the solution with the <strong>maximal/minimal value</strong>(The <strong>optimal</strong> solution).</dd></dl><p><strong>Optimised Tree Construction in Weighted Graphs</strong></p><ul><li><strong>Goal</strong>: Construct a tree in the graph that is the optimal solution,</li><li><strong>Optimal Substructure</strong>: If <span class="math inline">\(S\)</span> is an optimal solution, then <strong>any subpart of <span class="math inline">\(S\)</span></strong> is also an optimal solution.</li></ul><h2 id="cut-property-1.0">Cut Property 1.0</h2><p>Let <span class="math inline">\(G = (V, E, w)\)</span> be a weighted graph.</p><ul><li>We say a <strong>partial MST</strong> of <span class="math inline">\(G\)</span> is a <strong>subtree</strong> that could lead to an MST.</li><li>Suppose we have constructed a partial MST <span class="math inline">\(X\)</span> on a subset <span class="math inline">\(S \subseteq V\)</span>.</li><li>Let <span class="math inline">\(e\)</span> be the <strong>lightest edge across the partition</strong> between <span class="math inline">\(S\)</span>(known reigon) and <span class="math inline">\(V − S\)</span>(unknown reigon).</li><li>Then <span class="math inline">\(X \cup \{e\}\)</span> is <strong>also a partial MST</strong>.</li></ul><h2 id="prims-algorithm">Prim’s Algorithm</h2><ul><li>Find MST in a similar way as Dijkstra’s algorithm.</li><li>Maintain a set for the known region.</li><li>Maintain <span class="math inline">\(prev(u)\)</span>(<code>u.prev</code>) for every node <span class="math inline">\(u\)</span> to store the tree.</li><li>Maintain a <strong>priority queue</strong> storing <strong>the candidate edges weights</strong>.</li></ul><p><img src="/image/25-11-12-1-COMPSCI220-17-min-span-tree/1766662918987.webp" width = "525" height = "252" align=center /></p><table><thead><tr class="header"><th>Iteration</th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th><th>F</th></tr></thead><tbody><tr class="odd"><td>1</td><td>0</td><td>INF</td><td>INF</td><td>INF</td><td>INF</td><td>INF</td></tr><tr class="even"><td>2</td><td>(dequeued)</td><td>4(AB)</td><td>4(AC)</td><td>4(AD)</td><td>INF</td><td>INF</td></tr><tr class="odd"><td>3</td><td></td><td>(dequeued)</td><td>2(BC)</td><td>3(BD)</td><td>INF</td><td>6(BF)</td></tr><tr class="even"><td>4</td><td></td><td></td><td>(dequeued)</td><td>1(CD)</td><td>INF</td><td>4(CF)</td></tr><tr class="odd"><td>5</td><td></td><td></td><td></td><td>(dequeued)</td><td>INF</td><td>4(CF)</td></tr><tr class="even"><td>6</td><td></td><td></td><td></td><td></td><td>5(FE)</td><td>(dequeued)</td></tr><tr class="odd"><td>7</td><td></td><td></td><td></td><td></td><td>(dequeued)</td><td></td></tr></tbody></table><p>So the tree contains edges of AB, BC, CD, CF, FE, the total weight is 16.</p><p><img src="/image/25-11-12-1-COMPSCI220-17-min-span-tree/1766663627057.webp" width = "522" height = "234" align=center /></p><blockquote><p>Unlike Dijkstra’s, we fill <strong>edges</strong> into the table this time.</p></blockquote><h3 id="pseudocode">Pseudocode</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">algo MST_Prim(V, E, w)</span><br><span class="line">    s = V[0]</span><br><span class="line">    R = new Set(&#123;s&#125;)</span><br><span class="line">    P = new PriorityQueue(&#123;s, 0&#125;)</span><br><span class="line"></span><br><span class="line">    for u in V, u != s do</span><br><span class="line">        u.prev = NULL</span><br><span class="line">        u.value = INF</span><br><span class="line">        P.Insert(u, INF)</span><br><span class="line"></span><br><span class="line">    while P.isEmpty() != false do</span><br><span class="line">        u = P.DeleteMin()</span><br><span class="line">        R.add(u)</span><br><span class="line"></span><br><span class="line">        for (u, v) in E &amp;&amp; v not in R do</span><br><span class="line">            if weight(u, v) &lt; value(u, v) then</span><br><span class="line">                value(v) = weight(u, v)</span><br><span class="line">                P.DecreaseKey(v, v.value)</span><br><span class="line">                v.prev = u</span><br></pre></td></tr></table></figure><h3 id="complexity">Complexity</h3><p>For different data structure for priority queue,</p><ul><li><strong>Linked list</strong>: <span class="math inline">\(O(n^2)\)</span>.<br />Preferred when there are lots of edges, <span class="math inline">\(m \geq \frac{n^2}{\log n}\)</span>.</li><li><strong>Binary heap</strong>: <span class="math inline">\(O((m + n) \log n)\)</span>.<br />Preferred when there aren’t lots of edges, <span class="math inline">\(m &lt; \frac{n^2}{\log n}\)</span>.</li><li><strong>Fibonacci Heap</strong>: <span class="math inline">\(O(n \log n + m)\)</span>.<br />Better, but too complicated for implementation.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> COMPSCI 220 Algorithms and Data Structures </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 奥克兰大学—西南大学合作课程 </tag>
            
            <tag> 外文 </tag>
            
            <tag> 算法分析与设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【COMPSCI 220】 Lecture 16 Distances in Weight Graphs</title>
      <link href="/2025/12/25/25-11-12-1-COMPSCI220-16-dist-wg/"/>
      <url>/2025/12/25/25-11-12-1-COMPSCI220-16-dist-wg/</url>
      
        <content type="html"><![CDATA[<h2 id="weighted-graphs">Weighted Graphs</h2><dl><dt><strong>Weighted Graph</strong></dt><dd>A weighted graph is <span class="math inline">\(G = (V, E, w)\)</span> where <span class="math inline">\((V, E)\)</span> is an <strong>undirected graph</strong> and <span class="math inline">\(w : E → \mathbf{Z}\)</span> is a weight function that assigns each edge with an integer weight.</dd></dl><p>We extend adjacency matrix or adjacency list representations to weighted graphs.</p><h2 id="distances-weighted-graph">Distances Weighted Graph</h2><p><strong>Goals</strong>: Compute distances in a weighted graph.</p><p>If weights are integers, <strong>subdivide edges</strong> into a sequence of uni-length edges, convert a weighted graph into an unweighted graph.</p><p>However, the time complexity of BFS would depend on the sum of all weights.</p><h2 id="a-lazy-way-for-finding-distances">A “Lazy” Way for Finding Distances</h2><p>We don’t care about the distances on these auxiliary nodes. We could just “go to sleep” when BFS visits these auxiliary nodes, But we need to “wake up” when BFS visits an original node.</p><h3 id="setting-the-alarm-clock">Setting the Alarm Clock</h3><p><strong>Strategy</strong></p><ul><li>Maintain an “alarm clock” for each node. The time we set on an alarm clock is an expected time for visiting this node.</li><li>Whenever an alarm clock goes off, wake up and check which node is reached. Then reset the other clocks.</li></ul><h3 id="implementing-the-alarm-clocks">Implementing the Alarm Clocks</h3><p>Find a data structure that stimulates the alarm clock system.</p><dl><dt><strong>Priority queue</strong></dt><dd>A data structure that stores a collection of <code>(element, key)</code> pairs where the key of an element is an <strong>integer value</strong> and allows the following operations:</dd><dd></dd><dd><ul><li><code>Insert(e, k)</code>: Add a new element <code>e</code> with key <code>k</code> to the collection.</li></ul></dd><dd><ul><li><code>DeleteMin()</code>: Return the element with <strong>the smallest key</strong>, and remove it from the collection.</li></ul></dd><dd><ul><li><code>ResetKey(e, k)</code>: Reset the key value of element <code>e</code> to <strong>a smaller value</strong> <code>k</code>.</li></ul></dd><dt><strong>Binary Heap</strong></dt><dd>A special heap data structure that is often used to implement priority queues. It is a <strong>complete binary tree</strong>, that is, every layer except the bottom is completely filled, and the bottom nodes are arranged as far to the left as possible.</dd><dd></dd><dd><ul><li><strong>Max Heap</strong>: The key value of each parent node is greater than or equal to the key value of all its child nodes.</li></ul></dd><dd><ul><li><strong>Min Heap</strong>: The key value of each parent node is less than or equal to the key value of all its child nodes.</li></ul></dd></dl><h2 id="dijkstras-algorithm">Dijkstra’s Algorithm</h2><p>Implementing the “Alarm Clocks” using <strong>priority queue</strong>:</p><ul><li>Maintain a priority key set for each node</li><li>Maintain a set of confirmed nodes</li></ul><h3 id="pseudocode">Pseudocode</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">algo Dijkstra(G, s)</span><br><span class="line">    s.dist = 0</span><br><span class="line">    Reach = new Set(&#123;s&#125;)</span><br><span class="line">    P = new PriorityQueue(&#123;(s, 0)&#125;)</span><br><span class="line"></span><br><span class="line">    for u in V &amp;&amp; u != s do</span><br><span class="line">        u.dist = INF</span><br><span class="line">        u.prev = NULL</span><br><span class="line">        P.Insert(u, INF)</span><br><span class="line"></span><br><span class="line">    while P.isEmpty() != false do</span><br><span class="line">        u = P.DeleteMin()</span><br><span class="line">        Reach.add(u)</span><br><span class="line"></span><br><span class="line">        for (u, v) in E &amp;&amp; v not in Reach do</span><br><span class="line">            if u.dist + w(u, v) &lt; v.dist do</span><br><span class="line">                P.ResetKey(v, dist(v))</span><br><span class="line">                v.prev = u</span><br><span class="line">    </span><br><span class="line">    return all v.dist in G</span><br></pre></td></tr></table></figure><h3 id="correctness">Correctness</h3><h3 id="complexity">Complexity</h3><p>The running time of the algorithm depends on the running time of <strong>priority queue implementations</strong>.</p><ul><li>Let <span class="math inline">\(T_{in}(n)\)</span> be the time it takes to <strong>insert elements</strong> to the priority queue.<br /></li><li>Let <span class="math inline">\(T_{re}(n)\)</span> be the time it takes to <strong>reset key</strong> for an element in the priority queue.</li><li>Let <span class="math inline">\(T_{de}(n)\)</span> be the time it takes to <strong>delete min element</strong> from the priority queue.</li></ul><p>Running time <span class="math inline">\(nT_{in}(n) + mT_{re}(n) + nT_{de}(n)\)</span>.</p><p>For different data structure for priority queue,</p><ul><li><strong>Linked list</strong>: <span class="math inline">\(O(n^2)\)</span>.<br />Preferred when there are lots of edges, <span class="math inline">\(m \geq \frac{n^2}{\log n}\)</span>.</li><li><strong>Binary heap</strong>: <span class="math inline">\(O((m + n) \log n)\)</span>.<br />Preferred when there aren’t lots of edges, <span class="math inline">\(m &lt; \frac{n^2}{\log n}\)</span>.</li><li><strong>Fibonacci Heap</strong>: <span class="math inline">\(O(n \log n + m)\)</span>.<br />Better, but too complicated for implement.</li></ul><h2 id="graph-exploration">Graph Exploration</h2><p>A <strong>graph exploration algorithm</strong> traverses the graph:</p><ul><li>The algorithm maintains a <strong>known region</strong> of nodes.</li><li>Each time it picks an edge that <strong>goes out</strong> from the known region, exploring a node outside and expanding its known region.</li><li>It stops when no more edge can be explored.</li></ul><h3 id="relationship-between-three-algorithms">Relationship Between Three Algorithms</h3><table><thead><tr class="header"><th>Algorithm</th><th>Edge Picking Order</th></tr></thead><tbody><tr class="odd"><td>DFS</td><td>stack order</td></tr><tr class="even"><td>BFS</td><td>queue order</td></tr><tr class="odd"><td>Dijkstra’s Algorithm</td><td>priority order</td></tr></tbody></table><h2 id="question">Question</h2><p>Suppose you would like to find the longest path from a given node to other nodes in a weighted directed acyclic graph. Someone suggests that maybe we can try modifying Dijkstra’s algorithm, so that instead of using a min-heap (as we do for Dijkstra’s algorithm), we use a max-heap, <em>i.e.</em>, a priority queue where we have <code>DeleteMax</code> operation that returns and removes the maximum element, and update the value <code>v.dist</code> for a node <code>v</code> whenever we find a longer path to <code>v</code>. Do you think this algorithm would correctly compute the longest distance from the starting node to other nodes in a dag? Explain why.</p><hr /><p><strong>No, it cannot.</strong></p><p>If a node is removed from the priority queue, it means that this is the final distance of the shortest path, which will not be affected by the following iterations. However, for the longest path, distances can increase as the algorithm iterates.</p><p>Consider a small graph.</p><pre class="mermaid">flowchart LRa(("0")) -->|10| b(("1"))a -->|1| c(("2"))c -->|10| b</pre><p>Iteration table(start from 0)</p><table><thead><tr class="header"><th>Iteration</th><th>0</th><th>1</th><th>2</th></tr></thead><tbody><tr class="odd"><td>1</td><td>0</td><td>INF</td><td>INF</td></tr><tr class="even"><td>2</td><td>(dequeued)</td><td>10(01)</td><td>1(02)</td></tr><tr class="odd"><td>3</td><td></td><td><font color="red">(dequeued)/11(021)?</font></td><td>1(02)</td></tr></tbody></table><p><strong>Contradiction</strong>: From step 2 to 3, node 1 should be removed with the distance 10. But path 021 has the longer path distance 11, affected the result we’ve made.</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> COMPSCI 220 Algorithms and Data Structures </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 奥克兰大学—西南大学合作课程 </tag>
            
            <tag> 外文 </tag>
            
            <tag> 算法分析与设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【COMPSCI 220】 Lecture 15 Breadth First Search</title>
      <link href="/2025/12/25/25-11-10-2-COMPSCI220-15-bfs/"/>
      <url>/2025/12/25/25-11-10-2-COMPSCI220-15-bfs/</url>
      
        <content type="html"><![CDATA[<h2 id="distance-between-nodes">Distance Between Nodes</h2><p>The distance from <span class="math inline">\(u\)</span> to <span class="math inline">\(v\)</span>, <span class="math inline">\(dist(u, v)\)</span>, is the length of <strong>the shortest path</strong> from <span class="math inline">\(u\)</span> to <span class="math inline">\(v\)</span>. If there is no path, then <span class="math inline">\(dist(u, v) = \infty\)</span>.</p><h3 id="distance-problem">Distance Problem</h3><ul><li><strong>INPUT</strong>: a graph <span class="math inline">\(G\)</span>, and two nodes <span class="math inline">\(u\)</span>, <span class="math inline">\(v\)</span>.</li><li><strong>OUTPUT</strong>: the distance from <span class="math inline">\(u\)</span> to <span class="math inline">\(v\)</span>.</li></ul><h3 id="shortest-path-problem">Shortest Path Problem</h3><ul><li><strong>INPUT</strong>: a graph <span class="math inline">\(G\)</span>, and two nodes <span class="math inline">\(u\)</span>, <span class="math inline">\(v\)</span>.</li><li><strong>OUTPUT</strong>: the shortest path from <span class="math inline">\(u\)</span> to <span class="math inline">\(v\)</span>.</li></ul><h2 id="missionary-and-cannibals">Missionary and Cannibals</h2><details>There are 3 missionaries and 3 cannibals coming to a river with only one boat that can hold only 2 people. At any instance the number of cannibals cannot be more than the number of missionaries. What is the least number of boat rides for all the people to cross the river?</details><p>Define a graph <span class="math inline">\(G = (V, E)\)</span>, where <span class="math inline">\(V\)</span> contains all possible state, <span class="math inline">\(E\)</span> all transitions with one boat ride.</p><p>Then find the shortest path from <span class="math inline">\((, \cdot MMMCCC) \rightarrow (\cdot MMMCCC,)\)</span>.</p><h2 id="breadth-first-search">Breadth First Search</h2><h3 id="strategy">Strategy</h3><ul><li>Visit the start node <span class="math inline">\(s\)</span>.</li><li>Visit <strong>all nodes</strong> that have distance 1 from <span class="math inline">\(s\)</span> (call them <span class="math inline">\(V_1\)</span>).</li><li>Visit <strong>all nodes</strong> that have distance 1 from <span class="math inline">\(V_1\)</span> (call them <span class="math inline">\(V_2\)</span>).</li><li>…</li></ul><h3 id="implementation">Implementation</h3><p>Maintain a <strong>queue</strong> of to-be-explored nodes.</p><p>At each iteration</p><ul><li>Finish the first element in the queue, then <strong>dequeue</strong> it.</li><li><strong>Enqueue</strong> the <strong>out-neighbour</strong> of the dequeued element.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">algo bfs(Diagram G)</span><br><span class="line">    // INPUT: A graph G and a starting node s</span><br><span class="line">    // OUTPUT: Labeling dist(u) for every u</span><br><span class="line"></span><br><span class="line">    for u in V</span><br><span class="line">        u.dist = INF</span><br><span class="line"></span><br><span class="line">    for u in G.V</span><br><span class="line">        if u.dist = INF </span><br><span class="line">            bfs_explore(G, u)</span><br><span class="line"></span><br><span class="line">algo bfs_explore(Diagram G, Node s)</span><br><span class="line">    Q = new Queue()</span><br><span class="line">    Q.enqueue(s)</span><br><span class="line"></span><br><span class="line">    while Q.isEmpty == false</span><br><span class="line">        u = Q.dequeue() // Dequeue the first element and assign this element to u.</span><br><span class="line">        for any outgoing edge (u, v) do</span><br><span class="line">            if v.dist = INF do</span><br><span class="line">                Q.enqueue(v)</span><br><span class="line">                v.dist = u.dist + 1</span><br></pre></td></tr></table></figure><p>After running <code>bfs_explore(G, s)</code>, <code>u.dist</code> is the distance from <span class="math inline">\(s\)</span> to <span class="math inline">\(u\)</span>.</p><h3 id="complexity">Complexity</h3><ul><li>Every node <span class="math inline">\(u\)</span> may be enqueued and dequeued <strong>at most once</strong>.</li><li>Every edge may be checked <strong>at most once</strong>.</li></ul><p>Therefore the running time of the BFS algorithm is <span class="math inline">\(O(m + n)\)</span>.</p><h2 id="summary">Summary</h2><table style="width:100%;"><colgroup><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 16%" /></colgroup><thead><tr class="header"><th>Algorithm</th><th>Exploration</th><th>Strategy</th><th>Data Structure</th><th>Running Time</th><th>Application</th></tr></thead><tbody><tr class="odd"><td>DFS</td><td>deep but narrow</td><td>Only retreat when it runs out of new nodes.</td><td>stack</td><td><span class="math inline">\(O(m + n)\)</span></td><td>reachability, linearizability, connectedness</td></tr><tr class="even"><td>BFS</td><td>shallow but breadth</td><td>Visit nodes by increasing distances.</td><td>queue</td><td><span class="math inline">\(O(m + n)\)</span></td><td>distance</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> COMPSCI 220 Algorithms and Data Structures </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 奥克兰大学—西南大学合作课程 </tag>
            
            <tag> 外文 </tag>
            
            <tag> 算法分析与设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【COMPSCI 220】 Lecture 14 Connectivity and Components</title>
      <link href="/2025/12/25/25-11-10-1-COMPSCI220-14-connectivity/"/>
      <url>/2025/12/25/25-11-10-1-COMPSCI220-14-connectivity/</url>
      
        <content type="html"><![CDATA[<h2 id="subgraph">Subgraph</h2><dl><dt><strong>Subgraph</strong></dt><dd>Let <span class="math inline">\(E \subseteq V^2\)</span>, <span class="math inline">\(V&#39; \subseteq V\)</span>,</dd><dd></dd><dd><ul><li><span class="math inline">\(E \upharpoonright V&#39; = \{(u, v ) \in E | u, v \in V&#39;\}\)</span>(all edges that is used by <span class="math inline">\(V&#39;\)</span> in <span class="math inline">\(G\)</span>).</li></ul></dd><dd><ul><li>A subgraph of <span class="math inline">\(G = (V, E)\)</span> is a diagraph <span class="math inline">\(G&#39; = (V&#39;, E&#39;)\)</span> where <span class="math inline">\(V&#39; \subseteq V\)</span> and <span class="math inline">\(E&#39; \subseteq E \upharpoonright V&#39;\)</span>.</li></ul></dd><dd><ul><li>If <span class="math inline">\(E&#39; = E \upharpoonright V&#39;\)</span>, then the subgraph is an <strong>induced subgraph</strong>.</li></ul></dd></dl><h2 id="decomposing-undirected-graphs">Decomposing Undirected Graphs</h2><p>We may decompose the graph into <strong>equivalence classes</strong>: Two nodes are in the same class if they are reachable from each other.</p><p>Each equivalence class is a connected component.</p><dl><dt><strong>Undirected Connectivity</strong></dt><dd>A connected components is the induced subgraph of a maximal set of nodes that are <strong>pairwise reachable</strong>.</dd><dd>An undirected graph is <strong>connected</strong> if it contains <strong>only one connected component</strong>.</dd></dl><p>We may use DFS to decide whether two nodes are in the same CC, <span class="math inline">\(O(m + n)\)</span>.</p><h2 id="decomposing-directed-graph">Decomposing Directed Graph</h2><dl><dt><strong>Directed Connectivity</strong></dt><dd>In a digraph <span class="math inline">\(G\)</span>, we say that two nodes <span class="math inline">\(u\)</span>, <span class="math inline">\(v\)</span> are in the same <strong>strongly connected component (SCC)</strong> if there is a <strong>path</strong> from <span class="math inline">\(u\)</span> to <span class="math inline">\(v\)</span> and a path from <span class="math inline">\(v\)</span> to <span class="math inline">\(u\)</span>. A digraph is strongly connected if it contains <strong>only one SCC</strong>.</dd></dl><h3 id="speacial-cases">Speacial Cases</h3><table><colgroup><col style="width: 33%" /><col style="width: 33%" /><col style="width: 33%" /></colgroup><thead><tr class="header"><th>Graph</th><th>SCC Count</th><th>Actual Meaning</th></tr></thead><tbody><tr class="odd"><td>acyclic</td><td><span class="math inline">\(n\)</span></td><td>every node itself</td></tr><tr class="even"><td>cycle</td><td><span class="math inline">\(1\)</span></td><td><span class="math inline">\(G\)</span> itself</td></tr><tr class="odd"><td>undirected</td><td><span class="math inline">\(u\)</span>, <span class="math inline">\(v\)</span> are in the same SCC whenever <span class="math inline">\(u\)</span> can reach <span class="math inline">\(v\)</span></td><td>checking is the same as reachability</td></tr></tbody></table><h3 id="scc-problem">SCC Problem</h3><ul><li><strong>INPUT</strong>: A digraph <span class="math inline">\(G\)</span>.</li><li><strong>OUTPUT</strong>: All the SCC of <span class="math inline">\(G\)</span>.</li></ul><h2 id="meta-graph">Meta-graph</h2><dl><dt><strong>Meta-Graph</strong></dt><dd>Given a graph <span class="math inline">\(G\)</span>. If we collapse all nodes in the same SCCs together, only keeping the edges between different components, then we get the <strong>meta-graph</strong>, <span class="math inline">\(G^{SCC}\)</span>.</dd></dl><h3 id="source-and-sink">Source and Sink</h3><p><span class="math inline">\(G^{SCC}\)</span> should be <strong>acylic</strong>, otherwise it is not fully collapsed.</p><ul><li><strong>Source</strong>: A node in <span class="math inline">\(G^{SCC}\)</span> with no incoming edge.</li><li><strong>Sink</strong>: A node in <span class="math inline">\(G^{SCC}\)</span> with no outgoing edge.</li></ul><blockquote><p>If we run <strong>DFS</strong> in a <strong>sink</strong>, then we’ll find all nodes in this sink.</p></blockquote><h2 id="scc-problem-1">SCC Problem</h2><h3 id="a-plan-for-finding-scc">A Plan for Finding SCC</h3><p>Given <span class="math inline">\(G\)</span>. Repeat the following:</p><ol type="1"><li>Find a node <span class="math inline">\(u\)</span> in a <strong>sink</strong>.</li><li>Run <code>dfs_explore(G, u)</code>.</li><li>Declare all visited nodes an SCC. Take those nodes out.</li></ol><h3 id="find-a-sink">Find a Sink</h3><ol type="1"><li>Run DFS, the node that <strong>finished first</strong> is the <strong>souce</strong>.</li><li>Let <span class="math inline">\(G^T\)</span> be the <strong>transpose</strong> of <span class="math inline">\(G\)</span>, where <strong>the direction of all edges is reversed</strong>, then <em>all sources become sinks and all sinks become sources</em>.</li></ol><h3 id="algorithm">Algorithm</h3><ol type="1"><li>Run DFS in the original <span class="math inline">\(G\)</span>.</li><li>List nodes in reverse finishing order.</li><li>Draw <span class="math inline">\(G^T\)</span>.</li><li>Run DFS on <span class="math inline">\(G^T\)</span> in the reverse finishing order.</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">algo SCC(G)</span><br><span class="line">    stack = new Stack()</span><br><span class="line"></span><br><span class="line">    Run dfs(G). When a node is finished,</span><br><span class="line">        stack.push(u)</span><br><span class="line">    </span><br><span class="line">    GT = transpose(G)</span><br><span class="line">    for u in popOrder(stack)</span><br><span class="line">        dfs_explore(GT, u) // The nodes visited by explore is the SCC of u.</span><br></pre></td></tr></table></figure><p>Time complexity: <span class="math inline">\(O(m + n)\)</span>.</p><p>Essentially, the algorithm runs DFS <strong>twice</strong>: first time on <span class="math inline">\(G\)</span>, then<br />on <span class="math inline">\(G^T\)</span>. In the second time, when no where to go, select <em>the next node in decreasing order of finishing time of the first DFS</em>.</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> COMPSCI 220 Algorithms and Data Structures </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 奥克兰大学—西南大学合作课程 </tag>
            
            <tag> 外文 </tag>
            
            <tag> 算法分析与设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【COMPSCI 220】 Lecture 13  Directed Acyclic Graph</title>
      <link href="/2025/12/25/25-11-6-2-COMPSCI220-13-dag/"/>
      <url>/2025/12/25/25-11-6-2-COMPSCI220-13-dag/</url>
      
        <content type="html"><![CDATA[<h2 id="directed-acyclic-graphsdag">Directed Acyclic Graphs(DAG)</h2><h3 id="definition">Definition</h3><dl><dt><strong>DAG</strong></dt><dd>A directed acyclic graph (dag) is a digraph that <strong>does not</strong> contain a cycle.</dd></dl><h3 id="acyclicity-problem">Acyclicity Problem</h3><p>How to determin whether a graph is a DAG?</p><details><p>Let <span class="math inline">\(T\)</span> be the <strong>DFS forest</strong> in <span class="math inline">\(G\)</span>. There are four types of edges in <span class="math inline">\(G\)</span>:</p><ul><li>If <span class="math inline">\((u, v)\)</span> belongs to the search forest, <span class="math inline">\((u, v)\)</span> is <strong>a tree edge</strong>.</li><li>Otherwise if <span class="math inline">\(u\)</span> is an ancestor of <span class="math inline">\(v\)</span> in <span class="math inline">\(T\)</span>, <span class="math inline">\((u, v)\)</span> is a <strong>forward edge</strong>.</li><li>Otherwise if <span class="math inline">\(v\)</span> is an ancestor of u in <span class="math inline">\(T\)</span>, <span class="math inline">\((u, v)\)</span> is a <strong>back edge</strong>.</li><li>Otherwise <span class="math inline">\((u, v)\)</span> is a <strong>cross edge</strong>.</li></ul></details><h3 id="fact">Fact</h3><ol type="1"><li><span class="math inline">\(G\)</span> is a DAG <span class="math inline">\(\Leftrightarrow\)</span> the DFS forest has <strong>no back edge</strong>.</li><li>The following algorithm runs in time <span class="math inline">\(O(n + m)\)</span> and decides whether any given digraph <span class="math inline">\(G\)</span> is a dag.</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">algo Acyclic(G)</span><br><span class="line">    // INPUT: A diagraph G.</span><br><span class="line">    // OUTPUT: Whether G is a DAG.</span><br><span class="line">    Run DFS(G) with the following modification:</span><br><span class="line">        Whenever discover a node u, do</span><br><span class="line">            for every edge (u, v) out of u</span><br><span class="line">                if pre(v) &lt; pre(u) and post(v) is undefined // There is a back edge.</span><br><span class="line">                    return false // Declare G has a cycle and return.</span><br><span class="line">    return true // Declare that G is a dag.</span><br></pre></td></tr></table></figure><h2 id="dfs-and-linearisations">DFS and Linearisations</h2><dl><dt><strong>Linearization</strong></dt><dd>A <strong>linearization</strong> or (<strong>topological sort</strong>) of a digraph <span class="math inline">\(G\)</span> is a <strong>list of all nodes</strong> in <span class="math inline">\(G\)</span> such that if <span class="math inline">\(G\)</span> contains an edge <span class="math inline">\((u, v)\)</span> then <span class="math inline">\(u\)</span> appears <strong>before</strong> <span class="math inline">\(v\)</span> in the list.</dd></dl><ul><li>All DAGs can be linearized.</li><li>Digraph <strong>with cycles</strong> cannot be linearized.</li></ul><h3 id="zero-indegree-algorithm">Zero-indegree Algorithm</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">algo ZeroInDegree(G)</span><br><span class="line">    // INPUT: A DAG G.</span><br><span class="line">    // OUTPUT: The linearisation.</span><br><span class="line"></span><br><span class="line">    list = new List() // list = []</span><br><span class="line">    while G.isEmpty == false do</span><br><span class="line">        for u in V</span><br><span class="line">            if u.inDegree() == 0 then</span><br><span class="line">                list.append(u)</span><br><span class="line">                G.delete(u)</span><br><span class="line">    return list</span><br></pre></td></tr></table></figure><p>Running time complexity: <span class="math inline">\(O((n + m)n)\)</span>.</p><h3 id="dfs-based-linearisations">DFS-based Linearisations</h3><p>For an edge <span class="math inline">\((u, v) \in E\)</span>, there <strong>must</strong> be <span class="math inline">\(post(v) &lt; post(u)\)</span></p><ul><li><span class="math inline">\(u\)</span> is discovered before <span class="math inline">\(v\)</span> <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(v\)</span> is finished before <span class="math inline">\(u\)</span> is finished.</li><li><span class="math inline">\(v\)</span> is discovered before <span class="math inline">\(u\)</span> <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(v\)</span> is finished before <span class="math inline">\(u\)</span> is finished.</li></ul><p>We obtain an easy algorithm for graph linearisation in time <span class="math inline">\(O(m + n)\)</span>: Output the list of nodes in decreasing finishing order.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">algo dfsLinearise(G)</span><br><span class="line">    // INPUT: A DAG G.</span><br><span class="line">    // OUTPUT: A linearisation of G.</span><br><span class="line">    stack = new Stack()</span><br><span class="line"></span><br><span class="line">    Run dfs(G), in addition:</span><br><span class="line">        when a node is finished, stack.push(u)</span><br><span class="line">    </span><br><span class="line">    return popOrder(stack)</span><br></pre></td></tr></table></figure><p>This will create a list in <strong>decreasing finishing order</strong>(from the latest to the earliest).</p><h2 id="further-comments">Further Comments</h2><p><span class="math display">\[\rm Linearizable \equiv Acyclicity \equiv \text{No-back-edgeness}\]</span></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> COMPSCI 220 Algorithms and Data Structures </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 奥克兰大学—西南大学合作课程 </tag>
            
            <tag> 外文 </tag>
            
            <tag> 算法分析与设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【COMPSCI 220】 Lecture 12 Depth First Search</title>
      <link href="/2025/12/25/25-11-6-1-COMPSCI220-12-dfs/"/>
      <url>/2025/12/25/25-11-6-1-COMPSCI220-12-dfs/</url>
      
        <content type="html"><![CDATA[<h2 id="graph-traverse">Graph Traverse</h2><p>Graph Traversal refers to the process of starting from a vertex in the graph and accessing <strong>all vertices</strong> in the graph according to a certain rule, and <strong>each vertex is accessed only once</strong>. It is the basis for many graph algorithms such as shortest path, connected component detection, <em>etc.</em></p><h2 id="depth-first-search">Depth First Search</h2><h3 id="problem">Problem</h3><ul><li><strong>INPUT</strong>: A (representation of) digraph <span class="math inline">\(G\)</span>.</li><li><strong>OUTPUT</strong>: Enumeration of all nodes in the digraph following arcs of the digraph.</li></ul><h3 id="stategy">Stategy</h3><p>Each node is proceed in two stages:</p><ul><li><strong>Stage 1.</strong> A node is discovered(<strong>preproceed</strong>): the first time it is visited.</li><li><strong>Stage 2.</strong> A node is finished(<strong>postproceed</strong>): the last time it is visited.</li></ul><h3 id="implementation">Implementation</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Algo dfs(Diagraph G)&#123;</span><br><span class="line">    for v in V &#123;</span><br><span class="line">        v.isVisited = false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for v in V &#123;</span><br><span class="line">        if v.isVisited == false &#123;</span><br><span class="line">            explore(G, v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Algo explore(Diagraph G, Vertex v)&#123;</span><br><span class="line">    v.isVisited = true</span><br><span class="line">    discover(v) // Let v be discovered.</span><br><span class="line">    for (v, u) in E &#123;  // for all vertex u that is v -&gt; u is an edge.</span><br><span class="line">        if (u.isVisited == false)&#123;</span><br><span class="line">            explore(G, u)</span><br><span class="line">        &#125;</span><br><span class="line">        finish(v) // Let v be finished.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Implementing <code>explore(G, v)</code> with FILO stack.<br /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">algo explore(Diagram G, Vertex v)&#123;</span><br><span class="line">    S = new Stack()</span><br><span class="line">    S.push(v)</span><br><span class="line">    v.isVisited = true</span><br><span class="line"></span><br><span class="line">    while !(S.isEmpty())&#123;</span><br><span class="line">        u = S.top()</span><br><span class="line">        discover(u)</span><br><span class="line">        w = first node such that (u, w) in E and w.isVisited == false</span><br><span class="line"></span><br><span class="line">        if w == undefined then</span><br><span class="line">            finish(u)</span><br><span class="line">            S.pop(u)</span><br><span class="line">        else </span><br><span class="line">            S.push(w)</span><br><span class="line">            w.isVisited = true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="complexity">Complexity</h3><ul><li>Discover and finish each node <span class="math inline">\(O(n)\)</span>.</li><li>Visiting the out-neighbours if each node <span class="math inline">\(O(n + m)\)</span>(with adjacency list) or <span class="math inline">\(O(n^2)\)</span>(with adjacency matrix).</li></ul><blockquote><p><strong>Fact</strong><br />The DFS algorithm takes <span class="math inline">\(O(n + m)\)</span> time woth adjacency list and <span class="math inline">\(O(n^2)\)</span> with adjacency matrix.</p></blockquote><h2 id="dfs-and-reachability">DFS and Reachability</h2><dl><dt><strong>Reachability</strong></dt><dd>Node <span class="math inline">\(u\)</span> is <strong>reachable</strong> from <span class="math inline">\(v\)</span> in <span class="math inline">\(G\)</span> if there is a <strong>path</strong> that <span class="math inline">\(v \rightsquigarrow u\)</span>.</dd></dl><p><code>explore(G, v)</code> can visit <span class="math inline">\(u\)</span> <strong>if and only if</strong> <span class="math inline">\(u\)</span> is reachable from <span class="math inline">\(v\)</span>.</p><h2 id="dfs-and-searching-tree">DFS and Searching Tree</h2><dl><dt><strong>Search Forest</strong></dt><dd>DFS defines one or more search trees, forming a forest in the<br />digraph. These trees contain <strong>all paths DFS used</strong> to visit nodes in <span class="math inline">\(G\)</span>.</dd></dl><p>Maintain a “timer” in the algorithm, and two times <span class="math inline">\(pre(u)\)</span> and <span class="math inline">\(post(u)\)</span> for each node <span class="math inline">\(u\)</span>:</p><ul><li><span class="math inline">\(pre(u)\)</span>: the time step in which <span class="math inline">\(u\)</span> is first visited.</li><li><span class="math inline">\(post(u)\)</span>: the time step in which <span class="math inline">\(u\)</span> is last visited.</li></ul><p>Therefore we can represent the search trees in <strong>parenthesis form</strong>:</p><ul><li>If <span class="math inline">\(pre(u) = k\)</span>, then the <span class="math inline">\(k\)</span>th symbol is <code>(u</code>.</li><li>If <span class="math inline">\(post(u) = k\)</span>, then the <span class="math inline">\(k\)</span>th symbol is <code>u)</code>.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> COMPSCI 220 Algorithms and Data Structures </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 奥克兰大学—西南大学合作课程 </tag>
            
            <tag> 外文 </tag>
            
            <tag> 算法分析与设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【计算机组成原理】 第五章 存储系统</title>
      <link href="/2025/12/24/25-11-26-2-CompOrg-5-mem/"/>
      <url>/2025/12/24/25-11-26-2-CompOrg-5-mem/</url>
      
        <content type="html"><![CDATA[<h2 id="存储系统的组成">5.1 存储系统的组成</h2><h3 id="存储器分类">5.1.1 存储器分类</h3><ol type="1"><li><p><strong>按存储器在计算机中的作用分</strong></p><table><colgroup><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /></colgroup><thead><tr class="header"><th>名称</th><th>作用</th><th>成本</th><th>性能</th></tr></thead><tbody><tr class="odd"><td>高速存储缓冲器（Cache）</td><td>位于主存与 CPU 之间，存放正在执行的程序段与数据</td><td>高</td><td>速度与 CPU 匹配，容量小</td></tr><tr class="even"><td>主存储器</td><td>存放计算机运行期间所需要的程序和数据，CPU 和直接随机读写</td><td></td><td>速度较高，具有一定容量</td></tr><tr class="odd"><td>辅助存储器（外存储器、后援存储器）</td><td>存放当前暂不运行的程序和数据以及永久保存的信息</td><td>很低</td><td>容量大，速度较慢</td></tr></tbody></table></li><li><p><strong>按存取方式分类</strong></p><table><colgroup><col style="width: 33%" /><col style="width: 33%" /><col style="width: 33%" /></colgroup><thead><tr class="header"><th>名称</th><th>特性</th><th>用途</th></tr></thead><tbody><tr class="odd"><td>随机存取存储器（RAM）</td><td>CPU 对存储器内容<strong>随机读取</strong>，对任何一个单元<strong>读写时间相同</strong>，使用灵活</td><td>主存、高速缓冲存储器</td></tr><tr class="even"><td>只读存储器（ROM）</td><td>内容<strong>只读不写</strong>，<strong>断电不消失</strong></td><td>BIOS、存入固定子程序、函数发生器、字符发生器、微程序控制器的控制存储器</td></tr><tr class="odd"><td>顺序存取存储器（SAM）</td><td>内容只能按<strong>某种顺序</strong>读取，读写时间与位置有关</td><td>磁带机</td></tr><tr class="even"><td>直接存取存储器（DAM）</td><td>访问时先指向存储器的<strong>某区域</strong>，再<strong>顺序检索</strong>这个区域，比 SAM 快</td><td>磁盘机</td></tr></tbody></table><p>SAM 和 DAM 的存取时间与物理位置有关，又统称<strong>串行访问存储器</strong>。</p></li><li><p><strong>按存储介质分类</strong></p><table><colgroup><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /></colgroup><thead><tr class="header"><th>名称</th><th>原理</th><th>特性</th><th>用途</th></tr></thead><tbody><tr class="odd"><td>磁芯存储器</td><td>使用磁芯剩磁状态表示二进制数</td><td>长期存储，断电不丢失；破坏性读出，需要重写；各方面性能较差</td><td>早期主存</td></tr><tr class="even"><td>半导体存储器</td><td>使用 MOS 型存储器和双极型存储器</td><td>MOS 型存储器集成度高、功耗低、价格便宜、存取慢；双极型存储器相反；半导体 RAM 断电丢失</td><td>替代磁芯存储器主存</td></tr><tr class="odd"><td>磁表面存储器</td><td>在基体上涂覆磁性材料</td><td>容量大、价格低、存取慢</td><td>辅助存储器</td></tr><tr class="even"><td>光存储器</td><td>采用激光技术控制访问</td><td>有只读式、一次写入式、可改写式；容量较大</td><td>辅助存储器</td></tr></tbody></table></li></ol><h3 id="存储系统结构">5.1.2 存储系统结构</h3><p>为了解决存储容量、存取速度和价格之间的矛盾，通常把各种不同存储容量、不同存取速度的存储器按一定的体系结构组织起来，形成一个统一整体的存储系统，形成<strong>多级存储层次</strong>。</p><figure><img src="/image/25-11-26-2-CompOrg-5-mem/1764235985781.webp" alt="1764235985781" /><figcaption aria-hidden="true">1764235985781</figcaption></figure><p>整个系统具有<strong>接近 <span class="math inline">\(M_1\)</span> 的速度</strong>、<strong><span class="math inline">\(M_n\)</span> 的容量</strong>。离 CPU 越远，速度越慢，容量越大，数据常用程度越低。</p><dl><dt><strong>命中率</strong></dt><dd>CPU 逻辑地址能在 <span class="math inline">\(M_1\)</span> 中访问到的概率。</dd></dl><p>设一个两级存储层次结构。 <span class="math inline">\(N_1\)</span> 为访问 <span class="math inline">\(M_1\)</span> 次数，时间 <span class="math inline">\(T_{A1}\)</span>，<span class="math inline">\(N_2\)</span> 为访问 <span class="math inline">\(M_2\)</span> 次数，时间 <span class="math inline">\(T_{A2}\)</span>，则命中率 <span class="math inline">\(H\)</span> 为<br /><span class="math display">\[H = \frac{N_1}{N_1 + N_2}\]</span></p><p>两级存储层次等效访问时间为 <span class="math inline">\(T_A\)</span>，</p><ul><li><p><span class="math inline">\(M_1\)</span> 访问和 <span class="math inline">\(M_2\)</span> 访问同时启动<br /><span class="math display">\[T_A = HT_{A1} + (1 - H)T_{A2}\]</span></p></li><li><p><span class="math inline">\(M_1\)</span> 未命中时 <span class="math inline">\(M_2\)</span> 访问启动<br /><span class="math display">\[T_A = T_{A1} + (1 - H)T_{A2}\]</span></p></li></ul><p>存储层次访问效率<br /><span class="math display">\[e = \frac{T_{A1}}{T_A}\]</span></p><p>由高速缓冲存储器、主存储器、辅助存储器构成的三级存储系统可以分为两个层次，其中高速缓存和主存间称为 <strong>Cache-主存存储层次（Cache 存储系统）</strong>；主存和辅存间称为<strong>主存-辅存存储层次（虚拟存储系统）</strong>。</p><figure><img src="/image/25-11-26-2-CompOrg-5-mem/1764236769824.webp" alt="1764236769824" /><figcaption aria-hidden="true">1764236769824</figcaption></figure><table><thead><tr class="header"><th>存储系统</th><th>速度</th><th>容量</th><th>价格</th></tr></thead><tbody><tr class="odd"><td>Cache 存储系统</td><td>Cache</td><td>主存</td><td>主存</td></tr><tr class="even"><td>虚拟存储系统</td><td>主存</td><td>虚拟地址空间</td><td>辅存</td></tr></tbody></table><h2 id="主存储器的组织">5.2 主存储器的组织</h2><h3 id="主存储器的基本结构">5.2.1 主存储器的基本结构</h3><figure><img src="/image/25-11-26-2-CompOrg-5-mem/1764237123518.webp" alt="1764237123518" /><figcaption aria-hidden="true">1764237123518</figcaption></figure><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th>组成部分</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>存储器</td><td>存放数据与程序</td></tr><tr class="even"><td>地址译码驱动电路</td><td><strong>译码器</strong>将总线输入的地址译为译码输出的有效电平，表示<strong>选中单元</strong>，<strong>驱动器</strong>提供驱动电流进行<strong>读写</strong></td></tr><tr class="odd"><td>I/O 和读写电路</td><td>包括读出放大器、写入电路、读写控制电路，完成<strong>读写操作</strong></td></tr></tbody></table><h3 id="主存储器的存储单元">5.2.2 主存储器的存储单元</h3><p>位是二进制数的最基本单位，也是存储器存储信息的最小单位。</p><p>一个存储单元可能存放一个字，也可能存放一个字节，这是由计算机的结构确定的。</p><p>对于字节编址的计算机，最小寻址单位是<strong>一个字节</strong>，相邻的存储单元地址指向相邻的存储字节；对于字编址的计算机，最小寻址单位是<strong>一个字</strong>，相邻的存储单元地址指向相邻的存储字。所以，<strong>存储单元是 CPU 对主存可访问操作的最小存储单位</strong>。</p><blockquote><p><strong>存储单元数、寻址范围</strong><br />总的来讲，寻址范围从 0 开始，上限为<br /><span class="math display">\[上限 = 存储单元数 - 1 = \frac{总容量}{单元大小} - 1\]</span></p></blockquote><ol type="1"><li><p><strong>大端方案</strong><br />如 IBM 370 机（32 位），主存按<strong>字节编址</strong>，每一个存储字包含 4 个单独编址的存储字节。字地址等于<strong>最高有效字节地址</strong>，字地址总为 4 的整数倍。用地址码的最末两位区分同一字的 4 字节。</p></li><li><p><strong>小端方案</strong><br />如 PDP-11 机（16 位），主存按<strong>字节编址</strong>，每个存储字包含 2 个单独编址的存储字节。字地址等于<strong>最低有效字节地址</strong>，字地址总为 2 的整数倍，用地址码的最末一位区分同一字的两字节。</p><figure><img src="/image/25-11-26-2-CompOrg-5-mem/1766577526402.webp" alt="1766577526402" /><figcaption aria-hidden="true">1766577526402</figcaption></figure></li></ol><h3 id="主存储器的主要技术指标">5.2.3 主存储器的主要技术指标</h3><ol type="1"><li><p><strong>存储容量</strong><br />对于<strong>字节编址</strong>的计算机，以<strong>字节数</strong>表示存储容量；对于<strong>字编址</strong>的计算机，以<b>字数乘字长（一字所含位数）</b>表示存储容量。</p><table><thead><tr class="header"><th>编址方式</th><th>容量</th></tr></thead><tbody><tr class="odd"><td>字编址</td><td><span class="math inline">\(\rm 64 K \times 16\)</span></td></tr><tr class="even"><td>字节编址</td><td><span class="math inline">\(\rm 128 KB\)</span></td></tr></tbody></table></li><li><p><strong>存取速度</strong></p><ul><li><p><strong>存取时间 <span class="math inline">\(T_a\)</span></strong><br />又称<strong>访问时间</strong>或<strong>读写时间</strong>。从<strong>启动一次存储器操作</strong>到<strong>完成该操作所需时间</strong>。<span class="math inline">\(T_a\)</span> 越小，存取速度越快。</p></li><li><p><strong>存取周期 <span class="math inline">\(T_m\)</span></strong><br />又称<strong>读写周期</strong>、<strong>访问周期</strong>。主存进行一次<strong>完整读写操作</strong>的全部时间，即<strong>连续两次访问存储器操作之间</strong>所需最短时间。一般 <span class="math inline">\(T_m &gt; T_a\)</span>。</p></li><li><p><strong>主存带宽 <span class="math inline">\(B_m\)</span></strong><br />又称<strong>数据传输率</strong>。每秒从主存<strong>进出</strong>信息的最大数量。主存带宽与储存等效工作频率与主存位宽有关系<br /><span class="math display">\[B_m(\rm{B/s}) = 主存等效工作频率(\rm{/s}) \times 主存位宽(\rm{/B}) \div 8\]</span></p><p>目前，主存速度还跟不上 CPU 速度。为提高 <span class="math inline">\(B_m\)</span>，可以</p><ul><li>缩短存取周期</li><li>增加存储字长</li><li>增加存储体</li></ul></li></ul></li><li><p><strong>可靠性</strong><br />规定时间内，存储器<strong>无故障读写</strong>的概率。用<strong>平均故障间隔时间</strong>（Mean Time Between Failures，MTBF）衡量。MTBF 越长，说明可靠性越高。</p></li><li><p><strong>功耗</strong><br />反映存储器耗电多少和发热情况。通常希望功耗小。大多数半导体存储器工作功耗<strong>远小于</strong>维持功耗。</p></li></ol><h3 id="数据在主存中的存放">5.2.4 数据在主存中的存放</h3><p>目前大多数存储器采用<strong>字节编址</strong>。假设读写数据的长度有字节（8 位）、半字（16 位）、单字（32 位）和双字（64 位）。</p><blockquote><p>数据字长（32 位）不等于存储字长（64 位）。</p></blockquote><p>如图所示有三种数据存储方法。</p><figure><img src="/image/25-11-26-2-CompOrg-5-mem/1766401740390.webp" alt="1766401740390" /><figcaption aria-hidden="true">1766401740390</figcaption></figure><ol type="1"><li><p><strong>不浪费</strong>：无论何种长度的数据，均为一个接一个存放。这样省空间但是工作速度慢、读写控制麻烦。</p></li><li><p><strong>过于浪费</strong>：无论何种长度数据，都从第一个存储字处开始存放。这样读写控制虽然简单，但有一半空间被浪费。</p></li><li><p><strong>边界对齐</strong>：对于不同长度的数据存放有如下要求</p><table><thead><tr class="header"><th>长度</th><th>地址末几位数字</th></tr></thead><tbody><tr class="odd"><td>8 字节（双字）</td><td>000（8 的倍数）</td></tr><tr class="even"><td>4 字节（单字）</td><td>00（4 的倍数）</td></tr><tr class="odd"><td>2 字节（半字）</td><td>0（2 的倍数）</td></tr></tbody></table><p>这样既能节省部分资源，又能在一个存取周期内完成访问。</p><p><a href="/2025/11/05/25-11-3-8-OpSys-5-phy-mem-con/">【操作系统原理】 Lecture 5 物理内存管理：连续内存分配</a></p></li></ol><h2 id="半导体存储器和只读存储器">5.3 半导体存储器和只读存储器</h2><h3 id="ram-记忆单元电路">5.3.1 RAM 记忆单元电路</h3><p>通常把存放<strong>一个二进制位</strong>的物理器件称为<strong>记忆单元</strong>，通常由 MOS 制成。</p><ol type="1"><li><p><strong>6 管 SRAM 记忆单元电路</strong><br />在该记忆单元未被选中或读出时电路处于双稳态触发器工作状态，电源不断供电以存储信息。一旦断电，信息丢失，称为<strong>易失性</strong>。</p><p>SRAM 存取快，但集成度低、功耗大。用于<strong>高速缓冲器</strong>和<strong>小容量主存系统</strong>。</p></li><li><p><strong>4 管 DRAM 记忆单元电路</strong><br />DRAM 记忆单元的刷新过程是对栅极电容补充电荷，也是一种读出过程，但目的不是未来读出信息，称为“假读”。</p><p>DRAM 集成度高、功耗小、存取慢，用于<strong>大容量主存系统</strong>。</p></li><li><p><strong>单管 DRAM 记忆单元电路</strong><br />同样需要刷新操作，相比 4 管 DRAM 记忆单元电路功耗更小、集成度更高。</p></li></ol><h3 id="动态-ram-的刷新">5.3.2 动态 RAM 的刷新</h3><ol type="1"><li><p><strong>刷新间隔</strong><br />主要由<strong>栅极电容电荷泄放速度</strong>决定。在规定时间内（如 2 ms），将全部存储体刷新一遍。</p><blockquote><p>刷新与<strong>重写</strong>完全不同。</p><table><thead><tr class="header"><th>属性</th><th>重写</th><th>刷新</th></tr></thead><tbody><tr class="odd"><td>时机</td><td>随机，破坏性读出后</td><td>定时，为长期未访问记忆单元补充电荷</td></tr><tr class="even"><td>单位</td><td>存储单元</td><td>存储矩阵的一行</td></tr></tbody></table></blockquote></li><li><p><strong>刷新方式</strong></p><ul><li><p><strong>集中刷新方式</strong><br />在允许的最大时间间隔内，按存储芯片容量大小安排几个刷新周期，期间<strong>停止读写操作</strong>。</p><p><span class="math display">\[刷新时间 = 存储矩阵行数 \times 刷新周期\]</span></p><figure><img src="/image/25-11-26-2-CompOrg-5-mem/1766404036069.webp" alt="1766404036069" /><figcaption aria-hidden="true">1766404036069</figcaption></figure><p>集中刷新停止读写期间被称为“死区”，存储容量越大，死区越长。死时间率为<br /><span class="math display">\[死时间率 = \frac{刷新时间}{最大刷新间隔}\]</span></p></li><li><p><strong>分散刷新方式</strong><br />把刷新操作<strong>分散到每个存取周期</strong>。存取周期前一半用于读写或保持，后一半用于刷新，一周期刷新一行。<br /><img src="/image/25-11-26-2-CompOrg-5-mem/1766404263492.webp" alt="1766404263492" /></p><p>这样没有死区，但是加长系统存取周期，降低整机速度；刷新过于频繁，当存储容量较小时，没有充分利用允许的最大刷新间隔。</p></li><li><p><strong>异步刷新方式</strong><br />前两种方法的结合，把刷新操作平均分配到整个最大刷新间隔时间内进行。<br /><span class="math display">\[相邻两行刷新间隔 = \frac{最大刷新间隔时间}{行数}\]</span></p><p><img src="/image/25-11-26-2-CompOrg-5-mem/1766404574933.webp" alt="1766404574933" /><br />对于 32 × 32 矩阵，2 ms 每刷新 32 行，一个刷新周期为 62.5 μs，刷新时封锁读写。</p><p>这样虽然也有死区，但是小得多，且减少刷新次数。</p></li></ul><p>为消除死区，还可采用<strong>不定期刷新</strong>，即把刷新操作安排在 CPU 不访问存储器的时间里。这样既无死区，又不会降低存储速度。但控制困难。</p></li><li><p><strong>刷新控制</strong><br />刷新控制电路的任务时解决刷新任务与 CPU 访问间的矛盾。通常优先进行刷新操作。</p><ul><li>刷新控制无论是由芯片外部完成还是内部完成，都对 CPU <strong>透明</strong>。</li><li>刷新操作<strong>按行进行</strong>，<strong>不需列地址</strong>。</li><li>刷新操作与读出操作不同，刷新<strong>不需要片选信号</strong>。</li><li>考虑刷新问题时应从单个芯片存储容量着手，不是整个存储器。</li></ul></li></ol><h3 id="ram-芯片分析">5.3.3 RAM 芯片分析</h3><ol type="1"><li><p><strong>RAM 芯片</strong><br />各种 RAM 芯片的外引脚主要有</p><table><thead><tr class="header"><th>名称</th><th>符号</th></tr></thead><tbody><tr class="odd"><td>地址线</td><td><span class="math inline">\(A_i\)</span></td></tr><tr class="even"><td>数据线</td><td><span class="math inline">\(D_i\)</span></td></tr><tr class="odd"><td>片选线</td><td><span class="math inline">\(\overline{CE}\)</span> 或 <span class="math inline">\(\overline{CS}\)</span></td></tr><tr class="even"><td>读写控制线</td><td><span class="math inline">\(\overline{WE}\)</span> 或 <span class="math inline">\(\overline{OE} / \overline{WE}\)</span></td></tr><tr class="odd"><td>工作电源</td><td><span class="math inline">\(V_{CC}\)</span>，+5 V</td></tr><tr class="even"><td>地线</td><td>GND</td></tr></tbody></table></li><li><p><strong>地址译码方式</strong></p><ul><li><p><strong>单译码方式</strong><br />又称<strong>字选法</strong>，适用于<strong>字结构</strong>存储器。结构简单，但是外围电路多，成本高。</p></li><li><p><strong>双译码方式</strong><br />又称<strong>重合法</strong>，存储芯片可以是位结构或字段结构的。与单译码方式相比，减少了选择线和驱动器数目。存储容量越大，两种方法的差异越明显。</p></li></ul></li><li><p><strong>RAM 的读写时序</strong></p><ul><li><p><strong>SRAM 读写时序</strong><br /><img src="/image/25-11-26-2-CompOrg-5-mem/1766406704372.webp" alt="1766406704372" /></p></li><li><p><strong>DRAM 读写时序</strong><br /><img src="/image/25-11-26-2-CompOrg-5-mem/1766406839548.webp" alt="1766406839548" /></p></li></ul></li></ol><h3 id="半导体只读存储器">5.3.4 半导体只读存储器</h3><p>ROM 的优点具有<strong>非易失性</strong>，断电后信息不丢失。</p><ol type="1"><li><p><strong>ROM 的类型</strong></p><ul><li><p><strong>掩膜式 ROM（MROM）</strong><br />内容由制造厂在生产过程种写入，无法改变。</p><p>MROM 可靠性高，集成度高，价格便宜；但灵活性差。</p></li><li><p><strong>一次性可编程 ROM（PROM）</strong><br />允许用户利用专门的这杯写入自己的程序，写入后内容不可变。双极型 PROM 有熔丝烧断型和 PN 结击穿型，写入都是不可逆的。</p></li><li><p><strong>可擦除可编程 ROM（EPROM）</strong><br />允许用户利用专门的这杯写入自己的程序，还可<strong>多次写入</strong>。</p><ul><li>UVEPROM：用紫外线照射透明窗口，为整芯片擦除。还需不透明黑纸防止阳光干扰。</li><li>EEPROM：采用电气方法擦除，在联机条件下既可以字擦除，也可以数据块擦除。</li></ul><p>EPROM 不能取代 RAM。</p><ul><li>EPROM 编程次数有限。</li><li>写入时间较长。</li></ul></li><li><p><strong>闪速存储器（Flash Memory）</strong><br />简称闪存。可以在操作种被多次读写擦除，兼备 EEPROM 与 RAM 的优点。</p><table><thead><tr class="header"><th>种类</th><th>特性</th></tr></thead><tbody><tr class="odd"><td>NOR 型</td><td>擦写时间长，允许随机存取任何区域</td></tr><tr class="even"><td>NAND 型</td><td>擦鞋时间短，以区块为单位读取</td></tr></tbody></table><p>大多数微型计算机采用<strong>闪存</strong>存储 BIOS 程序。</p></li></ul></li><li><p><strong>ROM 芯片</strong><br />ROM 中使用最多的是 EPROM。引脚主要有</p><table><thead><tr class="header"><th>名称</th><th>符号</th></tr></thead><tbody><tr class="odd"><td>地址线</td><td><span class="math inline">\(A_i\)</span></td></tr><tr class="even"><td>数据线</td><td><span class="math inline">\(D_i\)</span></td></tr><tr class="odd"><td>片选线</td><td><span class="math inline">\(\overline{CE}\)</span> 或 <span class="math inline">\(\overline{CS}\)</span></td></tr><tr class="even"><td>编程线</td><td><span class="math inline">\(\overline{PGM}\)</span></td></tr><tr class="odd"><td>工作电源、编程电源</td><td><span class="math inline">\(V_{CC}\)</span>、<span class="math inline">\(V_{PP}\)</span></td></tr><tr class="even"><td>地线</td><td>GND</td></tr></tbody></table></li></ol><h3 id="半导体存储器的封装">5.3.5 半导体存储器的封装</h3><ol type="1"><li><p><strong>DIP 存储芯片</strong><br />过去，一般存储芯片都是<strong>双列直插封装</strong>（Dual In-line Package，DIP）的。这种内存芯片必须焊接在主板上才能使用，一旦某一块芯片坏了，必须焊下来才能更换。</p></li><li><p><strong>内存条</strong></p><ul><li>单列直插存储模块（Single In-line Memory Module，SIMM）</li><li>双列直插存储模块（Dual In-line Memory Module，DIMM）</li><li>Rambus 直插存储模块（Rambus In-line Memory Module，RIMM）</li></ul><p>大多数主板不允许用户将不同容量的内存条混用。</p></li></ol><h2 id="主存储器的连接与控制">5.4 主存储器的连接与控制</h2><h3 id="主存容量的扩展">5.4.1 主存容量的扩展</h3><p>在扩展容量之前，通过要求容量与单个存储芯片容量计算芯片数<br /><span class="math display">\[总片数 = \frac{总容量}{容量/片} \\\\\frac{8 \rm{K} \times 8}{1 \rm{K} \times 4} = 16\]</span></p><ol type="1"><li><p><strong>位扩展</strong><br />在<strong>位数</strong>方向上扩展（加大<strong>字长</strong>）。将各存储芯片的<strong>地址线</strong>、<strong>片选线</strong>、<strong>读写线</strong>相应<strong>并联</strong>，将<strong>数据线</strong>单独列出。<br /><img src="/image/25-11-26-2-CompOrg-5-mem/1766408832344.webp" alt="1766408832344" /></p></li><li><p><strong>字扩展</strong><br />在<strong>字数</strong>方向上扩展。将各存储芯片的<strong>地址线</strong>、<strong>数据线</strong>、<strong>读写线</strong>相应<strong>并联</strong>，由<strong>片选信号</strong>区分各芯片。<br /><img src="/image/25-11-26-2-CompOrg-5-mem/1766409006906.webp" alt="1766409006906" /></p></li><li><p><strong>字和位同时扩展</strong><br /><img src="/image/25-11-26-2-CompOrg-5-mem/1766409047770.webp" alt="1766409047770" /></p></li></ol><h3 id="存储芯片的地址分配和片选">5.4.2 存储芯片的地址分配和片选</h3><p>CPU 要实现对存储单元的访问，首先要选择存储芯片，即进行<strong>片选</strong>；然后再从选中的芯片中依地址码选择出相应的存储单元，以进行数据的存取，这称为<strong>字选</strong>。</p><ol type="1"><li><p><strong>线选法</strong><br />线选法就是用除片内寻址外的高位地址线直接（或经反相器）分别接至各个存储芯片的片选端，当某地址线信息为 0 时，就选中与之对应的存储芯片。</p><blockquote><p>每次寻址时只能有一位有效，每次只选中一个芯片。</p></blockquote><p>线选法无需译码器，线路简单，适用于芯片较少的场合。线选法不能重复利用存储器空间，把地址空间<strong>相互隔离</strong>，不利于编程。</p></li><li><p><strong>全译码法</strong><br />全译码法将除片内寻址外的全部高位地址线都作为地址译码器的输入，译码器的输出作为各芯片的片选信号，接到片选端。</p></li><li><p><strong>部分译码法</strong><br />所谓部分译码就是用除片内寻址外的高位地址的一部分来译码产生片选信号。令未用到的高位地址全为 0，这样确定的存储器地址称为基本地址。部分译码法较全译码法简单，但存在<strong>地址重叠区</strong>。</p></li></ol><h3 id="主存储器和-cpu-的连接">5.4.3 主存储器和 CPU 的连接</h3><ol type="1"><li><p><strong>主存和 CPU 的硬连接</strong><br /><img src="/image/25-11-26-2-CompOrg-5-mem/1766410161444.webp" alt="1766410161444" /></p><p>主存与 CPU 有 3 组硬连线：<strong>地址总线 （AB）</strong>、<strong>数据总线 （DB）</strong>、<strong>控制总线 （CB）</strong>。此时，把主存看作一个黑盒子，<b>存储器地址寄存器（MAR）</b>和<b>存储器数据寄存器（MDR）</b>是主存和 CPU 之间的接口。MAR 可以接受来自程序计数器（PC）的指令地址或来自地址形成部件的操作数地址，以确定要访问的单元。MDR 是向主存写入数据或从主存读出数据的缓冲部件。MAR 和 MDR 从功能上看属于主存，但在小型计算机、微型计算机中常放在 CPU 内。</p></li><li><p><strong>CPU 对主存的基本操作</strong></p><ul><li><p><strong>读</strong><br /><img src="/image/25-11-26-2-CompOrg-5-mem/1766410550360.webp" alt="1766410550360" /></p></li><li><p><strong>写</strong><br /><img src="/image/25-11-26-2-CompOrg-5-mem/1766410571592.webp" alt="1766410571592" /></p></li></ul></li></ol><h3 id="主存的校验">5.4.4 主存的校验</h3><ol type="1"><li><p><strong>主存的奇偶校验</strong><br />每个存储单元存储 8 位数据、1 位校验位。</p></li><li><p><strong>错误验证与校正（ECC）</strong><br />ECC 可以检测错误、在不打扰计算机工作的情况下纠正错误。</p></li></ol><h3 id="pc-系列微型计算机的存储接口">5.4.5 PC 系列微型计算机的存储接口</h3><ol type="1"><li><p><strong>8 位存储接口</strong></p></li><li><p><strong>16 位存储接口</strong></p></li><li><p><strong>32 位存储接口</strong></p></li><li><p><strong>64 位存储接口</strong></p></li></ol><h2 id="提高主存读写速度的技术">5.5 提高主存读写速度的技术</h2><h3 id="主存与-cpu-速度的匹配">5.5.1 主存与 CPU 速度的匹配</h3><h3 id="fpm-dram">5.5.2 FPM DRAM</h3><p>快速页模式随机存储器（Fast Page Mode DRAM）。通过保持行地址不变而只改变列地址，可以对给定行的所有数据进行更快的访问。</p><h3 id="edo-dram">5.5.3 EDO DRAM</h3><p>扩展数据输出 DRAM（Extended Data Output DRAM）。EDO 不必等待当前的读写周期完成即可启动下一个读写周期，即可以在输出一个数据的过程中准备下一个数据的输出。</p><h3 id="sdram">5.5.4 SDRAM</h3><p>同步动态随机存储器（Synchronous DRAM，SDRAM）是一种与主存总线运行同步的<br />DRAM。 SDRAM 在同步脉冲的控制下工作，取消了主存等待时间，减少了数据传送的延迟<br />时间，因而加快了系统速度。</p><h3 id="ddr-sdram">5.5.5 DDR SDRAM</h3><p>双数据传输率同步动态随机存储器（Double Data Rate SDRAM）。DDR SDRAM不仅能在时钟脉冲的上升沿读出数据而且还能在下降沿读出数据，不需要提高时钟频率就能加倍提高 SDRAM 的速度。</p><h3 id="ddr2ddr3ddr4-和-ddr5-sdram">5.5.6 DDR2、DDR3、DDR4 和 DDR5 SDRAM</h3><ol type="1"><li><p><strong>DDR2 SDRAM</strong><br />DDR2 SDRAIM 拥有两倍于上一代 DDR SDRAM 的预读取能力（即 4 位数据读预取）。</p></li><li><p><strong>DDR3 SDRAM</strong><br />DDR3 的预取设计位数提升至 8 位。</p></li><li><p><strong>DDR4 SDRAM</strong><br />DDR4 推出了 bank group 设计。每个 bank group 可独立读写数据，使得内部的数据吞吐率大大提升。</p></li><li><p><strong>DDR5 SDRAM</strong><br />DDR5 的变化不仅是频率的提高，因为充许加入内部 ECC 来制造16Gb、32Gb颗粒，单条容量也会大大提升。</p></li></ol><h3 id="rambus-dram">5.5.7 Rambus DRAM</h3><p>美国 Rambus 公司研发的 RDRAM 在内部结构上进行了重新设计，并采用了新的信号接口技术，其对外接口也不同于以前的 DRAM。</p><h3 id="多通道内存技术">5.5.8 多通道内存技术</h3><ol type="1"><li><p><strong>双通道内存技术</strong><br />在北桥芯片组里制作两个内存控制器，这两个内存控制器是可以相互独立工作的。在这两个内存通道上，CPU 可以分别寻址、读取数据，从而可以使内存的带宽增加一倍，理论上数据存取速度也相应增加一倍。</p></li><li><p><strong>三通道内存技术</strong><br />对于支持三通道内存的主板，无论是 4 根内存插槽还是 6 根内存插槽的产品，要想实现三通道模式，只要将同色的三根内存插槽插上内存条即可，系统便会自动识别并进入三通道模式。但是，如果插上非 3 条或者非 6 条的内存，系统会自动进入单通道模式。</p></li></ol><h2 id="多体交叉存储技术">5.6 多体交叉存储技术</h2><h3 id="并行访问存储器">5.6.1 并行访问存储器</h3><p>在高速的计算机中，普遍采用并行主存系统，即在一个存取周期内可以并行读出多个字，依靠整体信息吞吐率的提高，以解决 CPU 与主存之间的速度匹配问题。</p><h3 id="交叉访问存储器">5.6.2 交叉访问存储器</h3><p>交叉访问存储器中有多个容量相同的存储模块（存储体），而且各存储模块具有各自独立的地址寄存器、读写电路和数据寄存器，这就是多体系统。各个存储体能并行工作，又能交叉工作。</p><blockquote><p>交叉访问存储器要求存储体的个数是 2 的整数幂，即必须是 2、4、8、16 个，而且任一分体出现故障都将影响整个地址空间的所有区域。</p></blockquote><figure><img src="/image/25-11-26-2-CompOrg-5-mem/1766580702375.webp" alt="1766580702375" /><figcaption aria-hidden="true">1766580702375</figcaption></figure><h2 id="高速缓冲存储器">5.7 高速缓冲存储器</h2><h3 id="高速缓存工作原理">5.7.1 高速缓存工作原理</h3><ol type="1"><li><p><strong>程序局部性原理</strong></p><ul><li><strong>时间局部性</strong>：如果一个存储单元被访问，则可能该单元会<strong>很快被再次访问</strong>。这是因为程序存在着循环。</li><li><strong>空间局部性</strong>：如果一个存储单元被访问，则<strong>该单元邻近的单元</strong>也可能很快被访问。</li></ul></li><li><p><strong>Cache 基本结构</strong><br /><img src="/image/25-11-26-2-CompOrg-5-mem/1766558526634.webp" alt="1766558526634" /></p><p>Cache 保存主存中最急需的若干块的副本。用主存地址的块号字段访问 <strong>Cache 标记</strong>，并将取出的标记和主存地址的标记字段相比较，若相等，说明访问 Cache 有效，称 Cache <strong>命中</strong>；若不相等，说明访问 Cache 无效，称 Cache <strong>不命中</strong>或失效。</p><blockquote><p><strong>数量关系</strong><br /><span class="math display">\[主存地址数 = 主存总字数 = 主存块数 \times 块大小 \\\\主存地址位数 = 主存地址标记位数 + {\rm Cache \\ 地址位数} = 主存地址标记位数 + 块号位数 + 块内地址位数\]</span></p></blockquote></li></ol><h3 id="cache-的读写操作">5.7.2 Cache 的读写操作</h3><ol type="1"><li><strong>Cache 的读操作</strong><ul><li>当 CPU 发出读请求时，如果 Cache 命中，就直接对 Cache 进行读操作，与主存无关</li><li>如果 Cache 不命中 ，则仍需访问主存，并把该块信息一次从主存调入 Cache 内。</li><li>若此时 Cache 已满，则必须根据某种替换算法，用这个块替换掉 Cache 中原来的某块信息。</li></ul></li><li><strong>Cache 的写操作</strong><br />如果 Cache 命中，需要进行一定的写处理，处理的方法有：<strong>写直达法</strong>和<strong>写回法</strong>，详见 5.7.5 节。如果写 Cache 不命中，就直接把信息写入主存，并有两种处理方法：<ul><li>不按写分配法，即只把所要写的信息写入主存。</li><li>按写分配法，即在把所要写的信息写入主存后<strong>还把这个块从主存中读入 Cache</strong>。</li></ul></li></ol><h3 id="地址映像">5.7.3 地址映像</h3><p>把主存地址空间映像到 Cache 地址空间。</p><ol type="1"><li><p><strong>全相联映像</strong><br />让主存中任何一个块均可映像装入到 Cache 中任何一个块上。这样 Cache 冲突概率最低、空间利用率最高；但变换速度慢、成本高、实现困难。</p></li><li><p><strong>直接映像</strong><br />主存中的每一块只能被放置到 Cache 中<strong>唯一的一个指定位置</strong>。若原来有内容，则发生<strong>冲突</strong>，无条件替换掉原来的块。这样做简单、成本低、易实现；但冲突概率高空间利用率低。<br /><span class="math display">\[K = I \bmod 2^c\]</span></p><p><span class="math inline">\(K\)</span> 为 Cache 块号；<span class="math inline">\(I\)</span> 为主存块号；<span class="math inline">\(2^c\)</span> 为 Cache 块数。</p></li><li><p><strong><span class="math inline">\(n\)</span> 路组相联映像</strong><br />将 Cache 空间分为 <span class="math inline">\(n\)</span> 个大小相同的组，让主存中的一块直接映像入 Cache 对应组的任何一块上，<strong>组间采取直接映像，组内采取全相联映像。</strong><br /><span class="math display">\[J = I \bmod Q\]</span></p><p><span class="math inline">\(J\)</span> 为 Cache 的组号；<span class="math inline">\(I\)</span> 为主存的块号；<span class="math inline">\(Q\)</span> 为 Cache 的组数。</p></li></ol><figure><img src="/image/25-11-26-2-CompOrg-5-mem/1766559456628.webp" alt="1766559456628" /><figcaption aria-hidden="true">1766559456628</figcaption></figure><h3 id="替换算法">5.7.4 替换算法</h3><p>在采用全相联映像和组相联映像方式从主存向 Cache 传送一个新块，而 Cache 中的空间<strong>已被占满</strong>时，就需要把原来存储的一块替换掉。</p><ol type="1"><li><p><strong>随机算法</strong><br />简单根据一个随机数选择一个块替换。</p></li><li><p><strong>先进先出（FIFO）算法</strong><br />按调入 Cache 的先后决定淘汰的顺序，即在需要更新时，将<strong>最先进入 Cache 的块</strong>作为被替换的块。</p></li><li><p><strong>近期最少使用（LRU）算法</strong><br />把 CPU <strong>近期最少使用的块</strong>作为被替换的块。</p></li></ol><h3 id="更新策略">5.7.5 更新策略</h3><ul><li><p><strong>写直达法</strong><br />CPU 在执行写操作时，必须<strong>把数据同时写入 Cache 和主存</strong>。当某一块需要替换时，不必写回主存，<strong>直接覆盖</strong>。</p></li><li><p><strong>写回法</strong><br />CPU 在执行写操作时，被写数据<strong>只写入 Cache，不写入主存</strong>。仅当需要替换时，才把<strong>已经修改过的 Cache 块</strong>写回到主存。</p><p>采用此策略，每一个 Cache 块有一个标志位，称为<strong>脏位</strong>。当脏位为 1 时，标明此块已被修改过，欲覆盖此块需先写回主存；当脏位为 0 时，标明此块未被修改过，可以直接覆盖。</p></li></ul><h3 id="微机中-cache-的实现">5.7.6 微机中 Cache 的实现</h3><ol type="1"><li><strong>单一缓存与多级缓存</strong><ul><li><strong>单一缓存</strong>：CPU 与主存之间只有一个 Cache。</li><li><strong>多级缓存</strong>：CPU 访存时首先查找 L1 Cache，如果 L1 Cache 不命中，则访问 L2 Cache……直到所有级别的 Cache 都不命中时，才访问主存。</li></ul></li><li><strong>统一缓存与分开缓存</strong><br />统一缓存是指指令和数据都存放在同一个 Cache 中。而分开缓存是指指令和数据分别存放在两个 Cache 中，一个称为<strong>指令 Cache</strong>，另一个称为<strong>数据 Cache</strong>。</li></ol><h2 id="虚拟存储器">5.8 虚拟存储器</h2><h3 id="虚拟存储器的基本概念">5.8.1 虚拟存储器的基本概念</h3><p>虚拟存储器将主存或辅存的地址空间<strong>统一编址</strong>，形成一个庞大的存储空间。在这个大空间里，用户可以<strong>自由编程</strong>，完全不必考虑程序在主存是否装得下以及这些程序将来在主存中的实际存放位置。</p><p>用户编程的地址称为<strong>虚地址</strong>或<strong>逻辑地址</strong>，实际的<strong>主存单元地址</strong>称为<strong>实地址</strong>或<strong>物理地址</strong>。显然，虚地址要比实地址大得多。</p><h3 id="页式虚拟存储器">5.8.2 页式虚拟存储器</h3><p>主存空间和虚存空间都划分成若干个<strong>大小相等</strong>的页。</p><figure><img src="/image/25-11-26-2-CompOrg-5-mem/1766560262795.webp" alt="1766560262795" /><figcaption aria-hidden="true">1766560262795</figcaption></figure><h3 id="段式虚拟存储器">5.8.3 段式虚拟存储器</h3><p>段式虚拟存储器中的段是按照程序的逻辑结构划分的，各个段的长度因程序而异。为<br />了把程序虚地址变换成主存实地址，需要一个段表。段表中每一行记录了某个段对应的若<br />十信息，包括段号、装入位、段起点和段长等。段表一般驻留在主存中。</p><figure><img src="/image/25-11-26-2-CompOrg-5-mem/1766560396463.webp" alt="1766560396463" /><figcaption aria-hidden="true">1766560396463</figcaption></figure><h3 id="段页式虚拟存储器">5.8.4 段页式虚拟存储器</h3><p>将程序按其逻辑结构分段，每段再划分为若干大小相等的页；主存空间也划分为若干同样大小的页。</p><h3 id="快表与慢表">5.8.5 快表与慢表</h3><p>在一段时间内，对页表的访向只是局限在少数几个存储器字内。为了将访向页表的时间降低到最低限度，许多计算机将页表分为快表和慢表两种。将当前最常用的页表信息存放在一个小容量的高速存储器中，称为“快表”（TLB），当快表中查不到时，再从存放在主存中的页表中查找实页号。与快表相对应，存放在主存中的页表称为“慢表”。快表只是慢表的一个副本，而且只存放了慢表中很少的一部分。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【COMPSCI 220】 Lecture 11 Graphs: A Brief Recap</title>
      <link href="/2025/12/22/25-11-5-15-COMPSCI220-11-graph-intro/"/>
      <url>/2025/12/22/25-11-5-15-COMPSCI220-11-graph-intro/</url>
      
        <content type="html"><![CDATA[<h2 id="graphs">Graphs</h2><ul><li>A <strong>graph</strong> is …</li><li>A <strong>directed graph</strong> (or simply called a <strong>digraph</strong>) is …</li></ul><h2 id="variants-of-graphs">Variants of Graphs</h2><ul><li>Multigraph.</li><li>Weighted (di)graph.</li></ul><h2 id="terminology">Terminology</h2><ol type="1"><li><p><strong>For undirected graph</strong></p><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th>Terminology</th><th>Definition</th></tr></thead><tbody><tr class="odd"><td><em>order</em> of a graph</td><td>The number of <strong>nodes</strong> in <span class="math inline">\(G\)</span>, <span class="math inline">\(|V|\)</span>.</td></tr><tr class="even"><td><em>adjacent</em>, <em>neighbours</em></td><td>If <span class="math inline">\((u, v) \in E\)</span>, then <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span> are adjacent or neighbours.</td></tr><tr class="odd"><td><em>endpoints</em> of an edge</td><td>If <span class="math inline">\((u, v) \in E\)</span>, then <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span> are endpoints of edge <span class="math inline">\((u, v)\)</span>.</td></tr><tr class="even"><td><em>degree</em> of a vertex</td><td>The number of its adjacent vertices.</td></tr><tr class="odd"><td><em>walk</em></td><td>A sequence of vertices where each consecutive pair of vertices are joined by an edge.</td></tr><tr class="even"><td><em>path</em></td><td>A walk where <strong>no vertex is repeated</strong>.</td></tr></tbody></table><blockquote><p>Customarily, we use <span class="math inline">\(n = |V|\)</span> and <span class="math inline">\(m = |E|\)</span>.</p></blockquote></li><li><p><strong>For directed graph</strong></p><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th>Terminology</th><th>Definition</th></tr></thead><tbody><tr class="odd"><td><em>in/out-degree</em> of a node</td><td>The number of incoming/outgoing neighbours of the node.</td></tr><tr class="even"><td><em>walk</em>(<em>path</em>)</td><td>A sequence of nodes where each consecutive pair of nodes are connected by a directed edge(which no node is repeated).</td></tr></tbody></table></li><li><p><strong>Special Types of Graphs</strong></p><table><colgroup><col style="width: 33%" /><col style="width: 33%" /><col style="width: 33%" /></colgroup><thead><tr class="header"><th>Type</th><th>Symbol</th><th>Definition</th></tr></thead><tbody><tr class="odd"><td>Complete graphs</td><td><span class="math inline">\(K_n\)</span></td><td><span class="math inline">\(G = (V, E)\)</span>, <span class="math inline">\((v_i, v_j) \in E\)</span> as long as <span class="math inline">\(v_i, v_j \in V, i \neq j\)</span></td></tr><tr class="even"><td>Path graphs</td><td><span class="math inline">\(P_n\)</span></td><td><span class="math inline">\(G = (V, E)\)</span>, <span class="math inline">\((v_i, v_{i + 1}) \in E\)</span> where <span class="math inline">\(i = 1, \cdots, n - 1\)</span></td></tr><tr class="odd"><td>Cycle graphs</td><td><span class="math inline">\(C_n\)</span></td><td><span class="math inline">\(G = (V, E)\)</span>, <span class="math inline">\(V = \bigcup_{i = 1}^n v_i\)</span>, <span class="math inline">\(E = \bigcup_{i = 1}^{n - 1}(v_i, v_{i + 1}) \cup (v_n, v_1)\)</span></td></tr><tr class="even"><td>Wheel graphs</td><td><span class="math inline">\(W_n\)</span></td><td><span class="math inline">\(G = (V, E)\)</span>, <span class="math inline">\(V = u \cup \bigcup_{i = 1}^n v_i\)</span>, <span class="math inline">\(E = \bigcup_{i = 1}^{n - 1}(v_i, v_{i + 1}) \cup (v_n, v_1) \cup \bigcup_{i = 1}^{n}(u, v_n)\)</span></td></tr></tbody></table></li></ol><h2 id="modeling-with-graphs">Modeling with Graphs</h2><h3 id="map-coloring">Map Coloring</h3><p>You are a cartographer charged with designing a map of a continent. You should fill regions using various colours, but want to use as few colours as possible, while giving different colours to neighbouring countries. How can you colour all the regions?</p><h3 id="exam-scheduling">Exam Scheduling</h3><p>A university needs to schedule exams at the end of the semester so that if a student is enrolled in two courses, these courses must get different examination periods. How can this be done?</p><h3 id="dining-mathematicians">Dining Mathematicians</h3><p>Two mathematicians are working on different problems. Sometimes they get hungry and need to eat. However, there is only one (very large) bowl of noodles and only one person can eat at a time. They decide to share a flag. When the flag is raised, one person is eating, and the other has to wait.</p><h3 id="transition-diagrams">Transition Diagrams</h3><p>A transition diagram is a digraph that represents states of a system and transitions between states.</p><h2 id="graph-as-a-data-structure">Graph as a Data Structure</h2><h3 id="adjacency-matrix">Adjacency Matrix</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; adjMtx</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  | 1 2 3 4 5</span></span><br><span class="line"><span class="comment">-------------</span></span><br><span class="line"><span class="comment">1 | 0 1 0 0 1</span></span><br><span class="line"><span class="comment">2 | 1 0 1 1 1</span></span><br><span class="line"><span class="comment">3 | 0 1 1 0 1</span></span><br><span class="line"><span class="comment">4 | 0 0 0 1 0</span></span><br><span class="line"><span class="comment">5 | 1 1 0 1 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>The adjacency matrix of <span class="math inline">\(G\)</span> is the <span class="math inline">\(n \times n\)</span> boolean matrix (encoded using 0, 1) such that <span class="math inline">\((i, j) \in E\)</span> if and only if the entry <span class="math inline">\((i, j)\)</span> is 1.</p><p>Size of representation: <span class="math inline">\(O(n^2)\)</span>.</p><h3 id="adjacency-list">Adjacency List</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; adjLst</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">1 | 2 5 </span></span><br><span class="line"><span class="comment">2 | 1 3 4 5</span></span><br><span class="line"><span class="comment">3 | 2 3 5</span></span><br><span class="line"><span class="comment">4 | 4</span></span><br><span class="line"><span class="comment">5 | 1 2 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>The adjacency list of a digraph <span class="math inline">\(G\)</span> is a list of <span class="math inline">\(n\)</span> lists, <span class="math inline">\(L_0, L_1, \cdots, L_{n − 1}\)</span>, where the <span class="math inline">\(i\)</span>-th list <span class="math inline">\(L_i\)</span> contains all the <strong>out-neighbors</strong> of node <span class="math inline">\(i\)</span>.</p><p>Size of representation: <span class="math inline">\(O(n + m)\)</span>.</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> COMPSCI 220 Algorithms and Data Structures </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 奥克兰大学—西南大学合作课程 </tag>
            
            <tag> 外文 </tag>
            
            <tag> 算法分析与设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【COMPSCI 220】 Lecture 10 Quick Sort</title>
      <link href="/2025/12/22/25-11-3-3-COMPSCI220-10-quicksort/"/>
      <url>/2025/12/22/25-11-3-3-COMPSCI220-10-quicksort/</url>
      
        <content type="html"><![CDATA[<h2 id="divide-and-conquer-sorting-algorithms">Divide and Conquer Sorting Algorithms</h2><ul><li><strong>Split</strong> the list into sublist</li><li><strong>Recursively</strong> sort each sublists.</li><li><strong>Combine</strong> the sorted lists.</li></ul><p><strong>Merge Sort</strong> does comparisons during <strong>combining</strong>, <strong>quick sort</strong> does comparisons during <strong>splitting</strong>.</p><h2 id="quick-sort"><a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html">Quick Sort</a></h2><ul><li><p>Choose a <strong>pivot</strong>, then <strong>split(partition)</strong>:</p><ul><li>All elements in left sublist <span class="math inline">\(\leq\)</span> pivot.</li><li>All elements in right sublist <span class="math inline">\(&gt;\)</span> pivot.</li></ul></li><li><p>Recursively sort the left and right sublists.</p></li><li><p>Combine.</p></li></ul><p><strong>Choose</strong> a pivot: Use <strong>the first entry</strong> as pivot element for a basic presentation.</p><h3 id="pseudocode">Pseudocode</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function QuickSort(list a[0..n - 1], int i, int j)</span><br><span class="line">    if i &lt; j then</span><br><span class="line">        p = Partition(a, i, j) // Put pivot in the correct position.</span><br><span class="line">        QuickSort(a, i, p - i) // Sort left half.</span><br><span class="line">        QuickSort(a, p + 1, j) // Sort right half.</span><br><span class="line"></span><br><span class="line">function Partition(a, i, j)</span><br><span class="line">    // Linear time partitioning - Hoare&#x27;s method.</span><br><span class="line">    p = a[i]</span><br><span class="line">    l = i</span><br><span class="line">    r = j + 1</span><br><span class="line"></span><br><span class="line">    while True do</span><br><span class="line">        repeat</span><br><span class="line">            l++</span><br><span class="line">        until a[l] &gt;= p</span><br><span class="line"></span><br><span class="line">        repeat</span><br><span class="line">            r--</span><br><span class="line">        until a[r] &lt;= p</span><br><span class="line"></span><br><span class="line">        if l &lt; r then </span><br><span class="line">            swap(a, l, r) // Before: a[l] &gt;= p &gt;= a[r], swap to make a[l] &lt;= p &lt;= a[r].</span><br><span class="line">        else // The next a[l] &gt;= p(a[r] &lt;= p) is already on the right(left) side.</span><br><span class="line">            swap(a, i, r) // Put pivot in correct place.</span><br><span class="line">            </span><br><span class="line">            return r</span><br></pre></td></tr></table></figure><h2 id="quick-sort-analysis">Quick Sort Analysis</h2><p>Let <span class="math inline">\(C_n\)</span> denote <strong>the number of comparisons</strong> performed by quick sort over a list with <span class="math inline">\(n\)</span> elements.</p><p>Assume pivot is <span class="math inline">\(k\)</span>-th element in the sorted list.</p><ul><li>Comparison times of left sublist, <span class="math inline">\(C_{k - 1}\)</span>.</li><li>Comparison times of right sublist, <span class="math inline">\(C_{n - k}\)</span>.</li><li>Comparison times of partition, <span class="math inline">\(n - 1\)</span>.</li></ul><p><span class="math display">\[T(n) = T(C_n) \\\\C_n = C_{k - 1} + C_{n - k} + n - 1\]</span></p><h3 id="best-case">Best Case</h3><p>The pivot is the <strong>median</strong>, both sublists have <strong>equal length</strong>.</p><ul><li><span class="math inline">\(\approx \log n\)</span> levels of recursion.</li><li>Each level of recursion takes <span class="math inline">\(\Theta(n)\)</span>.</li><li>Therefore <span class="math inline">\(T(n) = \Theta(n \log n)\)</span>.</li></ul><h3 id="worst-case">Worst Case</h3><p>Every iteration <span class="math inline">\(k = 1\)</span>, <em>i.e.</em></p><ul><li>the input array is already sorted.</li><li>or the input array is inversed sorted.</li></ul><p>Only these two cases lead to the worst case.<br /><span class="math display">\[C_n = C_{n - 1} + n - 1, \\\\C_{n - 1} = C_{n - 2} + n - 2, \\\\\ldots \\\\C_2 = 1\]</span><br />So,<br /><span class="math display">\[C_n = \sum_{i = 1}^{n - 1} i,\\\\T(n) = \Theta(n^2)\]</span></p><h3 id="average-case">Average Case</h3><p>Assume all input permutation appears with equal probability.</p><p>Let <span class="math inline">\(a_n\)</span> be the average of <span class="math inline">\(C_n\)</span>,<br /><span class="math display">\[a_n = \frac{2}{n} \sum_{j = 0}^{n - 1} a_j + n - 1\]</span></p><p>Do <span class="math inline">\(na_n - (n - 1)a_{n - 1}\)</span> and sum up,<br /><span class="math display">\[\frac{a_n}{n + 1} = \frac{a_{n - 1}}{n} + \frac{4}{n + 1} - \frac{2}{n}\]</span></p><p>Expand from <span class="math inline">\(a_n\)</span> to <span class="math inline">\(a_2\)</span> and sum up,<br /><span class="math display">\[\frac{a_n}{n + 1} = \frac{a_1}{2} + 4(\frac{1}{n + 1} + \ldots + \frac{1}{3}) - 2(\frac{1}{n} + \ldots + \frac{1}{2})\]</span></p><p><span class="math inline">\(n\)</span>-th harmonic number <span class="math inline">\(H_n = \sum_{i = 1}^n\frac{1}{i}\)</span> is <span class="math inline">\(\Theta(\log n)\)</span>,<br /><span class="math display">\[a_n = (n + 1)(\frac{4}{n + 1} + 2H_n - 4)\]</span><br />So,<br /><span class="math display">\[T_{avg}(n) = \Theta(n \log n)\]</span></p><h3 id="suggestions-to-improve-quick-sort">Suggestions to Improve Quick Sort</h3><ol type="1"><li><strong>Pivot</strong><ul><li>Take the <strong>median</strong> of a sample of (say 3) elements.</li><li>Choose a pivot <strong>uniformly at random</strong>.</li></ul></li><li>Use <strong>insertion sort</strong> if the sublists are <strong>small</strong>.</li></ol><h2 id="summary">Summary</h2><table><colgroup><col style="width: 20%" /><col style="width: 20%" /><col style="width: 20%" /><col style="width: 20%" /><col style="width: 20%" /></colgroup><thead><tr class="header"><th>Sort Algorithm</th><th>Idea</th><th>Best Case</th><th>Average Case</th><th>Worst Case</th></tr></thead><tbody><tr class="odd"><td>Selection Sort</td><td>Choose the min/max and append it to the sorted list.</td><td><span class="math inline">\(O(n^2)\)</span>(already sorted)</td><td><span class="math inline">\(O(n^2)\)</span></td><td><span class="math inline">\(O(n^2)\)</span>(inverted)</td></tr><tr class="even"><td>Merge Sort<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></td><td>Split sublist and do comparison while merging.</td><td><span class="math inline">\(O(n^2)\)</span></td><td><span class="math inline">\(O(n^2)\)</span></td><td><span class="math inline">\(O(n^2)\)</span></td></tr><tr class="odd"><td>Quick Sort</td><td>Do comparison to make the left part is smaller than the pivot and the right part is bigger than the pivot.</td><td><span class="math inline">\(O(n \log n)\)</span>(…)</td><td><span class="math inline">\(O(n \log n)\)</span></td><td><span class="math inline">\(O(n^2)\)</span>(…)</td></tr></tbody></table><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr /><ol><li id="fn1"><p>The process of merge sort is similar no matter how the input array is arranged.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> COMPSCI 220 Algorithms and Data Structures </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 奥克兰大学—西南大学合作课程 </tag>
            
            <tag> 外文 </tag>
            
            <tag> 算法分析与设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【COMPSCI 220】 Lecture 9 Analysis of Sorting Algorithms</title>
      <link href="/2025/12/22/25-11-3-2-COMPSCI220-9-sort/"/>
      <url>/2025/12/22/25-11-3-2-COMPSCI220-9-sort/</url>
      
        <content type="html"><![CDATA[<h2 id="the-sorting-problem">The Sorting Problem</h2><p>The sorting problem seeks to arrange a list (<em>i.e.</em>, array or linked list) of keys (<em>e.g.</em>, integers, strings) so that every adjacent pair of keys is in the designated order.</p><ul><li><strong>INPUT</strong>: An unsorted list of keys <span class="math inline">\(a = [0, \cdots, n - 1]\)</span>.</li><li><strong>OUTPUT</strong>: A sorted list containing the same list of elements <span class="math inline">\({a[0], \cdots, a[n - 1]}\)</span>.</li></ul><h2 id="selection-sort">Selection Sort</h2><ul><li>Split the input list into <strong>sorted</strong> and <strong>unsorted</strong> sublists.</li><li>Sorted sublist is initially empty, and the unsorted sublist is the whole list.</li><li>Find a <strong>maximal element</strong> of the <strong>unsorted</strong> part by the <strong>sequential scan</strong>.</li><li>Move the maximal element to the <strong>head</strong> of the sorted part.</li><li>If the unsorted sublist is empty then terminate else go to (3)</li></ul><h3 id="pseudocode">Pseudocode</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function SelectionSort(a[0..n - 1])</span><br><span class="line">    for l = n - 1 to 0 do</span><br><span class="line">        k = FindMax(a[0..l]) // Find k where a[k] is maximum in a.</span><br><span class="line"></span><br><span class="line">        if k != l then</span><br><span class="line">            swap(a, l, k) // Swap a[l] and a[k].</span><br><span class="line">    </span><br><span class="line">    return a</span><br><span class="line"></span><br><span class="line">function FindMax(a[0..l])</span><br><span class="line">    max = 0</span><br><span class="line"></span><br><span class="line">    for i = 1 to l do // Sequential scan.</span><br><span class="line">        if a[max] &lt; a[i] do // Comparison.</span><br><span class="line">            max = i</span><br><span class="line"></span><br><span class="line">    return max</span><br></pre></td></tr></table></figure><h3 id="time-complexity">Time Complexity</h3><ul><li>Finding the maximum of <code>a[0..l]</code> takes <span class="math inline">\(l\)</span> comparisons.</li><li>Number of comparisons: <span class="math inline">\((n − 1) + (n − 2) + · · · + 1\)</span> which is <span class="math inline">\(\Theta(n^2)\)</span>.</li><li>Number of swaps: at <strong>most</strong> <span class="math inline">\(n − 1\)</span>.</li><li><strong>Worst-case</strong>(Increasing array) running time: <span class="math inline">\(\sum_{i = 1}^{n - 1} i = \Theta(n^2)\)</span>. (That is, above all <span class="math inline">\(O(n^2)\)</span>.)</li></ul><h2 id="comparison-based-sorting-algorithm"><a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html">Comparison-based Sorting Algorithm</a></h2><p>A sorting algorithm is comparison-based if it only uses the order relation to compare keys, <em>i.e.</em>, we determine the order of elements by answering questions of the type “is <span class="math inline">\(x &lt; y\)</span>?”.</p><ul><li>Non-comparison-based sort including <strong>bucket sort</strong>, <strong>radix sort</strong>, <em>e.t.c</em>.</li><li>Both <strong>comparison</strong> and <strong>swap</strong> cost time complexity of <span class="math inline">\(\Theta(1)\)</span>.</li></ul><h2 id="merge-sort">Merge Sort</h2><ul><li>To sort an input list, split it into two sublists.</li><li><strong>Recursively</strong> sorts each sublist.</li><li>Then <strong>combine(merge)</strong> the sorted sublists to sort the original list.</li></ul><h3 id="merge-operation">Merge Operation</h3><ul><li>Create a pointer for each sublist.</li><li>Create a <strong>merged list</strong> and a third pointer for this list.</li><li>Start pointers at the beginning of each list.</li><li>Compare the elements being pointed to and <strong>choose the less one</strong> to start the sorted list. Increment that pointer.</li><li>Iterate until <strong>one pointer</strong> reaches the end of its list.</li><li>Copy <strong>remaining elements</strong> of the other list to the end of the final sorted list.</li></ul><h3 id="pseudocode-1">Pseudocode</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">function MergeSort(list input[0..n − 1])</span><br><span class="line">    if n &gt; 1 then</span><br><span class="line">        s = floor((n − 1) / 2)  // Median index of list.</span><br><span class="line">        l = MergeSort(input[0..s]) // Sort the left half.</span><br><span class="line">        r = MergeSort(input[s + 1..n − 1]) // Sort the right half.</span><br><span class="line">        input = Merge(l, r) // Merge both halves</span><br><span class="line"></span><br><span class="line">    return input</span><br><span class="line"></span><br><span class="line">function Merge(list l, list r)</span><br><span class="line">    mergeList = new list(l.size + r.size) // Create a new list.</span><br><span class="line">    pl = pr = pml = 0 // pl: pointer of the peft part, pr: pointer of the right part, pml: pointer of the merged list.</span><br><span class="line"></span><br><span class="line">    while pl &lt; l.size and pr &lt; r.size do // Iterate until one pointer reaches the end.</span><br><span class="line">        if l[pl] &lt;= r[pr] then</span><br><span class="line">            mergeList[pml] = l[pl]</span><br><span class="line">            pl++</span><br><span class="line">        else</span><br><span class="line">            mergeList[pml] = r[pr]</span><br><span class="line">            pr++</span><br><span class="line"></span><br><span class="line">        pml++</span><br><span class="line"></span><br><span class="line">    while pl &lt; l.size do</span><br><span class="line">        mergeList[pml] = l[pl]</span><br><span class="line">        pl++</span><br><span class="line">        pml++</span><br><span class="line"></span><br><span class="line">    while pr &lt; r.size do</span><br><span class="line">        mergeList[pml] = r[pr]</span><br><span class="line">        pr++</span><br><span class="line">        pml++</span><br><span class="line">    </span><br><span class="line">    return mergeList</span><br></pre></td></tr></table></figure><h3 id="time-complexity-1">Time Complexity</h3><p>The merging process requires comparing and moving all <span class="math inline">\(n\)</span> elements, <span class="math inline">\(f(n) = n\)</span>.<br /><span class="math display">\[T(n) = 2T(\frac{n}{2}) + n = \Theta(n \log n) \]</span></p><p>where <span class="math inline">\(n &gt; 1\)</span>, <span class="math inline">\(n\)</span> is the power of 2, <span class="math inline">\(T(1) = 0\)</span>.</p><h2 id="lower-bound-of-camparison-based-sorting">Lower Bound of Camparison-based Sorting</h2><p>A <strong>comparison tree</strong> contains all possible outcomes of the comparison.</p><figure><img src="/image/25-11-3-2-COMPSCI220-9-sort/1766385108485.webp" alt="1766385108485" /><figcaption aria-hidden="true">1766385108485</figcaption></figure><ul><li>Internal nodes are camparisons between 2 elements.</li><li>Every internal node has exactly 2 children.</li><li>Leaves are possible ordering of all elements.</li><li>Every ordering appears as one leaf.</li><li>There are <span class="math inline">\(n!\)</span> leaves.</li></ul><p>The depth of the tree is the number of comparisons on the <strong>longest path</strong> from the root to a leaf. For <span class="math inline">\(n &gt; 0\)</span>, let <span class="math inline">\(h(n)\)</span> be the height of the comparison tree for <span class="math inline">\(n\)</span> numbers.</p><p>A binary tree with <span class="math inline">\(k\)</span> leaves has <strong>at least height</strong> <span class="math inline">\(\log k\)</span>. There are <span class="math inline">\(n!\)</span> number of permutations with <span class="math inline">\(n\)</span> numbers, <span class="math inline">\(k = n!\)</span>.<br /><span class="math display">\[h(n) \geq \log n!\]</span></p><p>Because <span class="math inline">\(\log n! &gt; \log(\frac{n}{2})^{\frac{n}{2}} = \frac{n}{2}(\log n - 1)\)</span>,<br /><span class="math display">\[h(n) = \Omega(n \log n)\]</span></p><p>The best time complexity for any comparison-based sorting algorithm is <span class="math inline">\(\Theta(n \log n)\)</span>. Merge sort is an <strong>optimal</strong> comparison-based sorting algorithm.</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> COMPSCI 220 Algorithms and Data Structures </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 奥克兰大学—西南大学合作课程 </tag>
            
            <tag> 外文 </tag>
            
            <tag> 算法分析与设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【COMPSCI 220】 Lecture 8 Matrix Multiplication and Strassen’s Algorithm</title>
      <link href="/2025/12/22/25-11-3-1-COMPSCI220-8-matrix/"/>
      <url>/2025/12/22/25-11-3-1-COMPSCI220-8-matrix/</url>
      
        <content type="html"><![CDATA[<h2 id="standard-matrix-multiplication-algorithm">Standard Matrix Multiplication Algorithm</h2><p>Let<br /><!-- $$\mathbf{A} = \begin{bmatrix}a_{11} & a_{12} & a_{13} \\a_{21} & a_{22} & a_{23} \\a_{31} & a_{32} & a_{33}\end{bmatrix}, \mathbf{B} = \begin{bmatrix}b_{11} & b_{12} & b_{13} \\b_{21} & b_{22} & b_{23} \\b_{31} & b_{32} & b_{33}\end{bmatrix}$$ --></p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mi mathvariant="bold">A</mi></mrow><mo>=</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">[</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><msub><mi>a</mi><mrow><mn>11</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>12</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>13</mn></mrow></msub></mtd></mtr><mtr><mtd><msub><mi>a</mi><mrow><mn>21</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>22</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>23</mn></mrow></msub></mtd></mtr><mtr><mtd><msub><mi>a</mi><mrow><mn>31</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>32</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>33</mn></mrow></msub></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">]</mo></mrow><mo>,</mo><mrow><mi mathvariant="bold">B</mi></mrow><mo>=</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">[</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><msub><mi>b</mi><mrow><mn>11</mn></mrow></msub></mtd><mtd><msub><mi>b</mi><mrow><mn>12</mn></mrow></msub></mtd><mtd><msub><mi>b</mi><mrow><mn>13</mn></mrow></msub></mtd></mtr><mtr><mtd><msub><mi>b</mi><mrow><mn>21</mn></mrow></msub></mtd><mtd><msub><mi>b</mi><mrow><mn>22</mn></mrow></msub></mtd><mtd><msub><mi>b</mi><mrow><mn>23</mn></mrow></msub></mtd></mtr><mtr><mtd><msub><mi>b</mi><mrow><mn>31</mn></mrow></msub></mtd><mtd><msub><mi>b</mi><mrow><mn>32</mn></mrow></msub></mtd><mtd><msub><mi>b</mi><mrow><mn>33</mn></mrow></msub></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">]</mo></mrow></math></p><p>then<br /><span class="math display">\[\mathbf{C} = \mathbf{A} \mathbf{B}, c_{ij} = \sum_{k = 1}^3 a_{ik}b_{kj}\]</span></p><h3 id="complexity">Complexity</h3><ul><li>Inner-most loop: Compute value for an entry.</li><li>Middle loop: Compute values in a row.</li><li>Outer-most loop: Compute values in all rows.</li></ul><p>For <span class="math inline">\(n \times n\)</span> matrix multiplication, time complexity <span class="math inline">\(\Theta(n^3)\)</span>.</p><h2 id="divide-and-conquer">Divide and Conquer</h2><p>To multiply two <span class="math inline">\(n \times n\)</span> matricies, we can first perform 8 <span class="math inline">\(\frac{n}{2} \times \frac{n}{2}\)</span> matrix multiplications.<br /><!-- $$\mathbf{A} = \begin{bmatrix}\mathbf{A_1} & \mathbf{A_2} \\ \mathbf{A_3} & \mathbf{A_4}\end{bmatrix}, \mathbf{B} = \begin{bmatrix}\mathbf{B_1} & \mathbf{B_2} \\ \mathbf{B_3} & \mathbf{B_4}\end{bmatrix}$$ --><br /><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mi mathvariant="bold">A</mi></mrow><mo>=</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">[</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><mrow><msub><mi mathvariant="bold">A</mi><mn mathvariant="bold">1</mn></msub></mrow></mtd><mtd><mrow><msub><mi mathvariant="bold">A</mi><mn mathvariant="bold">2</mn></msub></mrow></mtd></mtr><mtr><mtd><mrow><msub><mi mathvariant="bold">A</mi><mn mathvariant="bold">3</mn></msub></mrow></mtd><mtd><mrow><msub><mi mathvariant="bold">A</mi><mn mathvariant="bold">4</mn></msub></mrow></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">]</mo></mrow><mo>,</mo><mrow><mi mathvariant="bold">B</mi></mrow><mo>=</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">[</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><mrow><msub><mi mathvariant="bold">B</mi><mn mathvariant="bold">1</mn></msub></mrow></mtd><mtd><mrow><msub><mi mathvariant="bold">B</mi><mn mathvariant="bold">2</mn></msub></mrow></mtd></mtr><mtr><mtd><mrow><msub><mi mathvariant="bold">B</mi><mn mathvariant="bold">3</mn></msub></mrow></mtd><mtd><mrow><msub><mi mathvariant="bold">B</mi><mn mathvariant="bold">4</mn></msub></mrow></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">]</mo></mrow></math></p><p>then<br /><!-- $$\mathbf{C} = \mathbf{A} \mathbf{B} = \begin{bmatrix}\mathbf{A_1}\mathbf{B_1} + \mathbf{A_2}\mathbf{B_3} & \mathbf{A_1}\mathbf{B_2} + \mathbf{A_2}\mathbf{B_4} \\ \mathbf{A_3}\mathbf{B_1} + \mathbf{A_4}\mathbf{B_3} & \mathbf{A_3}\mathbf{B_2} + \mathbf{A_4}\mathbf{B_4}\end{bmatrix}$$ --><br /><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mi mathvariant="bold">C</mi></mrow><mo>=</mo><mrow><mi mathvariant="bold">A</mi></mrow><mrow><mi mathvariant="bold">B</mi></mrow><mo>=</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">[</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><mrow><msub><mi mathvariant="bold">A</mi><mn mathvariant="bold">1</mn></msub></mrow><mrow><msub><mi mathvariant="bold">B</mi><mn mathvariant="bold">1</mn></msub></mrow><mo>+</mo><mrow><msub><mi mathvariant="bold">A</mi><mn mathvariant="bold">2</mn></msub></mrow><mrow><msub><mi mathvariant="bold">B</mi><mn mathvariant="bold">3</mn></msub></mrow></mtd><mtd><mrow><msub><mi mathvariant="bold">A</mi><mn mathvariant="bold">1</mn></msub></mrow><mrow><msub><mi mathvariant="bold">B</mi><mn mathvariant="bold">2</mn></msub></mrow><mo>+</mo><mrow><msub><mi mathvariant="bold">A</mi><mn mathvariant="bold">2</mn></msub></mrow><mrow><msub><mi mathvariant="bold">B</mi><mn mathvariant="bold">4</mn></msub></mrow></mtd></mtr><mtr><mtd><mrow><msub><mi mathvariant="bold">A</mi><mn mathvariant="bold">3</mn></msub></mrow><mrow><msub><mi mathvariant="bold">B</mi><mn mathvariant="bold">1</mn></msub></mrow><mo>+</mo><mrow><msub><mi mathvariant="bold">A</mi><mn mathvariant="bold">4</mn></msub></mrow><mrow><msub><mi mathvariant="bold">B</mi><mn mathvariant="bold">3</mn></msub></mrow></mtd><mtd><mrow><msub><mi mathvariant="bold">A</mi><mn mathvariant="bold">3</mn></msub></mrow><mrow><msub><mi mathvariant="bold">B</mi><mn mathvariant="bold">2</mn></msub></mrow><mo>+</mo><mrow><msub><mi mathvariant="bold">A</mi><mn mathvariant="bold">4</mn></msub></mrow><mrow><msub><mi mathvariant="bold">B</mi><mn mathvariant="bold">4</mn></msub></mrow></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">]</mo></mrow></math></p><h3 id="complexity-1">Complexity</h3><p>The <span class="math inline">\(\mathbf{C} = \mathbf{A} \mathbf{B}\)</span> has a fixed complexity of <span class="math inline">\(\Theta(n^2)\)</span>, thus<br /><span class="math display">\[T(n) = 8T(\frac{n}{2}) + cn = \Theta(n^3)\]</span></p><h2 id="strassens-algorithms">Strassen’s Algorithms</h2><p>“Group” some of the multiplications together so we need less than 8 sub-matrix multplication.</p><p>First divide <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span> into<br /><!-- $$\mathbf{A} = \begin{bmatrix}\mathbf{A_1} & \mathbf{A_2} \\ \mathbf{A_3} & \mathbf{A_4}\end{bmatrix}, \mathbf{B} = \begin{bmatrix}\mathbf{B_1} & \mathbf{B_2} \\ \mathbf{B_3} & \mathbf{B_4}\end{bmatrix}$$ --><br /><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mi mathvariant="bold">A</mi></mrow><mo>=</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">[</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><mrow><msub><mi mathvariant="bold">A</mi><mn mathvariant="bold">1</mn></msub></mrow></mtd><mtd><mrow><msub><mi mathvariant="bold">A</mi><mn mathvariant="bold">2</mn></msub></mrow></mtd></mtr><mtr><mtd><mrow><msub><mi mathvariant="bold">A</mi><mn mathvariant="bold">3</mn></msub></mrow></mtd><mtd><mrow><msub><mi mathvariant="bold">A</mi><mn mathvariant="bold">4</mn></msub></mrow></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">]</mo></mrow><mo>,</mo><mrow><mi mathvariant="bold">B</mi></mrow><mo>=</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">[</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><mrow><msub><mi mathvariant="bold">B</mi><mn mathvariant="bold">1</mn></msub></mrow></mtd><mtd><mrow><msub><mi mathvariant="bold">B</mi><mn mathvariant="bold">2</mn></msub></mrow></mtd></mtr><mtr><mtd><mrow><msub><mi mathvariant="bold">B</mi><mn mathvariant="bold">3</mn></msub></mrow></mtd><mtd><mrow><msub><mi mathvariant="bold">B</mi><mn mathvariant="bold">4</mn></msub></mrow></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">]</mo></mrow></math></p><p>We let<br /><span class="math display">\[\mathbf{P}_1 = \mathbf{A}_1(\mathbf{B}_2 - \mathbf{B}_4) \\\\\mathbf{P}_2 = (\mathbf{A}_1 + \mathbf{A}_2)\mathbf{B}_4 \\\\\mathbf{P}_3 = (\mathbf{A}_3 + \mathbf{A}_4)\mathbf{B}_1 \\\\\mathbf{P}_4 = \mathbf{A}_4(\mathbf{B}_3 - \mathbf{B}_1) \\\\\mathbf{P}_5 = (\mathbf{A}_1 + \mathbf{A}_4)(\mathbf{B}_1 + \mathbf{B}_4) \\\\\mathbf{P}_6 = (\mathbf{A}_2 - \mathbf{A}_4)(\mathbf{B}_3 + \mathbf{B}_4) \\\\\mathbf{P}_7 = (\mathbf{A}_1 - \mathbf{A}_3)(\mathbf{B}_1 + \mathbf{B}_2)\]</span></p><p>Each calculation above costs time complexity of <span class="math inline">\(\Theta(\frac{n}{2})\)</span>, then<br /><!-- $$\mathbf{C} = \mathbf{A} \mathbf{B} = \begin{bmatrix}\mathbf{P}_5 + \mathbf{P}_4 - \mathbf{P}_2 + \mathbf{P}_6 & \mathbf{P}_1 + \mathbf{P}_2 \\ \mathbf{P}_3 + \mathbf{P}_4 & \mathbf{P}_5 + \mathbf{P}_1 - \mathbf{P}_3 - \mathbf{P}_7\end{bmatrix}$$ --></p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mi mathvariant="bold">C</mi></mrow><mo>=</mo><mrow><mi mathvariant="bold">A</mi></mrow><mrow><mi mathvariant="bold">B</mi></mrow><mo>=</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">[</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><msub><mrow><mi mathvariant="bold">P</mi></mrow><mn>5</mn></msub><mo>+</mo><msub><mrow><mi mathvariant="bold">P</mi></mrow><mn>4</mn></msub><mo>−</mo><msub><mrow><mi mathvariant="bold">P</mi></mrow><mn>2</mn></msub><mo>+</mo><msub><mrow><mi mathvariant="bold">P</mi></mrow><mn>6</mn></msub></mtd><mtd><msub><mrow><mi mathvariant="bold">P</mi></mrow><mn>1</mn></msub><mo>+</mo><msub><mrow><mi mathvariant="bold">P</mi></mrow><mn>2</mn></msub></mtd></mtr><mtr><mtd><msub><mrow><mi mathvariant="bold">P</mi></mrow><mn>3</mn></msub><mo>+</mo><msub><mrow><mi mathvariant="bold">P</mi></mrow><mn>4</mn></msub></mtd><mtd><msub><mrow><mi mathvariant="bold">P</mi></mrow><mn>5</mn></msub><mo>+</mo><msub><mrow><mi mathvariant="bold">P</mi></mrow><mn>1</mn></msub><mo>−</mo><msub><mrow><mi mathvariant="bold">P</mi></mrow><mn>3</mn></msub><mo>−</mo><msub><mrow><mi mathvariant="bold">P</mi></mrow><mn>7</mn></msub></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">]</mo></mrow></math></p><h3 id="complexity-2">Complexity</h3><p><span class="math display">\[T(n) = 7T(\frac{n}{2}) + cn = \Theta(n^{\log7}) \approx \Theta(n^{2.808})\]</span></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> COMPSCI 220 Algorithms and Data Structures </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 奥克兰大学—西南大学合作课程 </tag>
            
            <tag> 外文 </tag>
            
            <tag> 算法分析与设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【COMPSCI 220】 Lecture 7 Divide and Conquer</title>
      <link href="/2025/12/22/25-12-11-2-COMPSCI220-7-div-coq/"/>
      <url>/2025/12/22/25-12-11-2-COMPSCI220-7-div-coq/</url>
      
        <content type="html"><![CDATA[<h2 id="divide-and-conquer">Divide-and-Conquer</h2><p>The divide-and-conquer technique solves a computational problem by dividing it into one or more subprograms of smaller size, conquering each of them by solving them recursively, and then combining their solutions into a solution for the original problem.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if n &lt;= n0 then</span><br><span class="line">    directly solve problem without dividing</span><br><span class="line">else</span><br><span class="line">    divide problem into a subproblems of size n/b each</span><br><span class="line">    for i ← 0 to a − 1 do</span><br><span class="line">        recursively solve the ith subproblem</span><br><span class="line">    combine the a solutions into a solution of the original problem</span><br></pre></td></tr></table></figure><p>Running time:<br /><span class="math display">\[T(n) = a T(\frac{n}{b}) + f(n)\]</span></p><h2 id="example-1-karatsubas-algorithm">Example 1: Karatsuba’s Algorithm</h2><p><a href="/2025/12/18/25-12-11-1-COMPSCI220-6-karastuba/#karastubas-algorithms">【COMPSCI 220】 Lecture 6 Karastuba’s Algorithms</a></p><h2 id="example-2-binary-search">Example 2: Binary Search</h2><h3 id="problem">Problem</h3><p>Search from a number from a sorted sequence of numbers.</p><table><colgroup><col style="width: 6%" /><col style="width: 6%" /><col style="width: 6%" /><col style="width: 6%" /><col style="width: 6%" /><col style="width: 6%" /><col style="width: 6%" /><col style="width: 6%" /><col style="width: 6%" /><col style="width: 6%" /><col style="width: 6%" /><col style="width: 6%" /><col style="width: 6%" /><col style="width: 6%" /><col style="width: 6%" /><col style="width: 6%" /></colgroup><thead><tr class="header"><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th></tr></thead><tbody><tr class="odd"><td>0</td><td>29</td><td>43</td><td>45</td><td>56</td><td>58</td><td>71</td><td>78</td><td>83</td><td>91</td><td>95</td><td>99</td><td>156</td><td>171</td><td>222</td><td>291</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function BinarySearch(arr, target, start, end)</span><br><span class="line">    INPUT: Integer array arr, indices start,end, integer target</span><br><span class="line">    OUTPUT: Yes if target is in arr; No otherwise</span><br><span class="line"></span><br><span class="line">    if start &gt; end then</span><br><span class="line">        return “the element doesn’t belong to the sequence”</span><br><span class="line"></span><br><span class="line">    middle ← celi(start + end)</span><br><span class="line"></span><br><span class="line">    if arr[middle] = target then</span><br><span class="line">        return “the element is found”</span><br><span class="line">    else if target &lt; arr[middle] then</span><br><span class="line">        return BinarySearch(arr, target, start, middle − 1)</span><br><span class="line">    else</span><br><span class="line">        return BinarySearch(arr, target, middle + 1, end)</span><br></pre></td></tr></table></figure><p>Time complexity:<br /><span class="math display">\[T(n) = T(\frac{n}{2}) + c\]</span></p><h2 id="master-theorem">Master Theorem</h2><p>If a time complexity has a form like <span class="math inline">\(T(n) = aT(\frac{n}{b}) + f(n)\)</span>, then<br /><span class="math display">\[T(n) = \begin{cases}    \Theta(n^{\log_ba}), &amp;f(n) \ll n^{\log_ba} \\\\    \Theta(n^{\log_ba} \log n), &amp;f(n) \approx n^{\log_ba} \\\\    \Theta(f(n)), &amp;f(n) \gg n^{\log_ba}\end{cases}\]</span></p><p><strong>Example</strong><br />Calculate<br /><span class="math display">\[T(n) = 9T(\frac{n}{3}) + n\]</span></p><details><p><strong>Answer</strong><br />Applying <strong>Master’s Theorem</strong>, we have<br /><span class="math display">\[a = 9, b = 3, f(n) = n\]</span></p><p>so<br /><span class="math display">\[n^{\log_ba} = n^2, \Theta(f(n)) = \Theta(n)\]</span></p><p>so<br /><span class="math display">\[f(n) \ll n^{\log_ba}\]</span></p><p>so<br /><span class="math display">\[T(n) = \Theta(n^{\log_ba}) = \Theta(n^2)\]</span></p></details><p>Calculate<br /><span class="math display">\[T(n) = T(\frac{n}{2}) + c\]</span></p><details><p>Applying Master’s Theorem, we have<br /><span class="math display">\[a = 1, b = 2, n^{\log_b a} = 1, \\f(n) = c\]</span></p><p>So <span class="math inline">\(n^{\log_b a}\)</span> and <span class="math inline">\(f(n)\)</span> have the same growth rate, then<br /><span class="math display">\[T(n) = \Theta(\log n)\]</span></p></details><blockquote><p><strong>Cases When Master’s Theorem Doesn’t Work</strong></p><ol type="1"><li><p><span class="math inline">\(a &lt; 1\)</span>.</p></li><li><p><span class="math inline">\(f(n) &lt; 0\)</span>.</p></li><li><p><span class="math inline">\(f(n)\)</span> is <strong>not small enough</strong>(difference is smaller than a polynomial factor).</p></li><li><p><span class="math inline">\(f(n)\)</span> is <strong>not big enough</strong>(difference is smaller than a polynomial factor).</p></li></ol></blockquote><p><strong>Other Examples</strong></p><ul><li>Karastuba’s Algorithm</li><li>Binary Search</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> COMPSCI 220 Algorithms and Data Structures </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 奥克兰大学—西南大学合作课程 </tag>
            
            <tag> 外文 </tag>
            
            <tag> 算法分析与设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【COMPSCI 220】 Lecture 6 Karastuba&#39;s Algorithms</title>
      <link href="/2025/12/18/25-12-11-1-COMPSCI220-6-karastuba/"/>
      <url>/2025/12/18/25-12-11-1-COMPSCI220-6-karastuba/</url>
      
        <content type="html"><![CDATA[<h2 id="multiplication-problem">Multiplication Problem</h2><ul><li><strong>INPUT</strong>: Two binary arrays <span class="math inline">\(x[0 \cdots n - 1]\)</span>, <span class="math inline">\(y[0 \cdots n - 1]\)</span>.</li><li><strong>OUTPUT</strong>: A binary array <span class="math inline">\(z[0 \cdots 2n - 1]\)</span> represents <span class="math inline">\(xy\)</span>.</li></ul><h2 id="long-multiplication-the-grade-school-algorithm">Long Multiplication: The “Grade School” Algorithm</h2><ul><li>Outer for-loop: repeats <span class="math inline">\(n\)</span> times.</li><li>Inner for-loop: repeats <span class="math inline">\(n\)</span> times in worst case.</li><li>Each iteration in the inner loop: Constant number of (single-bit) addition, modulo, division, and assignment</li></ul><p>Therefore the running time of long multiplication is <span class="math inline">\(\Theta(n^2)\)</span>.</p><h2 id="karastubas-algorithms">Karastuba’s Algorithms</h2><p>Multi-digit multiplication can be splitted and tidied into<br /><span class="math display">\[(ax + b)(cx + d) = acx^2 + bd + [(a + b)(c + d) - ac - bd]x\]</span></p><p>which costs <strong>3</strong> multiplications and <strong>6</strong> additions.<br /><img src="/image/25-12-11-1-COMPSCI220-6-karastuba/1766043927470.webp" alt="1766043927470" /></p><h3 id="pseudocode">Pseudocode</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">algo karastuba(x[0..n - 1], y[0..n - 1])</span><br><span class="line">    // Base Case</span><br><span class="line">    if(n == 1) do</span><br><span class="line">        return x * y</span><br><span class="line"></span><br><span class="line">    x.splitHalf(xhigh, xlow)</span><br><span class="line">    y.splitHalf(yhigh, ylow) // Split each integer into two halves: a high part and a low part.</span><br><span class="line"></span><br><span class="line">    z0 = karastuba(xlow, ylow)</span><br><span class="line">    z1 = karastuba(xlow + xhigh, ylow + yhigh)</span><br><span class="line">    z2 = karastuba(xhigh, yhigh)</span><br><span class="line"></span><br><span class="line">    return (z2 &lt;&lt; 2k) + ((z1 - z2 - z0) &lt;&lt; k) + z0</span><br></pre></td></tr></table></figure><h3 id="time-complexity">Time Complexity</h3><p>The algorithm has three recursive step which use half length of the input.<br /><span class="math display">\[T(n) = \begin{cases}  c &amp;, n = 1 \\  3T(\frac{n}{2}) + cn &amp;, \text{otherwise}\end{cases}\]</span></p><p>Let <span class="math inline">\(k = \log n\)</span> be the height of the recursive tree.<br />$$<br /><span class="math display">\[\begin{align}  T(n) &amp;= cn(1 + \frac{3}{2} + \frac{3^2}{2^2} + \cdots + \frac{3^k}{2^k}) \\  &amp;= cn\frac{\left( \frac{3}{2} \right)^{k + 1} - 1}{\frac{3}{2} - 1} \\   &amp;\leq 3cn\frac{3^k}{2^k} = 3cn\frac{3^{\log n}}{2^{\log n}} = 3c \cdot 3^{\log n} \\  &amp;= O(n^{1.59})\end{align}\]</span></p><p>$$</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> COMPSCI 220 Algorithms and Data Structures </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 奥克兰大学—西南大学合作课程 </tag>
            
            <tag> 外文 </tag>
            
            <tag> 算法分析与设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【COMPSCI 220】 Lecture 5 More Issues on Algorithm Analysis</title>
      <link href="/2025/12/11/25-11-19-2-COMPSCI220-5-more-iss/"/>
      <url>/2025/12/11/25-11-19-2-COMPSCI220-5-more-iss/</url>
      
        <content type="html"><![CDATA[<h2 id="elementary-operations">Elementary Operations</h2><ol type="1"><li><p><strong>Comparison</strong></p><table><thead><tr class="header"><th>Operation</th><th>Theoretically</th><th>Actually</th></tr></thead><tbody><tr class="odd"><td>Adding two numbers</td><td><span class="math inline">\(O(1)\)</span></td><td><span class="math inline">\(\Theta(n)\)</span></td></tr><tr class="even"><td>Multiplying two numbers</td><td><span class="math inline">\(O(1)\)</span></td><td><span class="math inline">\(O(n^2)\)</span> (by hand)</td></tr></tbody></table></li><li><p><strong>Default</strong></p><blockquote><p><strong>MOTTO</strong><br />Nevertheless, in this course, we will assume <span class="math inline">\(+\)</span>, <span class="math inline">\(\times\)</span> are <strong>elementary</strong> by default(<span class="math inline">\(O(1)\)</span>), unless stated otherwise.</p></blockquote></li></ol><h2 id="input-size">Input Size</h2><ol type="1"><li><p><strong>Definition</strong><br />The input size of an algorithm is <strong>the number of bits</strong> taken to store the input of the algorithm.</p></li><li><p><strong>Comaprison</strong><br />Let <span class="math inline">\(x\)</span> be the input number(binary, for example), let <span class="math inline">\(n\)</span> be the size of <span class="math inline">\(x\)</span>, <span class="math inline">\(n = \log_2 x\)</span>.</p><table><thead><tr class="header"><th>Algorithm</th><th><span class="math inline">\(T(x)\)</span></th><th><span class="math inline">\(T(n)\)</span></th></tr></thead><tbody><tr class="odd"><td>Slow Fibonacci</td><td><span class="math inline">\(\Omega(1.618^x)\)</span></td><td><span class="math inline">\(1.618^{2^n}\)</span></td></tr><tr class="even"><td>Fast Fibonacci</td><td><span class="math inline">\(\Theta(x)\)</span></td><td><span class="math inline">\(\Theta(2^n)\)</span></td></tr></tbody></table></li></ol><blockquote><p><strong>MOTTO</strong><br />In this course, from now on, we will use <span class="math inline">\(n\)</span> to denote <strong>the size of the input</strong>, not the value of input.</p></blockquote><h2 id="different-inputs-of-a-given-size">Different Inputs of a Given Size</h2><ol type="1"><li><strong>Definition</strong><ul><li>The <strong>worst-case</strong> running time of <code>algo</code> maps <span class="math inline">\(n\)</span> to the <strong>maximum running time</strong> of <code>algo</code> on any input with size <span class="math inline">\(n\)</span>.</li><li>The <strong>average-case</strong> running time of <code>algo</code> maps <span class="math inline">\(n\)</span> to the <strong>average running time</strong> of <code>algo</code> on any input with size <span class="math inline">\(n\)</span>.</li><li>The <strong>best-case</strong> running time of <code>algo</code> maps <span class="math inline">\(n\)</span> to the <strong>minimum running time</strong> of <code>algo</code> on any input with size <span class="math inline">\(n\)</span>.</li></ul></li><li><strong>Example: Calculating Cases</strong><br /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function ZERO(arrays a[0..n − 1])</span><br><span class="line">    j ← 0</span><br><span class="line">    count ← 0</span><br><span class="line">    while a[j] = 0 do</span><br><span class="line">        count ← count + 1</span><br><span class="line">        j ← j + 1</span><br><span class="line">    return count</span><br></pre></td></tr></table></figure><ul><li><p><strong>Best Case</strong>: When <span class="math inline">\(a[1] = 1\)</span>, the while-loop terminates straightaway. <span class="math inline">\(T(n) = \Theta(1)\)</span>.</p></li><li><p><strong>Worst Case</strong>: When <span class="math inline">\(a\)</span> contains no <span class="math inline">\(1\)</span>, the while-loop repeats <span class="math inline">\(n\)</span> iterations, <span class="math inline">\(T(n) = \Theta(n)\)</span>.</p></li><li><p><strong>Average Case</strong></p><ul><li>There are total <span class="math inline">\(2^n\)</span> input cases.</li><li>For <span class="math inline">\(i = 1 \cdots n\)</span>, there are <span class="math inline">\(2^{n - 1}\)</span> cases that <span class="math inline">\(a_k = 0, k &lt; i, a_i = 1\)</span>. The while-loop will run <span class="math inline">\(i\)</span> times.</li><li>There is 1 array <span class="math inline">\([0, 0, \cdots 0]\)</span>.</li></ul><p>The sum of the number of while-loop iterations over all inputs:<br /><span class="math display">\[n + \sum_{i = 1}^n i 2^{n - 1} = n + 2^{n + 1} - n - 2\]</span></p><p>The average time of the running:<br /><span class="math display">\[\frac{2^{n + 1} - 2}{2^n} \leq 2\]</span></p><p>So <span class="math inline">\(T(n) = \Theta(1)\)</span>.</p></li></ul></li></ol><blockquote><p><strong>MOTTO</strong><br />In this course, we will mostly perform <strong>worst-case</strong> running time analysis, and we will discuss average-case only for special algorithms.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> COMPSCI 220 Algorithms and Data Structures </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 奥克兰大学—西南大学合作课程 </tag>
            
            <tag> 外文 </tag>
            
            <tag> 算法分析与设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【STATS 330】 Handout 5 Deviance as A Goodness-of-fit Statistic</title>
      <link href="/2025/11/30/25-11-30-2-STATS330-5-devi-as-gof/"/>
      <url>/2025/11/30/25-11-30-2-STATS330-5-devi-as-gof/</url>
      
        <content type="html"><![CDATA[<h2 id="goodness-of-fit">Goodness-of-fit</h2><p>What is it actually?</p><h2 id="deviance-as-a-goodness-of-fit-statistic">Deviance as A Goodness-of-fit Statistic</h2><p>A large deviance could indicate lack-of-fit. How large is too large?<br />- If the model is correct, then, under certain conditions, the deviance comes from a <span class="math inline">\(\chi_{n - k}^2\)</span>, where <span class="math inline">\(n\)</span> is the number of observations and <span class="math inline">\(k\)</span> is the number of coefficients.<br />- If it is plausible that <strong>the deviance could have come from this distribution</strong>, we have <strong>no evidence against</strong> the hypothesis that our model is correct.<br />- If it is not plausible that the deviance could have come from this distribution, we do have evidence against the hypothesis that the model is correct.</p><p>Formally, we test the null hypothesis that the model is correct by calculating a <strong>p-value</strong> using<br /><span class="math display">\[p = \Pr(\chi_{n - k}^2 &gt; D)\]</span></p><p>Using R to calculate this p-value.<br /><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="operator">-</span> pchisq<span class="punctuation">(</span><span class="operator">&lt;</span>deviance<span class="operator">&gt;</span><span class="punctuation">,</span> <span class="operator">&lt;</span>df<span class="operator">&gt;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure></p><p>The critical value is still 0.05.</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> STATS 330 Application and Practice of Statistics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 统计学 </tag>
            
            <tag> R 语言 </tag>
            
            <tag> 数据科学 </tag>
            
            <tag> 奥克兰大学—西南大学合作课程 </tag>
            
            <tag> 外文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【STATS 330】 Handout 4 Deviance</title>
      <link href="/2025/11/30/25-11-30-1-STATS330-4-deviance/"/>
      <url>/2025/11/30/25-11-30-1-STATS330-4-deviance/</url>
      
        <content type="html"><![CDATA[<h2 id="goodness-of-fit">Goodness-of-fit</h2><p>“Goodness-of-fit” is a property that describes how well the data appear to fit the model assumptions.</p><p>For a GLM, they are:<br />- The observations are <strong>independent</strong>.<br />- <span class="math inline">\(g(\boldsymbol{\theta}) = \boldsymbol{X \beta}\)</span>; after applying the link function, the parameter of interest is a <strong>linear combination</strong> of the explanatory terms.<br />- Each response comes from the <strong>assumed distribution</strong>.</p><h2 id="model-complexity-residual-sum-of-squares-and-likelihood">Model Complexity, Residual Sum of Squares, and Likelihood</h2><p>Increasing a model’s complexity will almost always/never decrease/increase RSS(LM), or increase/decrease the log-likelihood(GLM).</p><h2 id="the-saturated-model">The Saturated Model</h2><dl><dt><strong>Saturated Model</strong></dt><dd>A model with as many parameters as there are observations.</dd></dl><p>Which means the model:<br />- is <strong>the most complex</strong>.<br />- cannot add any <strong>further explanatory terms</strong>.<br />- The regression will go through <strong>every data point</strong>.<br />- <span class="math inline">\(RSS \equiv 0\)</span>(LM) or loglikelihood reaches the max(GLM).</p><p>Overcomplicated models, such as saturated models, are said to be impractical because<br />- we need underlying trends, not with random noise.</p><h2 id="the-null-model">The Null Model</h2><dl><dt><strong>Null Model</strong></dt><dd>A model with no explanatory variables.</dd></dl><p><span class="math display">\[g(\theta_i) = \beta_0\]</span></p><p>A model with any choice of explanatory variables, the RSS would be<br /><span class="math display">\[0 = RSS_{\text{saturated}} \leq RSS \leq RSS_{\text{null}}\]</span></p><p>The log-likelihood would be<br /><span class="math display">\[l_{\text{null}} \leq l \leq l_{\text{saturated}} = l_{\max}\]</span></p><h2 id="deviance">Deviance</h2><dl><dt><strong>Deviance</strong></dt><dd>The difference between the maximised log-likelihood of the fitted model.<br /><span class="math display">\[D = 2(l_S - l)\]</span></dd></dl><p>The further the observations get from the line, the larger the discrepancy between the fitted values of our model and the fitted values of the saturated model, the larger the deviance.</p><p>Null deviance is the deviance of the null model.<br /><span class="math display">\[D_N = 2(l_S - l_N)\]</span></p><p>So for a model with any choice of explanatory variables,<br /><span class="math display">\[0 = D_S \leq D \leq D_N = D_{\max}\]</span></p><p>Using R to calculate deviance<br /><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deviance<span class="punctuation">(</span><span class="operator">&lt;</span>fit<span class="operator">&gt;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> STATS 330 Application and Practice of Statistics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 统计学 </tag>
            
            <tag> R 语言 </tag>
            
            <tag> 数据科学 </tag>
            
            <tag> 奥克兰大学—西南大学合作课程 </tag>
            
            <tag> 外文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【COMPSCI 220】Lecture 4 Asymptotic notations</title>
      <link href="/2025/11/19/25-11-19-1-COMPSCI220-4-asym-not/"/>
      <url>/2025/11/19/25-11-19-1-COMPSCI220-4-asym-not/</url>
      
        <content type="html"><![CDATA[<h2 id="dominance-relation">Dominance Relation</h2><p>The dominance relation of the frequently used classes:<br /><span class="math display">\[1 \prec \log n \prec (\log n)^2 \prec n \prec n \log n \prec n^2 \prec n^2 \log n \prec n^3 \prec \cdots \prec 2^n \prec n!\]</span></p><h2 id="asymptotic-notation">Asymptotic Notation</h2><p>Define<br /><span class="math display">\[f(n) \prec g(n) \Leftrightarrow f(n) = O(g(n)) \\\\g(n) \prec f(n) \Leftrightarrow f(n) = \Omega(g(n)) \\\\f(n) = O(g(n)), f(n) = \Omega(g(n)) \Leftrightarrow f(n) = \Theta(g(n))\]</span></p><table><thead><tr class="header"><th>Notation</th><th>Read</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(O\)</span></td><td>asymptotic upper bound</td></tr><tr class="even"><td><span class="math inline">\(\Omega\)</span></td><td>asymptotic lower bound</td></tr><tr class="odd"><td><span class="math inline">\(\Theta\)</span></td><td>have the same growth rate</td></tr></tbody></table><p>Loosely,<br /><span class="math display">\[\begin{aligned}f(n) = O(g(n)) &amp;\Leftrightarrow \lim_{n \to \infty} \frac{f(n)}{g(n)} &lt; \infty \\\\f(n) = \Omega(g(n)) &amp;\Leftrightarrow \lim_{n \to \infty} \frac{f(n)}{g(n)} &gt; 0 \\\\f(n) = \Theta(g(n)) &amp;\Leftrightarrow \lim_{n \to \infty} \frac{f(n)}{g(n)} = c, \text{a constant real number}\end{aligned}\]</span></p><h3 id="nature">Nature</h3><ul><li><p><strong>Reflexivity</strong><br /><span class="math display">\[f(n) = O(f(n)) \ \text{or} \  \Omega(f(n)) \ \text{or} \  \Theta(f(n))\]</span></p></li><li><p><strong>Symmetry</strong><br /><span class="math display">\[f(n) = \Theta(g(n)) \Leftrightarrow g(n) = \Theta(f(n))\]</span></p></li><li><p><strong>Transitivity</strong><br /><span class="math display">\[f(n) = R(g(n)), g(n) = R(h(n)) \Rightarrow f(n) = R(h(n))\]</span></p><p><span class="math inline">\(R\)</span> could be <span class="math inline">\(O\)</span>, <span class="math inline">\(\Omega\)</span>, <span class="math inline">\(\Theta\)</span>.</p></li><li><p><strong>Sum Rule</strong><br /><span class="math display">\[f_1 = O(g_1), f_2 = O(g_2) \\\\\Rightarrow f_1 + f_2 = O(\max\{g_1, g_2\})\]</span></p></li><li><p><strong>Product Rule</strong><br /><span class="math display">\[f_1 = O(g_1), f_2 = O(g_2) \\\\\Rightarrow f_1f_2 = O(g_1g_2)\]</span></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> COMPSCI 220 Algorithms and Data Structures </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 奥克兰大学—西南大学合作课程 </tag>
            
            <tag> 外文 </tag>
            
            <tag> 算法分析与设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【COMPSCI 220】 Lecture 3 How to Estimate Running Time?</title>
      <link href="/2025/11/19/25-11-4-3-COMSCI220-3-esti-run-time/"/>
      <url>/2025/11/19/25-11-4-3-COMSCI220-3-esti-run-time/</url>
      
        <content type="html"><![CDATA[<h2 id="time-complexity-and-loops">Time Complexity and Loops</h2><ol type="1"><li><p><strong>No loop.</strong><br /><span class="math inline">\(f(n) = c\)</span>.<br /><strong>Rule 1</strong>: A fixed umber of statements take constant time.</p></li><li><p><strong>A single loop.</strong><br /><span class="math inline">\(f(n) = c(n - 1) + d\)</span>.<br /><strong>Rule 2</strong>: The running time of a loop multiplies by the number of iterations.</p></li><li><p><strong>Exponential change of variables in loop.</strong><br /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 1</span><br><span class="line">while i &lt; n do</span><br><span class="line">    i = 2i</span><br><span class="line">    print i</span><br></pre></td></tr></table></figure><br />In general, the number of iterations is <span class="math inline">\(\lceil \log n \rceil\)</span>, the smallest <span class="math inline">\(k\)</span> such that <span class="math inline">\(2^k &gt; n\)</span>.</p></li><li><p><strong>Disjoint blocks.</strong><br /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for i = 1 to n do</span><br><span class="line">    print i</span><br><span class="line">    j = 1</span><br><span class="line">while j &lt; n do</span><br><span class="line">    j = 2j</span><br><span class="line">    print j</span><br></pre></td></tr></table></figure><br /><span class="math inline">\(t(n) = f(n) + g(n) = cn + d \lceil \log n \rceil\)</span>.<br /><strong>Rule 3</strong>: Running time of disjoint blocks adds.</p></li><li><p><strong>Nested loops.</strong><br /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i = 1 to n do</span><br><span class="line">    for j = 1 to n do</span><br><span class="line">        print i + j</span><br></pre></td></tr></table></figure><br /><span class="math inline">\(f(n) = cn^2\)</span>.<br /><strong>Rule 4</strong>: Running time of nested loops with non-interacting variables multiplies.</p></li><li><p><strong>If statements.</strong><br /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for i = 1; i &lt; n; i = 2i do</span><br><span class="line">    for j = 1; j &lt; n; j = 2j do</span><br><span class="line">        if j = 2i then</span><br><span class="line">            for k = 0; k &lt; n; k = k + 1 do</span><br><span class="line">                &#123; constant number of elementary operations &#125;</span><br><span class="line">        else</span><br><span class="line">            for k = 1; k &lt; n; k = 3k do</span><br><span class="line">                &#123; constant number of elementary operations &#125;</span><br></pre></td></tr></table></figure></p><ul><li>The nested for-loop will contribute <span class="math inline">\(\lceil \lg n \rceil^2\)</span> toward running time.</li><li>Let <span class="math inline">\(m = \lceil \log n \rceil\)</span>, <span class="math inline">\(2^m \geq n\)</span>.</li><li>For every <span class="math inline">\(i \in \{1, 2, 2^2, \cdots, 2^{m - 2}\}\)</span>, there is exactly 1 <span class="math inline">\(j\)</span> that satisfy <span class="math inline">\(j = 2i\)</span>.</li><li>If-statement will go through <span class="math inline">\(m - 1\)</span> times, will not go through <span class="math inline">\(m^2 - (m - 1)\)</span> times.</li><li>Running time:<br /><span class="math display">\[T(n) = d(\lceil \log n \rceil^2 - \log n + 1)\lceil \log_3 n \rceil + c(\lceil \log n \rceil - 1)n\]</span></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> COMPSCI 220 Algorithms and Data Structures </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 奥克兰大学—西南大学合作课程 </tag>
            
            <tag> 外文 </tag>
            
            <tag> 算法分析与设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【COMPSCI 220】 Lecture 2 How to Measure Running Time?</title>
      <link href="/2025/11/19/25-11-4-2-COMPSCI220-2-run-time/"/>
      <url>/2025/11/19/25-11-4-2-COMPSCI220-2-run-time/</url>
      
        <content type="html"><![CDATA[<h2 id="some-big-numbers">Some Big Numbers</h2><h2 id="characterising-an-algorithm">Characterising an Algorithm</h2><ul><li>Domain of definition.</li><li>Correctness.</li><li>Resource use: running time and memory space.</li></ul><h3 id="resource-use">Resource Use</h3><ul><li><p>Time: Execution time of an algorithm.</p></li><li><p>Space: Memory space taken by an algorithm.</p></li><li><p>Machine model: A models of computation is a collection of assumptions/idealisation about the type of machines and system environment that the algorithm is running on.</p></li><li><p>Elementary operation: An elementary operation is the basic measuring unit of running time, and it represents any instruction whose execution time does not depend on the input size.</p></li><li><p>Running time: The running time of an algorithm <code>algo</code> running on input <code>inp</code> is defined as <span class="math inline">\(T(inp)\)</span> which is the number of elementary operations used when <code>inp</code> is fed into <code>algo</code>.</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> COMPSCI 220 Algorithms and Data Structures </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 奥克兰大学—西南大学合作课程 </tag>
            
            <tag> 外文 </tag>
            
            <tag> 算法分析与设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【COMPSCI 220】 Lecture 1 What is a Algorithm and Why Analyse It?</title>
      <link href="/2025/11/19/25-11-4-1-COMPSCI220-1-intro/"/>
      <url>/2025/11/19/25-11-4-1-COMPSCI220-1-intro/</url>
      
        <content type="html"><![CDATA[<h2 id="algorithms-and-data-structures">Algorithms and Data Structures</h2><ul><li><strong>Algorithms</strong> are sequences of clearly-stated rules that specify a step-by-step method for solving a given problem.</li><li><strong>Data structure</strong> are <strong>particular ways</strong> of <strong>storing and organising data</strong> in a computer system so that it can be used <strong>efficiently</strong>.</li></ul><h2 id="history">History</h2><h3 id="calculating-fibonacci-sequence">Calculating Fibonacci Sequence</h3><p>Approximately, <span class="math inline">\(F(n) \approx 1.618^n\)</span>.</p><h3 id="two-central-questions">Two Central Questions</h3><ol type="1"><li><strong>What is an algorithm?</strong><ul><li>A list of unambiguous and detailed rules that specify successive operations.</li><li>An idealised/abstracted version of a computer program.</li></ul></li><li><strong>What is a good algorithm?</strong><ul><li>Correctness.</li><li>Effciency.</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> COMPSCI 220 Algorithms and Data Structures </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 奥克兰大学—西南大学合作课程 </tag>
            
            <tag> 外文 </tag>
            
            <tag> 算法分析与设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【操作系统原理】 Lecture 18 信号量与管程</title>
      <link href="/2025/11/05/25-11-5-14-OpSys-18-sema-tube/"/>
      <url>/2025/11/05/25-11-5-14-OpSys-18-sema-tube/</url>
      
        <content type="html"><![CDATA[<h3 id="一信号量"><strong>一、信号量</strong></h3><p>信号量是由 Dijkstra 提出的更强大、更通用的同步原语。<br />#### <strong>1. 基本概念</strong><br />- <strong>定义</strong>：一个整型变量，只能通过两个标准的原子操作来访问：<code>P</code>操作（Proberen，测试/等待）和<code>V</code>操作（Verhogen，增加/信号）。<br />- <strong>组成</strong>：<br />- 一个整型值 <code>sem</code>。<br />- 一个等待队列 <code>q</code>，用于存放阻塞的进程。<br />#### <strong>2. P/V操作实现</strong><br /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Semaphore::P() &#123; <span class="comment">// 等待/申请资源</span></span><br><span class="line">    sem--;</span><br><span class="line">    <span class="keyword">if</span> (sem &lt; <span class="number">0</span>) &#123; <span class="comment">// 资源不足</span></span><br><span class="line">        Add this thread t to q; <span class="comment">// 将当前线程加入等待队列</span></span><br><span class="line">        block(p); <span class="comment">// 阻塞当前线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Semaphore::V() &#123; <span class="comment">// 释放/提供资源</span></span><br><span class="line">    sem++;</span><br><span class="line">    <span class="keyword">if</span> (sem &lt;= <span class="number">0</span>) &#123; <span class="comment">// 有线程在等待</span></span><br><span class="line">        Remove a thread t from q; <span class="comment">// 从等待队列中取出一个线程</span></span><br><span class="line">        wakeup(t); <span class="comment">// 唤醒该线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br />#### <strong>3. 信号量的分类与使用</strong><br />- <strong>二进制信号量</strong>：初值为0或1，用于实现<strong>互斥</strong>。<br />- <strong>实现互斥</strong>：为每个临界区设置一个初值为1的信号量<code>mutex</code>。<br /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mutex-&gt;P();</span><br><span class="line"><span class="comment">// Critical Section</span></span><br><span class="line">mutex-&gt;V();</span><br></pre></td></tr></table></figure><br />- <strong>计数信号量</strong>：初值大于0，用于<strong>条件同步</strong>或资源计数。<br />- <strong>实现条件同步</strong>：设置一个初值为0的信号量<code>condition</code>。<br /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待方</span></span><br><span class="line">condition-&gt;P(); <span class="comment">// 阻塞，直到另一方执行V操作</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 发信号方</span></span><br><span class="line">...</span><br><span class="line">condition-&gt;V(); <span class="comment">// 唤醒等待方</span></span><br></pre></td></tr></table></figure><br />#### <strong>4. 使用信号量的困难</strong><br />信号量功能强大但使用灵活，容易出错。程序员需要小心地安排<code>P</code>和<code>V</code>操作的顺序，否则容易导致死锁或逻辑错误。生产者-消费者问题的解决方案就体现了这种复杂性，需要三个信号量（<code>mutex</code>, <code>fullBuffers</code>, <code>emptyBuffers</code>）协同工作。</p><h3 id="二管程"><strong>二、管程</strong></h3><p>管程是一种更高级的同步抽象，旨在简化并发编程，将同步的复杂性封装起来。<br />#### <strong>1. 管程的组成与特性</strong><br />- <strong>定义</strong>：一个特殊的软件模块，由共享数据、对这些数据进行操作的一组过程以及一个初始化序列组成。<br />- <strong>核心特性</strong>：<strong>互斥性</strong>。管程保证在任何时刻，只有一个进程可以活跃在管程内。这个互斥性由编译器或操作系统保证，程序员无需显式使用锁。<br />- <strong>组成</strong>：<br />- <strong>共享数据</strong>：管程内所有过程访问的数据。<br />- <strong>过程</strong>：定义在管程内的函数，是外部进程访问共享数据的唯一接口。<br />- <strong>入口队列</strong>：当管程被占用时，其他试图进入的进程必须在此队列等待。<br />- <strong>条件变量</strong>：用于解决管程内的条件同步问题。<br />#### <strong>2. 条件变量</strong><br />- <strong>作用</strong>：当进程在管程内发现某个条件不满足时，可以通过条件变量进行等待，从而让出管程的控制权，允许其他进程进入。<br />- <strong>两个核心操作</strong>：<br />- <code>Wait(lock)</code>：释放锁，将当前进程阻塞在条件变量的等待队列上。<br />- <code>Signal()</code>：唤醒一个在该条件变量上等待的进程（如果有的话）。<br />- <strong>实现细节</strong>：<br /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Condition::Wait(lock) &#123;</span><br><span class="line">    numWaiting++;</span><br><span class="line">    Add this thread t to q;</span><br><span class="line">    release(lock); <span class="comment">// 必须先释放锁，否则死锁</span></span><br><span class="line">    schedule(); <span class="comment">// 阻塞自己</span></span><br><span class="line">    require(lock); <span class="comment">// 被唤醒后，重新获取锁</span></span><br><span class="line">&#125;</span><br><span class="line">Condition::Signal() &#123;</span><br><span class="line">    <span class="keyword">if</span> (numWaiting &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Remove a thread t from q;</span><br><span class="line">        wakeup(t);</span><br><span class="line">        numWaiting--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br />#### <strong>3. Hansen vs. Hoare 管程</strong><br />- <strong>Hansen风格</strong>：<code>Signal</code>操作是<strong>非阻塞</strong>的。发出信号的进程继续执行，直到它退出管程，被唤醒的进程才有机会进入。被唤醒的进程需要<strong>重新检查条件</strong>，因此<code>Wait</code>操作通常放在<code>while</code>循环中。<br />- <strong>Hoare风格</strong>：<code>Signal</code>操作是<strong>阻塞</strong>的。发出信号的进程立即被挂起，被唤醒的进程立即运行。这种方式效率更高，但实现更复杂。<br />#### <strong>4. 用管程解决生产者-消费者问题</strong><br />管程将互斥和同步逻辑封装在内部，使得代码更清晰、更安全。<br /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> &#123;</span></span><br><span class="line">    Lock lock;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    Condition notFull, notEmpty;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">Deposit</span><span class="params">(c)</span> &#123;</span><br><span class="line">        lock-&gt;Acquire();</span><br><span class="line">        <span class="keyword">while</span> (count == n) &#123; <span class="comment">// 使用while循环</span></span><br><span class="line">            notFull.Wait(&amp;lock);</span><br><span class="line">        &#125;</span><br><span class="line">        Add c to the buffer;</span><br><span class="line">        count++;</span><br><span class="line">        notEmpty.Signal(); <span class="comment">// 唤醒可能等待的消费者</span></span><br><span class="line">        lock-&gt;Release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Remove方法类似</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br />—<br />### <strong>三、经典同步问题</strong><br />#### <strong>1. 哲学家就餐问题</strong><br />- <strong>问题</strong>：5个哲学家围坐一桌，每人左右各有一只叉子。哲学家要么思考，要么吃饭。吃饭必须同时拿到左右两只叉子。<br />- <strong>挑战</strong>：如何设计算法避免死锁（所有哲学家都拿起左叉子，然后无限等待右叉子）和饥饿（有人永远拿不到叉子）。<br />- <strong>解决方案</strong>：<br />- <strong>方案1（失败）</strong>：每个哲学家先拿左叉子，再拿右叉子。会导致死锁。<br /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 5 <span class="comment">// 哲学家个数</span></span></span><br><span class="line">semaphore fork [<span class="number">5</span>] ; <span class="comment">// 信号量初值为1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">philosopher</span><span class="params">(<span class="type">int</span> i)</span>&#123; <span class="comment">// 同步执行五个这个函数</span></span><br><span class="line">    <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">        think();</span><br><span class="line">        P(fork[i]);</span><br><span class="line">        P(fork[(i + <span class="number">1</span>) % N]);</span><br><span class="line">        eat()</span><br><span class="line">        V(fork[i]);</span><br><span class="line">        V(fork[(i + <span class="number">1</span>) % N ]);       </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><br />- <strong>方案2（可行但低效）</strong>：使用一个额外的互斥信号量 <code>mutex</code>，确保一次只有一个哲学家能进入“拿叉子”的<strong>临界区</strong>。这解决了死锁，但破坏了并发性。<br /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 5 <span class="comment">// 哲学家个数</span></span></span><br><span class="line">semaphore fork[<span class="number">5</span>]; <span class="comment">// 信号量初值为 1</span></span><br><span class="line">semaphore mutex;</span><br><span class="line"><span class="type">void</span> <span class="title function_">philosopher</span><span class="params">(<span class="type">int</span> i)</span>&#123; <span class="comment">// 同步执行五个这个函数</span></span><br><span class="line">    <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">        think();</span><br><span class="line">        P(mutex)</span><br><span class="line">        P(fork[i]);</span><br><span class="line">        P(fork[(i + <span class="number">1</span>) % N]);</span><br><span class="line">        eat()</span><br><span class="line">        V(fork[i]);</span><br><span class="line">        V(fork[(i + <span class="number">1</span>) % N ]);</span><br><span class="line">        V(mutex)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><br />- <strong>方案3（可行且高效）</strong>：<strong>破坏循环等待</strong>条件。让奇数号哲学家先拿左叉子，偶数号哲学家先拿右叉子。这样就不会形成所有人都等待对方资源的环路。<br /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 5 <span class="comment">// 哲学家个数</span></span></span><br><span class="line">semaphore fork[<span class="number">5</span>] ; <span class="comment">// 信号量初值为1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">philosopher</span><span class="params">(<span class="type">int</span> i)</span>&#123; <span class="comment">// 同步执行五个这个函数</span></span><br><span class="line">    <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">        think();</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 偶数号先拿左边叉子</span></span><br><span class="line">            P(fork[i]);</span><br><span class="line">            P(fork[(i + <span class="number">1</span>) % N]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 奇数号先拿右边叉子</span></span><br><span class="line">            P(fork[(i + <span class="number">1</span>) % N]);</span><br><span class="line">            P(fork[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        eat()</span><br><span class="line">        <span class="comment">//归还叉子</span></span><br><span class="line">        V(fork[i]);</span><br><span class="line">        V(fork[(i + <span class="number">1</span>) % N ]);       </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><br />#### <strong>2. 读者-写者问题</strong><br />- <strong>问题</strong>：一个共享数据库，允许多个读者同时读，但写者必须<strong>独占访问</strong>。读者和写者<strong>不能同时访问</strong>。<br />- <strong>挑战</strong>：如何设计同步策略，并决定读者和写者的优先级。<br />- <strong>信号量解决方案（读者优先）</strong>：<br />- <strong>用信号量描述每个约束</strong><br />- 信号量 <code>WriteMutex = 1</code>，控制读写操作的互斥。<br />- 读者技术 <code>RCount = 0</code>，正在进行操作的读者数目。<br />- 信号量 <code>CountMutex = 1</code>，控制对读者技术的互斥修改。<br /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Writer */</span></span><br><span class="line">P(WriteMutex);</span><br><span class="line">write;</span><br><span class="line">V(WriteMutex);</span><br></pre></td></tr></table></figure><br /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Reader */</span></span><br><span class="line">P(CountMutex);</span><br><span class="line"><span class="keyword">if</span>(Rcount == <span class="number">0</span>)&#123;</span><br><span class="line">    P(WriteMutex);</span><br><span class="line">&#125;</span><br><span class="line">RCount++;</span><br><span class="line">V(CountMutex);</span><br></pre></td></tr></table></figure><br />- <strong>问题</strong>：如果读者源源不断，写者会饥饿。<br />- <strong>管程解决方案（更公平）</strong>：<br />- 两个基本方法<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Database::<span class="built_in">Read</span>() &#123;</span><br><span class="line">    <span class="comment">// Wait until no writers;</span></span><br><span class="line">    <span class="built_in">StartRead</span>();</span><br><span class="line">    database.<span class="built_in">read</span>();</span><br><span class="line">    <span class="comment">// check out – wake up waiting writers; </span></span><br><span class="line">    <span class="built_in">DoneRead</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Database::<span class="built_in">Write</span>() &#123;</span><br><span class="line">    <span class="comment">// Wait until no readers/writers;</span></span><br><span class="line">    <span class="built_in">StartRead</span>();</span><br><span class="line">    database.<span class="built_in">write</span>();</span><br><span class="line">    <span class="comment">// check out – wake up waiting readers/writers; </span></span><br><span class="line">    <span class="built_in">DoneRead</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br />- 管程内部维护更精细的状态（<code>AR</code>，<code>AW</code>，<code>WR</code>，<code>WW</code>）。<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AR = <span class="number">0</span>;     <span class="comment">// # of active readers</span></span><br><span class="line">AW = <span class="number">0</span>;           <span class="comment">// # of active writers</span></span><br><span class="line">WR = <span class="number">0</span>;    <span class="comment">// # of waiting readers</span></span><br><span class="line">WW = <span class="number">0</span>;           <span class="comment">// # of waiting writers</span></span><br><span class="line">Lock lock;</span><br><span class="line">Condition okToRead;</span><br><span class="line">Condition okToWrite;</span><br></pre></td></tr></table></figure><br />- 通过条件变量 <code>okToRead</code> 和 <code>okToWrite</code> 来精确控制读者和写者的等待与唤醒。<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Private <span class="title">Database::StartRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.<span class="built_in">Acquire</span>();</span><br><span class="line">    <span class="keyword">while</span> ((AW+WW) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        WR++;</span><br><span class="line">        okToRead.<span class="built_in">wait</span>(&amp;lock);</span><br><span class="line">        WR--;</span><br><span class="line">    &#125;</span><br><span class="line">    AR++;</span><br><span class="line">    lock.<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Private <span class="title">Database::DoneRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.<span class="built_in">Acquire</span>();</span><br><span class="line">    AR--;</span><br><span class="line">    <span class="keyword">if</span> (AR ==<span class="number">0</span> &amp;&amp; WW &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        okToWrite.<span class="built_in">signal</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    lock.<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Private <span class="title">Database::StartWrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.<span class="built_in">Acquire</span>();</span><br><span class="line">    <span class="keyword">while</span> ((AW+AR) &gt; <span class="number">0</span>)  &#123;</span><br><span class="line">        WW++;</span><br><span class="line">        okToWrite.<span class="built_in">wait</span>(&amp;lock);</span><br><span class="line">        WW--;</span><br><span class="line">    &#125;</span><br><span class="line">    AW++;</span><br><span class="line">    lock.<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Private <span class="title">Database::DoneWrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.<span class="built_in">Acquire</span>(); <span class="comment">// 加锁</span></span><br><span class="line">    AW--;</span><br><span class="line">    <span class="keyword">if</span> (WW &gt; <span class="number">0</span>) &#123; <span class="comment">// 查看有没有进程等着写</span></span><br><span class="line">        okToWrite.<span class="built_in">signal</span>(); <span class="comment">// 发出可写信号 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (WR &gt; <span class="number">0</span>) &#123; <span class="comment">//如果没有进程可写，再看有没有进程读</span></span><br><span class="line">        okToRead.<span class="built_in">broadcast</span>(); <span class="comment">// 向所有读者广播可读</span></span><br><span class="line">    &#125;</span><br><span class="line">    lock.<span class="built_in">Release</span>(); <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br />- 可以轻松实现不同的优先级策略（如写者优先、公平策略），只需调整 <code>StartRead</code>，<code>DoneRead</code>，<code>StartWrite</code>，<code>DoneWrite</code>中的唤醒逻辑即可。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> 操作系统原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【操作系统原理】 Lecture 17 同步互斥</title>
      <link href="/2025/11/05/25-11-5-13-OpSys-17-sync-excl/"/>
      <url>/2025/11/05/25-11-5-13-OpSys-17-sync-excl/</url>
      
        <content type="html"><![CDATA[<h3 id="一背景与并发问题"><strong>一、背景与并发问题</strong></h3><h4 id="并发的好处与挑战"><strong>1. 并发的好处与挑战</strong></h4><ul><li><strong>好处</strong>：并发执行可以充分利用多核CPU资源，提高系统吞吐量和响应速度。</li><li><strong>挑战</strong>：并发进程共享资源时，如果协调不当，会导致<strong>竞态条件</strong>，即程序的最终结果依赖于进程执行的相对时序，从而产生不可预测的错误。<br />#### <strong>2. 竞态条件示例：PID分配</strong><br />幻灯片中给出了一个经典的例子：两个进程A和B同时尝试获取下一个进程ID（<code>next_pid</code>）。</li><li><strong>错误场景</strong>：<ol type="1"><li>进程A加载<code>next_pid</code>（值为100）到寄存器。</li><li><strong>发生上下文切换</strong>，进程B运行。</li><li>进程B加载<code>next_pid</code>（仍为100），将其分配给<code>new_pid</code>，然后递增<code>next_pid</code>为101并写回。</li><li><strong>上下文切换回进程A</strong>。</li><li>进程A继续执行，将寄存器中的100分配给它的<code>new_pid</code>，然后递增<code>next_pid</code>为101并写回。</li></ol></li><li><strong>结果</strong>：两个进程获得了相同的PID（100），系统状态出错。</li><li><h2 id="根本原因load---store---inc---store这个序列不是一个原子操作它在执行过程中被中断导致了不一致的状态"><strong>根本原因</strong>：<code>load -&gt; store -&gt; inc -&gt; store</code>这个序列不是一个<strong>原子操作</strong>，它在执行过程中被中断，导致了不一致的状态。</h2><h3 id="二现实生活中的同步问题与临界区"><strong>二、现实生活中的同步问题与临界区</strong></h3><h4 id="家庭采购协调问题"><strong>1. 家庭采购协调问题</strong></h4>这个生动的例子模拟了两个线程（丈夫和妻子）协调购买面包的场景，揭示了同步问题的复杂性。</li><li><strong>问题</strong>：两人约定，如果家里没面包，就去买。但可能两人都发现没面包，然后都去买，导致买了两个面包。</li><li><strong>方案演进</strong>：<ul><li><strong>方案一（检查再标记）</strong>：<code>if (nobread) &#123; if (noNote) &#123; leave Note; buy bread; remove Note; &#125; &#125;</code>。失败，因为“检查”和“标记”之间可能被中断。</li><li><strong>方案二（先标记再检查）</strong>：<code>leave Note; if (nobread) &#123; ... &#125;</code>。失败，可能导致两人都留下便条，然后都去买。</li><li><strong>方案三（双标记）</strong>：使用两个便条。仍然复杂且容易出错。</li></ul></li><li><strong>最终解决方案（方案五）</strong>：引入一个<strong>锁</strong>（<code>breadlock</code>）。<br /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">breadlock.Acquire(); <span class="comment">// 获取锁</span></span><br><span class="line"><span class="keyword">if</span> (nobread) &#123;</span><br><span class="line">    buy bread; <span class="comment">// 临界区</span></span><br><span class="line">&#125;</span><br><span class="line">breadlock.Release(); <span class="comment">// 释放锁</span></span><br></pre></td></tr></table></figure><br />这个方案将“检查并购买”这个不可分割的操作保护起来，确保任何时候只有一个人能执行。<br />#### <strong>2. 临界区</strong></li><li><strong>定义</strong>：进程中访问<strong>共享资源</strong>的一段代码。</li><li><strong>相关区域</strong>：<ul><li><strong>进入区</strong>：在进入临界区前，检查是否可以安全进入，如果不能则等待。</li><li><strong>退出区</strong>：在离开临界区后，清理状态，允许其他进程进入。</li><li><strong>剩余区</strong>：进程的其他代码。<br />#### <strong>3. 临界区的访问规则</strong><br />一个正确的临界区解决方案必须满足以下四个条件：</li></ul></li></ul><ol type="1"><li><strong>空闲则入</strong>：如果临界区空闲，必须允许一个请求进入的进程立即进入。</li><li><strong>忙则等待</strong>：如果临界区正在被使用，其他请求进入的进程必须等待。</li><li><strong>有限等待</strong>：一个进程不能无限期地被禁止进入临界区（避免饥饿）。</li><li><h2 id="让权等待可选但推荐等待进入临界区的进程应该放弃cpu进入阻塞而不是忙等待以浪费cpu时间"><strong>让权等待</strong>（可选，但推荐）：等待进入临界区的进程应该放弃CPU（进入阻塞），而不是忙等待，以浪费CPU时间。</h2><h3 id="三临界区的实现方法"><strong>三、临界区的实现方法</strong></h3>幻灯片介绍了三种不同层次的实现方法，从简单粗暴到高效抽象。<br />#### <strong>方法1：禁用硬件中断</strong></li></ol><ul><li><strong>原理</strong>：在单核CPU上，进程切换是由时钟中断触发的。通过在进入临界区前禁用所有中断，在退出后重新开启，可以保证临界区代码不会被中断，从而原子执行。</li><li><strong>实现</strong>：<br /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">local_irq_save(flags); <span class="comment">// 保存状态并禁用中断</span></span><br><span class="line"><span class="comment">// critical section</span></span><br><span class="line">local_irq_restore(flags); <span class="comment">// 恢复状态并开启中断</span></span><br></pre></td></tr></table></figure></li><li><strong>缺点</strong>：<ul><li><strong>滥用特权</strong>：这是一个非常粗暴的方法，应该只由内核在极少数情况下使用。</li><li><strong>不适用于多处理器</strong>：禁用一个CPU的中断，其他CPU上的进程仍然可以访问临界区。</li><li><strong>影响系统响应</strong>：长时间禁用中断会导致系统对其他事件（如I/O）失去响应。<br />#### <strong>方法2：基于软件的解决方法</strong><br />这种方法不依赖特殊硬件指令，仅通过共享变量和算法来实现同步。</li></ul></li><li><strong>Peterson算法</strong>（适用于两个进程）：<br /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 共享变量</span></span><br><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>] = &#123;<span class="literal">false</span>, <span class="literal">false</span>&#125;;</span><br><span class="line"><span class="type">int</span> turn;</span><br><span class="line"><span class="comment">// 进程i的代码</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    flag[i] = <span class="literal">true</span>;   <span class="comment">// 我想进入</span></span><br><span class="line">    turn = j;         <span class="comment">// 礼让，让对方先</span></span><br><span class="line">    <span class="keyword">while</span> (flag[j] &amp;&amp; turn == j); <span class="comment">// 如果对方也想进且轮到对方，则等待</span></span><br><span class="line">    <span class="comment">// critical section</span></span><br><span class="line">    flag[i] = <span class="literal">false</span>;  <span class="comment">// 我出来了</span></span><br><span class="line">    <span class="comment">// remainder section</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></li><li><strong>优点</strong>：证明了纯软件解决方案的可行性。</li><li><strong>缺点</strong>：<ul><li><strong>复杂</strong>：算法逻辑复杂，难以理解和验证正确性。</li><li><strong>扩展性差</strong>：难以扩展到N个进程。</li><li><strong>忙等待</strong>：<code>while</code>循环会持续消耗CPU时间。<br />#### <strong>方法3：更高级的抽象方法（硬件支持）</strong><br />这是现代操作系统采用的主流方法，它结合了特殊的硬件原子指令和操作系统提供的数据结构。</li></ul></li><li><strong>硬件原子指令</strong>：<ul><li><strong>Test-and-Set (TS)</strong>：原子地读取内存位置并设置为<code>true</code>。</li><li><strong>Exchange</strong>：原子地交换两个内存位置的值。</li></ul></li><li><strong>自旋锁</strong>：<ul><li>使用TS指令实现。<code>Acquire</code>操作在一个循环中不断执行TS，直到锁被释放。</li><li><strong>缺点</strong>：仍然是忙等待，适用于临界区非常短（持有锁时间小于一次上下文切换时间）的场景。</li></ul></li><li><strong>无忙等待锁</strong>：<ul><li>在自旋锁的基础上改进。当获取锁失败时，不忙等待，而是将当前进程加入等待队列并<strong>阻塞</strong>（调用<code>schedule()</code>），让出CPU。</li><li>当锁被释放时，<code>Release</code>操作会从等待队列中唤醒一个进程。</li></ul></li><li><strong>优点</strong>：<ul><li><strong>高效</strong>：避免了忙等待，提高了CPU利用率。</li><li><strong>简单易用</strong>：为程序员提供了简单、高级的同步原语（如锁、信号量）。</li><li><strong>通用性强</strong>：适用于多处理器环境。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> 操作系统原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【操作系统原理】 Lecture 16 实验六 调度器</title>
      <link href="/2025/11/05/25-11-5-12-OpSys-16-exp6-sche/"/>
      <url>/2025/11/05/25-11-5-12-OpSys-16-exp6-sche/</url>
      
        <content type="html"><![CDATA[<h3 id="一总体介绍与目标"><strong>一、总体介绍与目标</strong></h3><h4 id="实验背景"><strong>1. 实验背景</strong></h4><p>在Lab5中，ucore已经能够创建和管理用户进程，但其调度机制非常原始：<code>idle</code>进程通过遍历进程池来寻找下一个可运行的进程，效率低下且缺乏公平性。Lab6的目标是<strong>重新设计并实现一个通用、高效的调度框架</strong>。<br />#### <strong>2. 实验目标</strong><br />- <strong>理解调度管理机制</strong>：掌握调度的完整流程，包括触发、选择、切换。<br />- <strong>熟悉ucore调度框架</strong>：理解其模块化设计，特别是<code>sched_class</code>接口。<br />- <strong>实现经典调度算法</strong>：<br />- 分析并理解<strong>Round Robin (RR)</strong> 算法的实现。<br />- 亲手实现<strong>Stride调度算法</strong>，这是一种公平的比例份额调度算法。<br />—<br />### <strong>二、调度过程</strong><br />调度过程是调度器工作的核心流程，可以分解为一系列标准化的步骤：<br />1. <strong>触发</strong>：某个事件发生，表明需要进行调度决策。例如：<br />- 时钟中断，当前进程时间片用完。<br />- 当前进程因I/O阻塞。<br />- 一个新进程被创建，变为就绪态。<br />2. <strong>入队</strong>：如果当前进程仍然是<code>PROC_RUNNABLE</code>状态，则需要将其重新放回就绪队列，等待下一次调度。<br />3. <strong>选取</strong>：调度算法的核心。从就绪队列中，根据特定策略（如RR、Stride）选择下一个要运行的进程。<br />4. <strong>出队</strong>：将选中的进程从就绪队列中移除，准备投入运行。<br />5. <strong>切换</strong>：执行底层的上下文切换（<code>switch_to</code>），将CPU控制权交给选中的新进程。<br />—<br />### <strong>三、调度算法支撑框架</strong><br />这是本实验最核心的设计，它将<strong>调度机制</strong>与<strong>调度策略</strong>分离，使得调度算法可以像插件一样被替换。<br />#### <strong>1. 关键抽象：<code>sched_class</code></strong><br />这是一个结构体，定义了一组函数指针，构成了所有调度算法必须实现的接口：<br /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">void</span> (*init)(<span class="keyword">struct</span> run_queue *rq);              <span class="comment">// 初始化调度队列</span></span><br><span class="line">    <span class="type">void</span> (*enqueue)(<span class="keyword">struct</span> run_queue *rq, ...);      <span class="comment">// 进程入队</span></span><br><span class="line">    <span class="type">void</span> (*dequeue)(<span class="keyword">struct</span> run_queue *rq, ...);      <span class="comment">// 进程出队</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *(*<span class="title">pick_next</span>)(<span class="keyword">struct</span> <span class="title">run_queue</span> *<span class="title">rq</span>);</span> <span class="comment">// 选择下一个进程</span></span><br><span class="line">    <span class="type">void</span> (*proc_tick)(<span class="keyword">struct</span> run_queue *rq, ...);    <span class="comment">// 时钟中断处理</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br />#### <strong>2. 调度主循环：<code>schedule()</code>函数</strong><br />这个函数是调度器的入口，它不关心具体算法，只负责调用<code>sched_class</code>提供的接口：<br /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">schedule</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 关中断，保证调度过程的原子性</span></span><br><span class="line">    <span class="comment">// 2. 重置当前进程的need_resched标志</span></span><br><span class="line">    <span class="comment">// 3. 如果当前进程仍可运行，调用enqueue将其入队</span></span><br><span class="line">    <span class="comment">// 4. 调用pick_next选择下一个进程</span></span><br><span class="line">    <span class="comment">// 5. 如果pick_next返回NULL，则选择idle进程</span></span><br><span class="line">    <span class="comment">// 6. 如果新进程不是当前进程，则调用proc_run进行切换</span></span><br><span class="line">    <span class="comment">// 7. 开中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br />#### <strong>3. 调度点</strong><br />调度点是指触发调度函数<code>schedule()</code>的时机，主要包括：<br />- <strong>时钟中断处理函数</strong>：调用<code>proc_tick</code>，更新进程时间片，如果时间片用完，设置<code>need_resched</code>标志，并在中断返回前检查该标志，决定是否调用<code>schedule</code>。<br />- <strong>进程状态改变时</strong>：如<code>sleep</code>（阻塞）、<code>wakeup</code>（唤醒）、<code>exit</code>（退出）等函数的末尾，通常会调用<code>schedule</code>。<br />—<br />### <strong>四、Round Robin调度算法</strong><br />RR算法是ucore默认实现的调度算法，它为每个进程分配固定的时间片。<br />#### <strong>1. 数据结构</strong><br />- <strong><code>run_queue</code></strong>：使用一个简单的双向链表<code>run_list</code>来维护就绪进程。<br />- <strong><code>max_time_slice</code></strong>：存储每个进程的默认时间片大小。<br />#### <strong>2. 接口实现</strong><br />- <strong><code>RR_init</code></strong>：初始化<code>run_list</code>链表。<br />- <strong><code>RR_enqueue</code></strong>：将进程添加到链表<strong>尾部</strong>，保证FIFO顺序。如果进程时间片为0或超限，则重置为<code>max_time_slice</code>。<br />- <strong><code>RR_dequeue</code></strong>：将进程从链表中移除。<br />- <strong><code>RR_pick_next</code></strong>：选择链表<strong>头部</strong>的进程。<br />- <strong><code>RR_proc_tick</code></strong>：每次时钟中断，将当前进程的<code>time_slice</code>减1。如果减为0，则设置<code>need_resched</code>标志，触发调度。<br />—<br />### <strong>五、Stride调度算法</strong><br />这是本实验要求学生亲手实现的算法，它旨在为不同优先级的进程提供按比例的CPU份额。<br />#### <strong>1. 算法原理</strong><br />- <strong>核心思想</strong>：每个进程都有一个<code>pass</code>值（表示其当前调度优先级）和一个<code>stride</code>值（每次运行后<code>pass</code>的增加量）。<br />- <strong><code>stride</code>的计算</strong>：<code>stride = BIG_STRIDE / priority</code>。优先级越高，<code>stride</code>值越小，<code>pass</code>增长越慢，被选中的频率越高。<br />- <strong>调度选择</strong>：<strong>总是选择<code>pass</code>值最小的进程</strong>投入运行。<br />- <strong><code>pass</code>的更新</strong>：当一个进程运行完一个时间片后，其<code>pass</code>值增加其<code>stride</code>值。<br />#### <strong>2. 实现要点</strong><br />- <strong>数据结构</strong>：为了高效地找到<code>pass</code>值最小的进程，不能使用简单的链表。实验推荐使用<strong>斜堆</strong>，一种自调整的二叉堆，其插入和删除操作的平均时间复杂度为O(log n)。<br />- <strong>PCB扩展</strong>：需要在<code>proc_struct</code>中添加Stride算法所需的字段：<br />- <code>lab6_stride</code>：进程的步长。<br />- <code>lab6_priority</code>：进程的优先级。<br />- <code>lab6_run_pool</code>：作为斜堆的节点。<br />- <strong>接口实现</strong>：<br />- <strong><code>init</code></strong>：初始化斜堆。<br />- <strong><code>enqueue</code></strong>：将进程节点插入斜堆。<br />- <strong><code>dequeue</code></strong>：从斜堆中移除进程节点。<br />- <strong><code>pick_next</code></strong>：获取斜堆的根节点，即<code>pass</code>值最小的进程。<br />- <strong><code>proc_tick</code></strong>：与RR类似，时间片用完后设置<code>need_resched</code>。<br />- <strong>关键问题</strong>：<br />- <strong>整数溢出</strong>：<code>pass</code>值会不断增长，可能导致溢出。解决方案是使用有符号整数比较<code>pass</code>差值，或者在<code>pass</code>值过大时对所有进程的<code>pass</code>进行一次归一化减法。<br />- <strong>算法绑定</strong>：完成实现后，需要在<code>sched_init</code>函数中将<code>sched_class</code>指针指向自己实现的Stride调度类。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> 操作系统原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【操作系统原理】 Lecture 15 处理机调度</title>
      <link href="/2025/11/05/25-11-5-10-OpSys-15-proc-sche/"/>
      <url>/2025/11/05/25-11-5-10-OpSys-15-proc-sche/</url>
      
        <content type="html"><![CDATA[<h3 id="一处理机调度概念"><strong>一、处理机调度概念</strong></h3><h4 id="调度的本质"><strong>1. 调度的本质</strong></h4><ul><li><strong>CPU资源的时分复用</strong>：通过在多个进程之间快速切换CPU，使得宏观上看起来多个进程在同时运行，从而提高系统资源利用率。</li><li><strong>调度时机</strong>：调度决策发生的时刻，主要包括：<ul><li><strong>时钟中断</strong>：当前进程的时间片用完。</li><li><strong>I/O中断</strong>：一个进程因等待I/O而阻塞，另一个进程变为就绪。</li><li><strong>系统调用</strong>：进程主动放弃CPU（如<code>sleep</code>）或创建新进程。</li><li><strong>进程退出</strong>：当前进程执行完毕。<br />#### <strong>2. 调度策略</strong></li></ul></li><li><strong>非抢占式调度</strong>：一旦CPU分配给一个进程，该进程会一直使用CPU，直到它自己主动释放（如阻塞或结束）。早期系统常用。</li><li><h2 id="抢占式调度操作系统可以强制剥夺当前进程的cpu使用权并将其分配给另一个更重要或更紧急的进程现代通用操作系统普遍采用"><strong>抢占式调度</strong>：操作系统可以强制剥夺当前进程的CPU使用权，并将其分配给另一个更重要或更紧急的进程。现代通用操作系统普遍采用。</h2><h3 id="二调度准则"><strong>二、调度准则</strong></h3>评价一个调度算法好坏的标准，通常从以下几个维度衡量：</li></ul><ol type="1"><li><strong>CPU利用率</strong>：保持CPU尽可能忙碌。</li><li><strong>吞吐量</strong>：单位时间内完成的进程数量。</li><li><strong>周转时间</strong>：从进程提交到完成的总时间（包括等待和执行）。</li><li><strong>等待时间</strong>：进程在就绪队列中等待的总时间。</li><li><strong>响应时间</strong>：从提交请求到首次产生响应的时间，对交互式系统尤为重要。</li><li><h2 id="公平性确保每个进程都能获得合理的cpu时间避免饥饿"><strong>公平性</strong>：确保每个进程都能获得合理的CPU时间，避免“饥饿”。</h2><h3 id="三调度算法"><strong>三、调度算法</strong></h3><h4 id="经典批处理调度算法"><strong>1. 经典批处理调度算法</strong></h4></li></ol><ul><li><strong>先来先服务</strong>：<ul><li><strong>原理</strong>：按照进程到达的先后顺序进行调度。</li><li><strong>优点</strong>：简单，公平。</li><li><strong>缺点</strong>：效率低，一个长进程会使后面所有短进程等待很久（护航效应）。</li></ul></li><li><strong>短进程优先</strong>：<ul><li><strong>原理</strong>：选择估计执行时间最短的进程。</li><li><strong>优点</strong>：平均等待时间和周转时间最优。</li><li><strong>缺点</strong>：<ul><li><strong>长进程饥饿</strong>：长进程可能长时间得不到执行。</li><li><strong>执行时间预估困难</strong>：难以准确预测进程的执行时间。</li><li><strong>实现</strong>：通常使用指数平均法进行预估：<code>τ_&#123;n+1&#125; = α * t_n + (1 - α) * τ_n</code>。</li></ul></li></ul></li><li><strong>最高响应比优先</strong>：<ul><li><strong>原理</strong>：选择响应比最高的进程。<code>响应比 = (等待时间 + 要求服务时间) / 要求服务时间</code>。</li><li><strong>优点</strong>：兼顾了等待时间和执行时间，避免了长进程饥饿。<br />#### <strong>2. 经典交互式调度算法</strong></li></ul></li><li><strong>时间片轮转</strong>：<ul><li><strong>原理</strong>：将所有就绪进程按FCFS原则排成一个队列，每次调度队首进程，使其运行一个固定的时间片。如果时间片结束进程未完成，则将其放回队尾。</li><li><strong>关键</strong>：时间片大小的选择。时间片太长退化为FCFS，太短则进程切换开销过大。</li></ul></li><li><strong>多级反馈队列</strong>：<ul><li><strong>原理</strong>：设置多个就绪队列，每个队列有不同的优先级和时间片大小。新进程进入最高优先级队列，如果用完时间片未完成则降入下一级队列。</li><li><strong>优点</strong>：兼顾了交互式任务和批处理任务的需求，是现代操作系统常用的调度算法。<br />#### <strong>3. ucore的调度框架</strong><br />ucore设计了一个灵活的、可扩展的调度框架：</li></ul></li><li><strong>调度队列</strong>：<code>run_queue</code>结构体，包含一个进程链表、进程数量和最大时间片。</li><li><strong>调度算法接口</strong>：<code>sched_class</code>结构体，定义了一组函数指针（如<code>enqueue</code>, <code>dequeue</code>, <code>pick_next</code>），将调度算法的具体实现与调度框架解耦。</li><li><strong>调度流程</strong>：<ol type="1"><li><strong>触发调度</strong>：在时钟中断等时机，调用<code>sched_class</code>的<code>proc_tick</code>函数更新进程时间片。</li><li><strong>选择进程</strong>：调用<code>pick_next</code>从就绪队列中选择下一个要运行的进程。</li><li><h2 id="进程切换调用switch_to完成上下文切换"><strong>进程切换</strong>：调用<code>switch_to</code>完成上下文切换。</h2><h3 id="四实时调度"><strong>四、实时调度</strong></h3>实时调度关注任务必须在指定的截止时间前完成。<br />#### <strong>1. 实时系统分类</strong></li></ol></li><li><strong>硬实时系统</strong>：必须在截止时间内完成任务，否则会造成灾难性后果（如飞行控制）。</li><li><strong>软实时系统</strong>：应该尽快完成任务，但偶尔超时是可以接受的（如视频播放）。<br />#### <strong>2. 实时任务</strong></li><li><strong>周期性任务</strong>：在固定的时间间隔内重复执行。</li><li><strong>非周期性任务</strong>：由随机事件触发。<br />#### <strong>3. 可调度性</strong></li><li><strong>定义</strong>：判断一个实时任务集是否能在其截止时间前全部完成。</li><li><strong>Rate Monotonic (RM) 算法</strong>：一种静态优先级调度算法，任务的周期越短，优先级越高。</li><li><h2 id="earliest-deadline-first-edf-算法一种动态优先级调度算法截止时间越早的任务优先级越高edf在理论上是最优的单处理器实时调度算法"><strong>Earliest Deadline First (EDF) 算法</strong>：一种动态优先级调度算法，截止时间越早的任务，优先级越高。EDF在理论上是最优的单处理器实时调度算法。</h2><h3 id="五多处理器调度"><strong>五、多处理器调度</strong></h3>在多核或多处理器系统中，调度变得更加复杂。</li><li><strong>对称多处理</strong>：所有处理器地位平等，共享内存，每个处理器都可以运行调度器，从公共的就绪队列中选择进程。</li><li><strong>进程分配</strong>：<ul><li><strong>单一就绪队列</strong>：所有处理器共享一个就绪队列，需要加锁保护，可能成为瓶颈。</li><li><h2 id="每个处理器一个队列避免了锁竞争但可能导致负载不均衡"><strong>每个处理器一个队列</strong>：避免了锁竞争，但可能导致负载不均衡。</h2><h3 id="六优先级反转"><strong>六、优先级反转</strong></h3>这是一个在实时系统中非常经典且危险的问题。<br />#### <strong>1. 问题定义</strong></li></ul></li><li><strong>现象</strong>：一个高优先级任务（T1）因等待一个被低优先级任务（T3）占有的资源而被阻塞，而一个中优先级任务（T2）抢占了T3，导致T1的等待时间被T2延长，甚至超过其截止时间。</li><li><strong>本质</strong>：高优先级任务被一个本不该影响它的中优先级任务间接阻塞。<br />#### <strong>2. 解决方案</strong></li><li><strong>优先级继承</strong>：<ul><li><strong>原理</strong>：当高优先级任务T1尝试获取已被低优先级任务T3持有的锁时，系统临时将T3的优先级提升到T1的级别，直到T3释放锁。</li><li><strong>效果</strong>：T3可以尽快执行并释放锁，从而让T1能够继续执行，避免了T2的干扰。</li></ul></li><li><strong>优先级天花板协议</strong>：<ul><li><strong>原理</strong>：为每个资源设置一个“天花板优先级”（所有可能访问该资源的任务的最高优先级）。任何任务成功获取该锁后，其优先级会被立即提升到这个天花板优先级。</li><li><strong>效果</strong>：比优先级继承更主动，能彻底避免优先级反转的发生，但可能降低并发性。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> 操作系统原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【操作系统原理】 Lecture 13 线程控制</title>
      <link href="/2025/11/05/25-11-5-8-OpSys-13-core-thr-man/"/>
      <url>/2025/11/05/25-11-5-8-OpSys-13-core-thr-man/</url>
      
        <content type="html"><![CDATA[<h3 id="一实验目标与概述"><strong>一、实验目标与概述</strong></h3><h4 id="核心目标"><strong>1. 核心目标</strong></h4><p>本实验的核心目标是让学生深入理解内核线程的整个生命周期管理，具体包括：<br />- <strong>线程创建与执行</strong>：了解一个内核线程如何从无到有，并被调度执行。<br />- <strong>线程状态管理</strong>：理解线程在<code>Ready</code>（就绪）、<code>Running</code>（运行）、<code>Waiting</code>（等待）等状态间的转换。<br />- <strong>线程切换与调度</strong>：掌握CPU控制权如何从一个线程转移到另一个线程，这是多任务操作系统的基石。<br />#### <strong>2. 练习任务</strong><br />实验通过三个循序渐进的练习来达成目标：<br />- <strong>练习1</strong>：分配并初始化一个进程控制块（PCB），这是线程存在的基石。<br />- <strong>练习2</strong>：为新创建的内核线程分配资源，主要是内核栈和执行上下文。<br />- <strong>练习3</strong>：理解并完成进程切换，这是实现并发执行的关键。<br />—<br />### <strong>二、关键数据结构</strong><br />内核线程的管理依赖于两个核心数据结构：<strong>线程控制块</strong>和<strong>线程控制块链表</strong>。<br />#### <strong>1. 线程控制块</strong><br />在ucore中，线程和进程使用统一的数据结构<code>proc_struct</code>来表示，可以称之为TCB（Thread Control Block）。它包含了管理一个线程所需的所有信息：<br />- <strong>进程标识</strong>：<code>pid</code>（进程ID）、<code>state</code>（进程状态）、<code>parent</code>（父进程指针）、<code>name</code>（进程名）。<br />- <strong>执行上下文</strong>：<code>context</code>结构体，保存了线程在内核态下切换时需要保存的寄存器（如<code>eip</code>, <code>esp</code>, <code>ebp</code>等）。<br />- <strong>内核栈</strong>：<code>kstack</code>指向该线程的内核栈底。每个线程都有自己独立的内核栈。<br />- <strong>内存管理</strong>：<code>mm</code>指针指向<code>mm_struct</code>，用于管理该线程的虚拟地址空间（对于内核线程，此为空）。<br />- <strong>状态与调度</strong>：<code>state</code>（状态）、<code>runs</code>（运行时间片）、<code>need_resched</code>（是否需要重新调度标志）。<br />- <strong>链表节点</strong>：<code>list_link</code>用于将线程加入全局链表，<code>hash_link</code>用于加入哈希表，便于快速查找。<br />#### <strong>2. 线程控制块链表</strong><br />ucore使用两种方式组织所有的TCB：<br />- <strong>全局链表</strong>：<code>proc_list</code>是一个双向链表，将所有创建的线程（PCB）链接起来，便于遍历。<br />- <strong>哈希表</strong>：<code>hash_list</code>是一个哈希表，通过PID可以快速地查找到对应的TCB，提高了查找效率。<br />—<br />### <strong>三、执行流程</strong><br />实验的核心流程是创建并执行两个特殊的内核线程：<code>idleproc</code>（空闲线程）和<code>initproc</code>（初始化线程）。<br />#### <strong>1. 创建第0个内核线程</strong><br /><code>idleproc</code>是系统创建的第一个线程，其作用是在没有其他就绪线程时运行，执行一些空闲任务或使CPU进入低功耗状态。<br />- <strong>初始化位置</strong>：在<code>proc_init()</code>函数中。<br />- <strong>创建过程</strong>：<br />1. <strong>分配内存</strong>：直接使用<code>kmalloc()</code>为<code>idleproc</code>分配<code>proc_struct</code>结构体空间。<br />2. <strong>手动初始化</strong>：由于是第一个线程，没有父进程，所以手动设置其关键属性：<br />- <code>pid = 0</code>；<code>state = PROC_RUNNABLE</code>（就绪态）。<br />- <code>kstack = bootstack</code>（使用启动时预留的栈）。<br />- <code>need_resched = 1</code>（标记为需要调度，以便尽快切换到<code>initproc</code>）。<br />- 设置名称为”idle”。<br />#### <strong>2. 创建第1个内核线程</strong><br /><code>initproc</code>是系统的第一个真正意义上的工作线程，它将执行一些初始化任务，并最终加载第一个用户进程。<br />- <strong>创建方式</strong>：通过调用<code>do_fork()</code>函数创建，这是一个通用的创建线程/进程的函数。<br />- <strong>创建过程</strong>：<br />1. <strong>分配PCB</strong>：<code>do_fork()</code>内部调用<code>alloc_proc()</code>为新线程分配并初始化一个<code>proc_struct</code>。<br />2. <strong>复制父进程上下文</strong>：<code>idleproc</code>作为父进程，其上下文被复制给<code>initproc</code>。<br />3. <strong>设置内核栈</strong>：调用<code>setup_stack()</code>为<code>initproc</code>分配一个新的内核栈。<br />4. <strong>设置Trapframe</strong>：这是最关键的一步，通过<code>copy_thread()</code>函数完成。Trapframe是中断发生时保存在内核栈上的寄存器集合，它决定了线程从内核态返回用户态（或继续在内核态执行）时的CPU状态。<br />- <strong>设置段寄存器</strong>：<code>tf_cs</code>, <code>tf_ds</code>等设置为内核段（<code>KERNEL_CS</code>, <code>KERNEL_DS</code>）。<br />- <strong>传递执行参数</strong>：将要执行的函数<code>fn</code>和参数<code>arg</code>存入<code>tf_ebx</code>和<code>tf_edx</code>。<br />- <strong>设置入口点</strong>：将<code>tf_eip</code>设置为<code>kernel_thread_entry</code>，这是一个汇编入口，它会从<code>tf_ebx</code>和<code>tf_edx</code>中取出函数和参数并调用。<br />- <strong>设置返回路径</strong>：将<code>context.eip</code>设置为<code>forkret</code>，<code>context.esp</code>指向trapframe。这样，当<code>initproc</code>第一次被调度时，会从<code>forkret</code>开始执行，最终跳转到<code>kernel_thread_entry</code>。<br />5. <strong>加入队列并唤醒</strong>：将<code>initproc</code>加入就绪队列和哈希表，并唤醒它。<br />#### <strong>3. 执行内核线程与上下文切换</strong><br />- <strong>首次调度</strong>：当<code>idleproc</code>运行时，由于<code>need_resched</code>标志被设置，调度器会选择<code>initproc</code>。<br />- <strong>上下文切换</strong>：调用<code>switch_to</code>汇编函数完成从<code>idleproc</code>到<code>initproc</code>的切换。<br />- <strong>保存旧上下文</strong>：将<code>idleproc</code>的<code>eip</code>, <code>esp</code>等寄存器保存到其<code>context</code>结构中。<br />- <strong>加载新上下文</strong>：从<code>initproc</code>的<code>context</code>结构中加载<code>eip</code>, <code>esp</code>等寄存器到CPU。<br />- <strong>跳转执行</strong>：<code>switch_to</code>的最后一条<code>ret</code>指令会弹出<code>initproc-&gt;context.eip</code>的值到<code>EIP</code>，从而跳转到<code>forkret</code>函数执行。<br />- <strong><code>initproc</code>的执行路径</strong>：<br />1. <code>forkret</code> -&gt; <code>kernel_thread_entry</code><br />2. <code>kernel_thread_entry</code>从寄存器中取出函数和参数，调用该函数（即<code>init_main</code>）。<br />3. <code>init_main</code>执行，输出字符串，并最终尝试加载用户程序。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> 操作系统原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【操作系统原理】 Lecture 14 实验五 用户进程管理</title>
      <link href="/2025/11/05/25-11-5-9-OpSys-14-user-proc-man/"/>
      <url>/2025/11/05/25-11-5-9-OpSys-14-user-proc-man/</url>
      
        <content type="html"><![CDATA[<h3 id="一总体介绍"><strong>一、总体介绍</strong></h3><h4 id="实验目标"><strong>1. 实验目标</strong></h4><p>本实验的目标是构建一个完整的用户进程环境，让学生掌握从内核态到用户态的跨越，以及用户进程的生命周期管理。<br />- <strong>创建第一个用户进程</strong>：理解如何“硬构造”出第一个用户进程，为其建立用户态的代码/数据段。<br />- <strong>实现系统调用框架</strong>：理解用户态如何通过<code>int 0x80</code>中断陷入内核，执行系统调用，并返回用户态。<br />- <strong>掌握进程管理机制</strong>：包括进程的创建（<code>fork</code>）、加载（<code>exec</code>）、复制和销毁。<br />#### <strong>2. 核心练习</strong><br />- <strong>加载并执行应用程序</strong>：将一个简单的<code>hello</code>程序（ELF格式）加载到内存并运行。<br />- <strong>实现进程复制</strong>：完成<code>fork</code>系统调用，让父进程复制自己的内存空间给子进程。<br />- <strong>分析系统调用与进程管理</strong>：深入理解<code>do_execve</code>和<code>do_fork</code>的实现细节。<br />—<br />### <strong>二、进程的内存布局</strong><br />理解用户进程的虚拟内存空间是本实验的基础。<br />#### <strong>1. 内核与进程虚拟内存布局对比</strong><br />ucore为内核和用户进程设计了不同的虚拟内存布局：<br />- <strong>内核空间（高地址）</strong>：<br />- <code>KERNBASE</code>到<code>KERNTOP</code>：内核代码和数据，直接映射物理内存。<br />- <code>VPT</code>：存放当前页目录和页表的虚拟地址，便于内核访问。<br />- <strong>用户空间（低地址）</strong>：<br />- <code>USERBASE</code>到<code>USERTOP</code>：用户进程的代码、数据、堆和栈。<br />- <strong>用户栈</strong>：位于用户空间顶部（如<code>USTACKTOP - USTACKSIZE</code>），向下增长。<br />#### <strong>2. 关键点</strong><br />- <strong>地址隔离</strong>：内核空间和用户空间通过页表进行隔离，用户态代码无法直接访问内核空间。<br />- <strong>布局一致性</strong>：所有用户进程都遵循相同的虚拟内存布局，简化了内核的管理。<br />—<br />### <strong>三、执行ELF格式的二进制代码</strong><br />这是将磁盘上的可执行文件变为内存中运行进程的核心过程。<br />#### <strong>1. <code>do_execve</code>系统调用</strong><br /><code>do_execve</code>是<code>exec</code>系统调用的内核实现，其核心步骤如下：<br />1. <strong>回收旧内存</strong>：如果当前进程已有内存空间（<code>mm</code>不为空），则释放它。<br />2. <strong>加载新程序</strong>：调用<code>load_icode</code>函数，从磁盘读取ELF文件并建立新的内存空间。<br />3. <strong>设置Trapframe</strong>：为新程序设置好用户态的执行起点和栈指针，以便从内核返回后能正确执行。<br />#### <strong>2. <code>load_icode</code>的实现细节</strong><br /><code>load_icode</code>是加载ELF文件的核心，它完成了从文件到内存的映射：<br />1. <strong>创建内存管理结构</strong>：调用<code>mm_create()</code>和<code>setup_pgdir()</code>创建新的<code>mm_struct</code>和页目录。<br />2. <strong>解析ELF头</strong>：读取ELF文件头，获取程序头表的位置和数量。<br />3. <strong>映射程序段</strong>：遍历每个程序头，根据其类型（如<code>PT_LOAD</code>）和属性（可读、可写、可执行）：<br />- 调用<code>mm_map</code>创建对应的VMA（虚拟内存区域）。<br />- 调用<code>pgdir_alloc_page</code>分配物理页，并将ELF文件中的内容复制到这些物理页中。<br />4. <strong>建立用户栈</strong>：在用户空间顶部映射一个可读写的VMA作为用户栈，并分配一个物理页。<br />5. <strong>设置进程PCB</strong>：将新创建的<code>mm_struct</code>挂载到当前进程的PCB，并更新CR3寄存器，切换到新的页目录。<br />#### <strong>3. 设置用户态执行起点</strong><br />这是从内核态返回用户态的关键一步：<br />- <strong>修改Trapframe</strong>：在<code>load_icode</code>的最后，需要设置保存在内核栈上的<code>trapframe</code>。<br />- <code>tf_cs</code>设置为用户代码段选择子。<br />- <code>tf_ds</code>/<code>tf_es</code>/<code>tf_ss</code>设置为用户数据段选择子。<br />- <code>tf_eip</code>设置为ELF程序的入口点（<code>e_entry</code>）。<br />- <code>tf_esp</code>设置为用户栈的栈顶。<br />- <strong>执行流程</strong>：当<code>do_execve</code>执行完毕，通过<code>iret</code>指令返回时，CPU会从<code>trapframe</code>中恢复这些寄存器，从而跳转到用户程序的入口点开始执行。<br />—<br />### <strong>四、进程复制</strong><br /><code>fork</code>系统调用是创建新进程的主要方式，它创建一个与父进程几乎完全相同的子进程。<br />#### <strong>1. <code>do_fork</code>的实现步骤</strong><br />1. <strong>分配PCB和内核栈</strong>：调用<code>alloc_proc()</code>和<code>setup_kstack()</code>为子进程分配PCB和内核栈。<br />2. <strong>复制内存空间</strong>：调用<code>copy_mm()</code>，这是<code>fork</code>的核心。<br />- 如果没有开启COW，<code>copy_mm</code>会调用<code>copy_range</code>，逐页复制父进程的物理内存到子进程。<br />- 如果开启了COW，<code>copy_mm</code>只会复制父进程的页目录和页表，并让父子进程的页表项指向相同的物理页，同时将这些页标记为只读。<br />3. <strong>复制Trapframe</strong>：调用<code>copy_thread()</code>，将父进程的<code>trapframe</code>复制到子进程的内核栈，并做关键修改：<br />- 将<code>tf_eax</code>设置为0（这是子进程<code>fork</code>的返回值）。<br />- 将<code>tf_esp</code>设置为传入的<code>stack</code>参数（如果用户指定了新栈）。<br />- 将<code>context.eip</code>设置为<code>forkret</code>，<code>context.esp</code>指向<code>trapframe</code>。<br />4. <strong>加入队列并唤醒</strong>：将子进程加入进程链表，并设置为就绪状态，等待调度。<br />—<br />### <strong>五、内存管理的写时复制机制</strong><br />为了提高<code>fork</code>的效率，现代操作系统普遍采用写时复制机制。<br />#### <strong>1. COW原理</strong><br />- <strong>延迟复制</strong>：<code>fork</code>时，子进程并不立即复制父进程的内存页，而是共享父进程的物理页。<br />- <strong>标记为只读</strong>：将这些共享的物理页在父子进程的页表项中都标记为只读。<br />- <strong>按需复制</strong>：当任一进程尝试写入这些共享页时，会触发一个<strong>页保护异常</strong>（一种Page Fault）。<br />- <strong>异常处理</strong>：在Page Fault处理程序中，内核会检查这是一个COW页，于是：<br />1. 分配一个新的物理页。<br />2. 将原页的内容复制到新页。<br />3. 修改触发异常的进程的页表项，使其指向这个新的、可写的物理页。<br />4. 清除异常，重新执行写入指令。<br />#### <strong>2. COW的关键实现点</strong><br />- <strong>引用计数</strong>：每个物理页需要一个引用计数（<code>page_ref</code>），记录有多少个页表项指向它。当页被复制后，原页的引用计数减1，新页的引用计数为1。只有当引用计数为0时，物理页才能被回收。<br />- <strong><code>dup_mmap</code>和<code>copy_range</code></strong>：在<code>copy_mm</code>中，<code>dup_mmap</code>负责复制VMA，而<code>copy_range</code>负责复制页表项并设置COW属性。<br />- <strong><code>do_pgfault</code></strong>：Page Fault处理程序需要能够识别COW场景，并执行上述的复制逻辑。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> 操作系统原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【操作系统原理】 Lecture 12 进程控制</title>
      <link href="/2025/11/05/25-11-5-7-OpSys-12-proc-ctrl/"/>
      <url>/2025/11/05/25-11-5-7-OpSys-12-proc-ctrl/</url>
      
        <content type="html"><![CDATA[<h3 id="一进程切换"><strong>一、进程切换</strong></h3><p>进程切换是操作系统多任务处理的核心，指CPU从一个进程的运行切换到另一个进程运行的过程。<br />#### <strong>1. 核心概念：上下文切换</strong><br />- <strong>上下文</strong>：指一个进程运行时所需的全部信息，包括：<br />- <strong>用户级上下文</strong>：代码、数据、用户栈、共享内存。<br />- <strong>寄存器上下文</strong>：通用寄存器、程序计数器、栈指针等。<br />- <strong>系统级上下文</strong>：进程控制块、内存管理信息（如页表基址）。<br />- <strong>上下文切换</strong>：保存当前进程的上下文，加载新进程的上下文，并转移控制权的过程。<br />#### <strong>2. ucore中的实现</strong><br />- <strong>进程控制块</strong>：<code>proc_struct</code>（<code>kern/process/proc.h</code>）是ucore的PCB，包含了进程状态、内核栈、进程ID、内存管理结构指针（<code>mm_struct</code>）等所有信息。<br />- <strong>内存地址空间</strong>：<code>mm_struct</code>管理进程的虚拟地址空间，包含指向页目录的指针和VMA链表。<br />- <strong>进程队列</strong>：ucore使用链表组织不同状态的进程（如就绪队列、等待队列）。<br />- <strong>切换流程</strong>：<br />1. <strong>触发切换</strong>：时钟中断、I/O中断或系统调用可能导致调度。<br />2. <strong>保存上下文</strong>：当前进程在内核态下，将其寄存器上下文保存到自己的内核栈中。<br />3. <strong>选择新进程</strong>：调度器从就绪队列中选择下一个要运行的进程。<br />4. <strong>切换栈</strong>：将CPU的栈指针（ESP）指向新进程的内核栈顶。<br />5. <strong>恢复上下文</strong>：从新进程的内核栈中恢复寄存器上下文。<br />6. <strong>执行新进程</strong>：通过<code>iret</code>指令返回用户态，开始执行新进程。<br />- <strong>关键函数</strong>：<code>switch_to</code>（<code>kern/arch/i386/process/switch.S</code>）是一个汇编函数，负责完成最核心的栈指针切换和寄存器恢复。<br />—<br />### <strong>二、进程创建</strong><br />进程创建是操作系统生成新进程的过程，最经典的系统调用是<code>fork()</code>。<br />#### <strong>1. <code>fork()</code>系统调用</strong><br />- <strong>功能</strong>：创建一个与当前进程（父进程）几乎完全相同的子进程。<br />- <strong>地址空间复制</strong>：<br />- <strong>传统方式</strong>：复制父进程的整个地址空间（代码、数据、堆栈），开销大。<br />- <strong>现代方式（写时复制, Copy-on-Write, COW）</strong>：<br />- 父子进程共享相同的物理页，但页表项标记为只读。<br />- 当任一进程尝试写入时，触发缺页异常，内核才复制该页，赋予写权限。<br />- <strong>优点</strong>：极大降低了<code>fork()</code>的开销，提高了创建进程的效率。<br />#### <strong>2. ucore中的实现</strong><br />- <strong><code>do_fork()</code>函数</strong>：<code>fork()</code>系统调用的内核实现。<br />1. <strong>分配PCB</strong>：调用<code>alloc_proc()</code>为新进程分配一个<code>proc_struct</code>并初始化。<br />2. <strong>设置内核栈</strong>：调用<code>setup_stack()</code>和<code>copy_stack()</code>为子进程设置内核栈，并复制父进程的部分上下文。<br />3. <strong>复制内存空间</strong>：调用<code>copy_mm()</code>复制父进程的<code>mm_struct</code>和页表，实现写时复制。<br />4. <strong>设置进程状态</strong>：将子进程设置为<code>PROC_RUNNABLE</code>（就绪）状态，并加入就绪队列。<br />5. <strong>返回</strong>：父进程返回子进程PID，子进程返回0。<br />- <strong>特殊进程创建</strong>：<br />- <strong>空闲进程</strong>：在<code>proc_init()</code>中创建，是所有进程的祖先，当没有就绪进程时运行它。<br />- <strong>第一个内核线程</strong>：同样在<code>proc_init()</code>中创建，用于执行初始化任务，并最终加载第一个用户进程。<br />—<br />### <strong>三、进程加载</strong><br />进程加载是指用一个全新的程序替换当前进程的地址空间，主要通过<code>exec()</code>系统调用实现。<br />#### <strong>1. <code>exec()</code>系统调用</strong><br />- <strong>功能</strong>：在当前进程的上下文中，读取磁盘上的可执行文件，清除旧的地址空间，建立新的地址空间，并开始执行新程序。<br />- <strong>特点</strong>：<br />- <strong>不创建新进程</strong>：<code>exec()</code>调用后，原进程被新程序“覆盖”，但PID不变。<br />- <strong>保留部分信息</strong>：通常保留打开的文件描述符（除非显式关闭）。<br />#### <strong>2. ucore中的实现</strong><br />- <strong><code>do_execve()</code>函数</strong>：<code>exec()</code>系统调用的内核实现。<br />1. <strong>加载ELF文件</strong>：解析可执行文件的ELF头，获取程序头信息。<br />2. <strong>创建新内存空间</strong>：调用<code>mm_create()</code>创建一个新的<code>mm_struct</code>。<br />3. <strong>建立内存映射</strong>：根据程序头，为代码段、数据段等建立VMA，并分配物理页或设置延迟分配。<br />4. <strong>设置入口点</strong>：将新程序的入口地址（通常是<code>_start</code>）设置到子进程的 trapframe 中，这样从内核返回用户态时会跳转到新程序执行。<br />5. <strong>替换当前进程</strong>：释放旧的内存空间，用新的<code>mm_struct</code>替换当前进程的<code>mm</code>指针。<br />—<br />### <strong>四、进程等待与退出</strong><br />进程等待与退出是进程生命周期结束和资源回收的机制。<br />#### <strong>1. <code>exit()</code>系统调用</strong><br />- <strong>功能</strong>：终止当前进程，释放其占有的大部分资源（如内存、文件），并通知父进程。<br />- <strong>状态转换</strong>：进程从运行态变为<strong>僵尸状态</strong>。<br />- <strong>僵尸状态</strong>：进程已终止，但其PCB仍保留在内核中，等待父进程获取其退出状态信息。<br />#### <strong>2. <code>wait()</code>系统调用</strong><br />- <strong>功能</strong>：父进程调用<code>wait()</code>或<code>waitpid()</code>来等待子进程结束。<br />- <strong>行为</strong>：<br />- 如果子进程仍在运行，父进程阻塞。<br />- 如果子进程已结束（处于僵尸状态），父进程回收子进程的PCB，获取其退出码，子进程彻底消失。<br />#### <strong>3. ucore中的实现</strong><br />- <strong><code>do_exit()</code>函数</strong>：<br />1. 释放进程的内存空间和资源。<br />2. 设置进程状态为<code>PROC_ZOMBIE</code>（僵尸）。<br />3. 如果父进程正在等待（<code>PROC_WAITING</code>），则唤醒父进程。<br />4. 调用调度器，选择新进程运行。<br />- <strong><code>do_wait()</code>函数</strong>：<br />1. 查找子进程，如果子进程未结束，则将当前进程设置为<code>PROC_WAITING</code>状态并阻塞。<br />2. 如果找到僵尸子进程，回收其PCB，并返回子进程的PID和退出状态。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> 操作系统原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【操作系统原理】 Lecture 11 进程与线程</title>
      <link href="/2025/11/05/25-11-5-6-OpSys-11-proc-thrd/"/>
      <url>/2025/11/05/25-11-5-6-OpSys-11-proc-thrd/</url>
      
        <content type="html"><![CDATA[<h3 id="一进程"><strong>一、进程</strong></h3><h4 id="进程的定义与组成"><strong>1. 进程的定义与组成</strong></h4><ul><li><strong>定义</strong>：进程是一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。它是操作系统进行资源分配和调度的基本单位。</li><li><strong>与程序的区别</strong>：<br />| <strong>维度</strong> | <strong>程序</strong> | <strong>进程</strong> |<br />|————–|————————————|———————————————-|<br />| <strong>性质</strong> | 静态的代码和数据集合 | 动态的执行过程 |<br />| <strong>生命周期</strong> | 长期存在于磁盘 | 临时存在，有创建、执行、消亡的生命周期 |<br />| <strong>并发性</strong> | 自身无法并发 | 可以与其他进程并发执行 |<br />| <strong>资源分配</strong> | 不直接占用系统资源 | 是资源分配的基本单位（内存、文件等） |</li><li><strong>组成</strong>：进程包含了正在运行的一个程序的所有状态信息，包括：<ul><li><strong>代码段</strong>：程序的指令。</li><li><strong>数据段</strong>：全局变量和静态变量。</li><li><strong>堆栈段</strong>：函数调用栈、局部变量和动态分配的内存。</li><li><strong>进程控制块</strong>：管理进程的核心数据结构。<br />#### <strong>2. 进程控制块</strong></li></ul></li><li><strong>作用</strong>：PCB是操作系统管理控制进程运行所用的信息集合，是进程存在的唯一标志。</li><li><strong>包含信息</strong>：<ul><li><strong>进程标识信息</strong>：如进程ID（PID）、父进程ID。</li><li><strong>进程控制信息</strong>：进程状态、程序计数器、CPU寄存器值、内存管理信息（页表基址）、I/O状态信息等。</li></ul></li><li><strong>组织方式</strong>：<ul><li><strong>链表</strong>：将同一状态的PCB链接成一个队列（如就绪队列、等待队列）。</li><li><strong>索引表</strong>：建立索引表，通过索引指向PCB，提高查找效率。<br />#### <strong>3. 进程的生命周期</strong><br />进程的生命周期由一系列事件驱动，主要包括：</li></ul></li><li><strong>创建</strong>：如用户登录、程序启动、系统调用创建子进程。</li><li><strong>执行</strong>：内核从就绪队列中选择一个进程，让其占用CPU运行。</li><li><strong>等待</strong>：进程因等待某事件（如I/O完成）而主动放弃CPU。</li><li><strong>唤醒</strong>：等待的事件发生，进程从等待状态转为就绪状态。</li><li><strong>抢占</strong>：高优先级进程就绪或当前进程时间片用完，被强制剥夺CPU。</li><li><h2 id="结束进程正常执行完毕或因错误被终止"><strong>结束</strong>：进程正常执行完毕或因错误被终止。</h2><h3 id="二进程状态模型"><strong>二、进程状态模型</strong></h3><h4 id="三状态进程模型"><strong>1. 三状态进程模型</strong></h4>这是最基础的进程状态模型，包含三个核心状态：</li><li><strong>运行态</strong>：进程正在CPU上执行。</li><li><strong>就绪态</strong>：进程已获得除CPU之外的所有资源，一旦获得CPU即可运行。</li><li><strong>等待态</strong>：进程因等待某个事件（如I/O）而暂停运行。<br /><strong>状态转换图</strong>：<br /><pre class="mermaid">  graph LR    A[创建] --> B[就绪态]    B -- 被调度 --> C[运行态]    C -- 时间片用完/被抢占 --> B    C -- 等待事件 --> D[等待态]    D -- 事件发生 --> B    C -- 执行结束 --> E[终止]</pre><h4 id="挂起进程模型"><strong>2. 挂起进程模型</strong></h4>在三状态模型的基础上引入<strong>挂起状态</strong>，以解决内存不足的问题。</li><li><strong>挂起状态</strong>：进程映像（代码、数据等）被交换到外存（磁盘）上，<strong>暂时不占用内存</strong>。</li><li><strong>两种挂起状态</strong>：<ul><li><strong>就绪挂起</strong>：进程在外存，一旦调入内存即可运行。</li><li><strong>等待挂起</strong>：进程在外存并等待事件。<br /><strong>引入挂起状态的原因</strong>：</li></ul></li><li><strong>回收内存</strong>：将暂时不运行的进程换出到外存，为其他进程腾出内存空间。</li><li><h2 id="调节负载系统负载过高时可挂起部分低优先级进程"><strong>调节负载</strong>：系统负载过高时，可挂起部分低优先级进程。</h2><h3 id="三线程"><strong>三、线程</strong></h3><h4 id="为什么引入线程"><strong>1. 为什么引入线程？</strong></h4></li><li><strong>案例</strong>：一个MP3播放软件需要同时执行三个任务：读取数据、解压缩、播放。</li><li><strong>单进程问题</strong>：只能串行执行，效率低下。</li><li><strong>多进程问题</strong>：<ul><li><strong>通信复杂</strong>：进程间通信（IPC）开销大。</li><li><strong>开销大</strong>：进程创建、切换成本高。</li></ul></li><li><strong>多线程解决方案</strong>：在一个进程内部创建多个线程，每个线程负责一个任务，共享进程的资源，并发执行。<br />#### <strong>2. 线程的概念与特点</strong></li><li><strong>定义</strong>：线程是进程的一部分，是进程中的指令执行流的最小单元，是CPU调度的基本单位。</li><li><strong>与进程的关系</strong>：<ul><li><strong>资源分配单位</strong>：进程是资源分配的基本单位（内存、文件等）。</li><li><strong>CPU调度单位</strong>：线程是CPU调度的基本单位。</li><li><strong>共享资源</strong>：同一进程的线程共享代码段、数据段和文件等资源。</li><li><strong>私有资源</strong>：每个线程有独立的栈、寄存器和程序计数器。</li></ul></li><li><strong>优势</strong>：<ul><li><strong>切换开销小</strong>：线程切换只需保存少量寄存器，比进程切换快得多。</li><li><strong>通信简单</strong>：线程间可以直接读写共享变量，无需复杂的IPC机制。</li><li><h2 id="并发性高提高应用程序的并发执行能力"><strong>并发性高</strong>：提高应用程序的并发执行能力。</h2><h3 id="四线程的实现方式"><strong>四、线程的实现方式</strong></h3>线程的实现方式主要分为三类，其核心区别在于线程的管理是由用户空间还是内核空间负责。<br />#### <strong>1. 用户线程</strong></li></ul></li><li><strong>实现</strong>：由用户空间的线程库（如POSIX threads）管理，内核不感知线程的存在。</li><li><strong>特点</strong>：<ul><li><strong>优点</strong>：线程切换在用户态完成，无需内核介入，速度快；可自定义调度算法。</li><li><strong>缺点</strong>：<ul><li><strong>阻塞问题</strong>：一个线程发起系统调用导致阻塞时，整个进程都会被阻塞。</li><li><strong>无法利用多核</strong>：内核将整个进程视为一个调度单元，无法在多核CPU上并行执行。</li></ul></li></ul></li><li><strong>模型</strong>：<strong>多对一模型</strong>（多个用户线程映射到一个内核线程）。<br />#### <strong>2. 内核线程</strong></li><li><strong>实现</strong>：线程的创建、终止和管理都由内核完成。</li><li><strong>特点</strong>：<ul><li><strong>优点</strong>：<ul><li><strong>内核感知</strong>：内核可以直接调度每个线程，一个线程阻塞不会影响其他线程。</li><li><strong>支持多核</strong>：不同线程可以在不同CPU核心上并行执行。</li></ul></li><li><strong>缺点</strong>：线程切换需要从用户态陷入内核态，开销较大。</li></ul></li><li><strong>模型</strong>：<strong>一对一模型</strong>（一个用户线程映射到一个内核线程）。<br />#### <strong>3. 轻量级进程</strong></li><li><strong>实现</strong>：这是内核支持的用户线程，结合了用户线程和内核线程的优点。</li><li><strong>特点</strong>：<ul><li>LWP是内核调度的基本单位，但仍然由用户空间的线程库进行管理。</li><li>一个进程可以有多个LWP，每个LWP由一个内核线程支持。</li></ul></li><li><strong>模型</strong>：<strong>多对多模型</strong>（多个用户线程映射到多个内核线程）。<ul><li><strong>优点</strong>：既克服了用户线程无法利用多核的缺点，又减少了内核线程管理的开销。</li><li><strong>代表</strong>：现代Linux系统采用此模型（通过<code>clone</code>系统调用实现）。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> 操作系统原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【操作系统原理】 Lecture 10 实验三 虚拟内存管理</title>
      <link href="/2025/11/05/25-11-5-5-OpSys-10-exp3-virt-mem/"/>
      <url>/2025/11/05/25-11-5-5-OpSys-10-exp3-virt-mem/</url>
      
        <content type="html"><![CDATA[<h3 id="一实验目标虚存管理"><strong>一、实验目标：虚存管理</strong></h3><p>本实验的核心目标是构建一个完整的虚拟内存管理系统，具体包括：<br />1. <strong>基础</strong>：在Lab1（保护模式、中断）和Lab2（物理内存管理、页机制）之上。<br />2. <strong>核心机制</strong>：利用页表和中断异常处理机制。<br />3. <strong>关键实现</strong>：<br />* <strong>Page Fault异常处理</strong>：当访问的虚拟页不在物理内存中时，能够捕获并处理该异常。<br />* <strong>页替换算法</strong>：实现FIFO（先进先出）算法，在物理内存已满时选择一个页面换出到磁盘。<br />* <strong>磁盘交互</strong>：实现对硬盘swap分区的读写，为换出的页面提供存储空间。<br />4. <strong>最终效果</strong>：为用户提供一个比实际物理内存“更大”的虚拟内存空间，使得程序可以运行在超过物理内存大小的地址空间中。<br />—<br />### <strong>二、回顾历史：Lab1和Lab2</strong><br />Lab3的实现高度依赖于前两个实验的成果：<br />* <strong>Lab1</strong>：<br />* 建立了<strong>保护模式</strong>和<strong>段机制</strong>，为内存访问提供了硬件层面的保护。<br />* 建立了<strong>中断机制</strong>，这是处理Page Fault异常的基础。<br />* 实现了基本的屏幕输出功能，便于调试。<br />* <strong>Lab2</strong>：<br />* 探测了可用的<strong>物理内存空间</strong>。<br />* 建立了基于<strong>连续物理内存</strong>的动态分配与释放机制（如伙伴系统）。<br />* 完成了<strong>页机制</strong>的建立，包括初始化页目录和页表，并开启了CR0寄存器的PG位，使能分页。<br />—<br />### <strong>三、了解当下：Lab3的总体框架</strong><br />Lab3的实验设计是一个循序渐进、层层递进的过程，其总体框架和步骤如下：<br />1. <strong>初始化</strong>：完成虚拟内存管理机制的初始化，包括IDE硬盘的读写驱动和缺页异常处理程序的设置。<br />2. <strong>数据结构设计</strong>：设计数据结构来表示虚拟页空间和物理页帧空间，并能描述那些“合法”但当前不在物理内存中的虚拟页。<br />3. <strong>核心功能实现</strong>：完善建立页表映射、处理页访问异常等核心函数。<br />4. <strong>测试与验证</strong>：通过一系列访存测试，逐步验证系统的正确性：<br />* 验证页表项能否正确完成虚实地址转换。<br />* 验证页表项能否正确描述一个页是在物理内存中还是在硬盘上。<br />* 验证能否正确地在物理内存和硬盘之间传递页面（换入/换出）。<br />* 验证页面替换算法（FIFO）是否被正确实现。<br />—<br />### <strong>四、处理流程、关键数据结构和功能</strong><br />#### <strong>1. 初始化流程</strong><br />虚拟内存管理的初始化在<code>kern/init/init.c</code>的<code>kern_init</code>函数中完成，调用顺序如下：<br />* <code>pmm_init()</code> (Lab2)：初始化物理内存管理。<br />* <code>pic_init()</code>, <code>idt_init()</code> (Lab1)：初始化中断控制器和中断描述符表。<br />* <code>vmm_init()</code>, <code>ide_init()</code>, <code>swap_init()</code> (Lab3)：<strong>本次实验的核心初始化函数</strong>。<br />* <code>vmm_init()</code>：初始化虚拟内存管理数据结构。<br />* <code>ide_init()</code>：初始化IDE硬盘驱动，为swap分区提供读写能力。<br />* <code>swap_init()</code>：初始化交换空间管理器。<br />#### <strong>2. 关键数据结构</strong><br />虚拟内存管理的核心是两个相互关联的结构体，定义在<code>kern/mm/vmm.h</code>中：<br />* <strong><code>vma_struct</code> (虚拟内存区域)</strong>：<br />* <code>vm_start</code>, <code>vm_end</code>：定义了一段连续的虚拟地址空间。<br />* <code>vm_flags</code>：描述该区域的属性（如可读、可写、可执行）。<br />* <code>list_link</code>：链表节点，用于将多个VMA链接起来。<br />* <code>vm_mm</code>：指向所属的<code>mm_struct</code>。<br />* <strong><code>mm_struct</code> (内存管理描述符)</strong>：<br />* <code>mmap_list</code>：一个链表头，链接了该进程所有的<code>vma_struct</code>。<br />* <code>mmap_cache</code>：一个缓存，指向最近一次访问的VMA，加速地址查找。<br />* <code>pgdir</code>：指向该进程的<strong>页目录基址</strong>，是整个地址转换的起点。<br />* <code>map_count</code>：记录VMA的数量。<br />* <code>sm_priv</code>：一个私有指针，用于指向swap manager（如FIFO算法）的特定数据。<br />—<br />### <strong>五、页访问异常</strong><br />当CPU访问一个无效的虚拟地址（如页表项的P位为0）时，会触发<strong>Page Fault异常（中断向量14）</strong>。<br />1. <strong>硬件响应</strong>：<br />* CPU将引发异常的<strong>线性地址</strong>存入<code>CR2</code>寄存器。<br />* 将<strong>错误码</strong>压入栈中，错误码包含以下信息：<br />* <code>P</code>：0表示页不存在，1表示页保护违规。<br />* <code>W/R</code>：0表示读操作，1表示写操作。<br />* <code>U/S</code>：0表示内核态访问，1表示用户态访问。<br />2. <strong>软件处理</strong>：<br />* CPU跳转到<code>vectors.S</code>中的<code>vector14</code>入口。<br />* 最终会调用C语言编写的<code>do_pgfault</code>函数。<br />* <code>do_pgfault</code>函数会读取<code>CR2</code>和错误码，根据<code>CR2</code>地址找到对应的<code>vma_struct</code>，判断访问是否合法。<br />* 如果合法，则分配一个物理页，从磁盘（swap分区）中读入数据（如果之前被换出），更新页表项，然后返回，重新执行引发异常的指令。<br />—<br />### <strong>六、页换入换出机制</strong><br />这是虚拟内存管理的动态核心，解决了“内存不足”的问题。<br />1. <strong>核心问题</strong>：<br />* <strong>换出哪个页？</strong> -&gt; 由<strong>页替换算法</strong>决定（Lab3实现<strong>FIFO</strong>）。<br />* <strong>虚拟页与磁盘扇区的对应关系？</strong> -&gt; 通过<strong>页表项</strong>中的<code>swap_entry_t</code>字段来记录。<br />* <strong>何时换入/换出？</strong> -&gt; <strong>换入</strong>由<strong>Page Fault</strong>触发；<strong>换出</strong>在<strong>物理内存不足</strong>时被动触发。<br />* <strong>如何支持算法？</strong> -&gt; 设计特定数据结构（如FIFO队列）。<br />* <strong>如何执行换入/换出？</strong> -&gt; 调用IDE硬盘读写函数。<br />2. <strong>关键实现细节</strong>：<br />* <strong>页替换算法</strong>：Lab3要求实现<strong>FIFO</strong>算法。该算法维护一个页面队列，每次需要换出时，选择最早进入队列的页面。<br />* <strong>虚拟页与磁盘的映射</strong>：当一个页被换出时，其物理页帧被回收，页表项的P位置0，并在页表项中记录它在swap分区中的位置（扇区偏移）。这个记录通过<code>swap_entry_t</code>结构实现，它复用了页表项的32位空间，用其中24位记录磁盘偏移。<br />* <strong>换入时机</strong>：当访问一个P=0的页时，触发<code>do_pgfault</code>，该函数会检查页表项，如果发现它是一个swap entry，就会调用<code>swap_in</code>函数，从磁盘读回数据到新分配的物理页中。<br />* <strong>换出时机</strong>：当分配物理页失败时（即内存已满），会调用<code>swap_out</code>函数。该函数会根据FIFO算法选择一个牺牲页，如果该页被修改过（Dirty Bit为1），则先调用<code>swap_out</code>将其写回磁盘，然后更新其页表项为swap entry，最后释放其物理页帧。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> 操作系统原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【操作系统原理】 Lecture 9 页面置换算法</title>
      <link href="/2025/11/05/25-11-5-4-OpSys-9-page-swap/"/>
      <url>/2025/11/05/25-11-5-4-OpSys-9-page-swap/</url>
      
        <content type="html"><![CDATA[<h3 id="一页面置换算法的概念"><strong>一、页面置换算法的概念</strong></h3><h4 id="功能与目标"><strong>1. 功能与目标</strong></h4><ul><li><strong>功能</strong>：当发生缺页异常且内存已满时，选择一个页面换出到外存，为新页面腾出空间。<br /></li><li><strong>目标</strong>：<ul><li><strong>减少缺页次数</strong>：尽可能置换未来最长时间不会被访问的页面。<br /></li><li><strong>降低系统开销</strong>：避免频繁的磁盘I/O操作。</li></ul></li></ul><h4 id="评价方法"><strong>2. 评价方法</strong></h4><ul><li><strong>缺页率</strong>：缺页次数占总访问次数的比例。<br /></li><li><strong>Belady现象</strong>：某些算法（如FIFO）在增加物理页帧时，缺页次数反而增多。</li></ul><h4 id="算法分类"><strong>3. 算法分类</strong></h4><table><colgroup><col style="width: 12%" /><col style="width: 59%" /><col style="width: 27%" /></colgroup><thead><tr class="header"><th><strong>类型</strong></th><th><strong>特点</strong></th><th><strong>代表算法</strong></th></tr></thead><tbody><tr class="odd"><td>局部置换算法</td><td>仅在当前进程的物理页帧中选择置换页面</td><td>OPT, FIFO, LRU, Clock, LFU</td></tr><tr class="even"><td>全局置换算法</td><td>从所有进程的物理页帧中选择置换页面，需考虑进程间的内存分配</td><td>工作集算法、缺页率算法</td></tr></tbody></table><h3 id="二局部页面置换算法"><strong>二、局部页面置换算法</strong></h3><h4 id="最优页面置换算法"><strong>1. 最优页面置换算法</strong></h4><ul><li><strong>原理</strong>：置换未来最长时间不会被访问的页面（理论最优，实际不可实现）。<br /></li><li><strong>示例</strong>：<ul><li>访问序列：<code>a, b, c, d, a, b, e, b, d, a, c</code>。<br /></li><li>置换时选择下次访问时间最晚的页面（如<code>d</code>下次访问时间为10）。</li></ul></li></ul><h4 id="先进先出算法"><strong>2. 先进先出算法</strong></h4><ul><li><strong>原理</strong>：置换最早进入内存的页面（队列实现）。<br /></li><li><strong>问题</strong>：存在Belady现象（如物理页帧从3增至4时，缺页次数从9增至10）。<br />#### <strong>3. 最近最久未使用算法</strong></li><li><strong>原理</strong>：置换最长时间未被访问的页面（栈实现，记录访问顺序）。<br /></li><li><strong>优点</strong>：性能接近OPT，无Belady现象。<br /></li><li><strong>缺点</strong>：硬件开销大（需维护时间戳或栈）。</li></ul><h4 id="时钟置换算法"><strong>4. 时钟置换算法</strong></h4><ul><li><strong>原理</strong>：<ul><li>页面访问时置访问位为1。<br /></li><li>置换时扫描页帧，跳过访问位为1的页面（置为0），选择第一个访问位为0的页面置换。<br /></li></ul></li><li><strong>改进版</strong>：结合修改位（Dirty Bit），优先置换未修改的页面（减少写回开销）。<br />#### <strong>5. 最不常用算法</strong></li><li><strong>原理</strong>：置换访问次数最少的页面（需维护计数器）。<br /></li><li><strong>问题</strong>：<ul><li>初始计数偏差（如历史访问频率高的页面可能被误换）。<br /></li><li>计数器硬件开销大。<br />#### <strong>6. 算法对比</strong><br />| <strong>算法</strong> | <strong>优点</strong> | <strong>缺点</strong> | <strong>Belady现象</strong> |<br />|———-|———————————–|———————————–|—————-|<br />| OPT | 理论最优 | 不可实现 | 无 |<br />| FIFO | 简单 | 性能差，有Belady现象 | 有 |<br />| LRU | 性能接近OPT | 硬件开销大 | 无 |<br />| Clock | 开销小，近似LRU | 性能略低于LRU | 无 |<br />| LFU | 适合访问频率稳定的场景 | 计数器开销大 | 无 |<br />—<br />### <strong>三、全局页面置换算法</strong><br />#### <strong>1. 局部置换算法的局限</strong></li></ul></li><li><strong>未考虑进程差异</strong>：所有进程分配固定页帧，无法适应动态内存需求。<br /></li><li><strong>示例</strong>：<ul><li>进程A访问序列<code>a, b, c</code>，物理页帧3时缺页9次；页帧4时缺页1次。<br /></li><li>局部置换无法动态调整页帧分配。<br />#### <strong>2. 工作集置换算法</strong></li></ul></li><li><strong>工作集（Working Set）</strong>：进程在时间窗口<code>Δ</code>内访问的页面集合（如<code>W(t, Δ)</code>）。<br /></li><li><strong>原理</strong>：<ul><li>置换不在工作集中的页面。<br /></li><li>动态调整常驻集（Resident Set）大小，使其包含工作集。<br /></li></ul></li><li><strong>示例</strong>：<ul><li>访问序列<code>2,6,1,5,7,7,...</code>，<code>Δ=10</code>时，工作集从<code>&#123;1,2,5,6,7&#125;</code>变为<code>&#123;3,4&#125;</code>。<br />#### <strong>3. 缺页率置换算法</strong></li></ul></li><li><strong>原理</strong>：<ul><li>监控进程缺页率（PFF），若超过阈值则增加页帧，否则减少页帧。<br /></li></ul></li><li><strong>实现</strong>：<ul><li>设置缺页率上限（如<code>PFF_max</code>）和下限（如<code>PFF_min</code>）。<br /></li><li><h2 id="动态调整常驻集大小使缺页率保持在合理范围">动态调整常驻集大小，使缺页率保持在合理范围。</h2><h3 id="四抖动与负载控制"><strong>四、抖动与负载控制</strong></h3><h4 id="抖动问题"><strong>1. 抖动问题</strong></h4></li></ul></li><li><strong>定义</strong>：进程频繁换入换出页面，导致CPU利用率下降。<br /></li><li><strong>原因</strong>：<ul><li>多道程序度过高，进程常驻集小于工作集。<br /></li><li>局部置换算法无法全局优化内存分配。<br />#### <strong>2. 负载控制</strong></li></ul></li><li><strong>目标</strong>：通过调整多道程序度（MPL）避免抖动。<br /></li><li><strong>方法</strong>：<ul><li><strong>工作集模型</strong>：确保进程常驻集 ≥ 工作集。<br /></li><li><strong>缺页率模型</strong>：动态调整MPL，使缺页率低于阈值。<br /></li></ul></li><li><strong>指标</strong>：<ul><li><strong>平均缺页间隔时间（MTBF）</strong>：<code>MTBF = 总时间 / 缺页次数</code>。<br /></li><li><strong>缺页服务时间（PFST）</strong>：处理一次缺页的平均时间。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> 操作系统原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【操作系统原理】 Lecture 8 虚拟存储概念</title>
      <link href="/2025/11/05/25-11-5-3-OpSys-8-virt-stor/"/>
      <url>/2025/11/05/25-11-5-3-OpSys-8-virt-stor/</url>
      
        <content type="html"><![CDATA[<h3 id="一虚拟存储的需求背景"><strong>一、虚拟存储的需求背景</strong></h3><h4 id="存储需求增长"><strong>1. 存储需求增长</strong></h4><ul><li><strong>程序规模 vs 存储容量</strong>：<ul><li>应用程序（如大型游戏）规模增长速度远超物理内存容量。<br /></li><li><strong>核心矛盾</strong>：需要运行比物理内存更大的程序。</li></ul></li></ul><h4 id="存储层次结构"><strong>2. 存储层次结构</strong></h4><ul><li><strong>金字塔模型</strong>：<ul><li><strong>顶层</strong>：CPU寄存器（最快，容量最小）。<br /></li><li><strong>中层</strong>：高速缓存、主存（RAM）。<br /></li><li><strong>底层</strong>：磁盘（最慢，容量最大）。<br /></li></ul></li><li><strong>操作系统抽象</strong>：<ul><li>通过虚拟存储技术，将外存（磁盘）扩展为内存的延伸。</li></ul></li></ul><h3 id="二核心技术覆盖与交换"><strong>二、核心技术：覆盖与交换</strong></h3><h4 id="覆盖技术"><strong>1. 覆盖技术</strong></h4><ul><li><strong>原理</strong>：<ul><li>按程序逻辑划分模块，将<strong>不会同时执行</strong>的模块共享同一内存区域。<br /></li></ul></li><li><strong>示例</strong>：<ul><li>模块A（20K）独立占用。<br /></li><li>模块B/E/F（50K）共享区域，模块C/D（30K）共享区域。<br /></li><li><strong>总内存需求</strong>：100K（原需150K）。<br /></li></ul></li><li><strong>不足</strong>：<ul><li>需程序员手动划分模块，增加编程复杂度。<br /></li><li>无法自动适应动态内存需求。</li></ul></li></ul><h4 id="交换技术"><strong>2. 交换技术</strong></h4><ul><li><strong>原理</strong>：<ul><li>将内存中<strong>暂时不运行</strong>的进程整体换出到外存，释放内存空间。<br /></li></ul></li><li><strong>流程</strong>：<ol type="1"><li><strong>换出</strong>：选择等待进程（如P2），写入磁盘。<br /></li><li><strong>换入</strong>：需要时再从磁盘加载回内存。<br /></li></ol></li><li><strong>面临问题</strong>：<ul><li><strong>交换区大小</strong>：需预留足够磁盘空间。<br /></li><li><strong>交换时机</strong>：何时触发交换（如内存不足时）。<br /></li><li><strong>重定位问题</strong>：换入后需放回原地址或动态重定位。</li></ul></li></ul><h4 id="覆盖-vs-交换"><strong>3. 覆盖 vs 交换</strong></h4><table><colgroup><col style="width: 13%" /><col style="width: 37%" /><col style="width: 48%" /></colgroup><thead><tr class="header"><th><strong>技术</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr class="odd"><td>覆盖</td><td>减少内存占用，无需OS支持</td><td>依赖程序员手动管理</td></tr><tr class="even"><td>交换</td><td>自动管理，支持多进程</td><td>整体换入/换出开销大</td></tr></tbody></table><h3 id="三局部性原理"><strong>三、局部性原理</strong></h3><h4 id="定义"><strong>1. 定义</strong></h4><ul><li><strong>时间局部性</strong>：最近访问的数据可能再次被访问（如循环变量）。<br /></li><li><strong>空间局部性</strong>：相邻地址的数据可能被连续访问（如数组遍历）。</li></ul><h4 id="示例分析"><strong>2. 示例分析</strong></h4><ul><li><strong>场景</strong>：二维数组<code>A[1024][1024]</code>按行存储，页面大小4K，物理页数=1。<br /></li><li><strong>两种遍历方式</strong>：<br /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1：按列遍历（低空间局部性）</span></span><br><span class="line"><span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;<span class="number">1024</span>; j++)</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">1024</span>; i++)</span><br><span class="line">        A[i][j] = <span class="number">0</span>;  <span class="comment">// 缺页次数：1024×1024</span></span><br><span class="line"><span class="comment">// 方法2：按行遍历（高空间局部性）</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">1024</span>; i++)</span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;<span class="number">1024</span>; j++)</span><br><span class="line">        A[i][j] = <span class="number">0</span>;  <span class="comment">// 缺页次数：1024</span></span><br></pre></td></tr></table></figure></li><li><strong>结论</strong>：<ul><li><h2 id="方法1每次访问跨页导致频繁缺页方法2连续访问同一页缺页次数显著减少">方法1每次访问跨页，导致频繁缺页；方法2连续访问同一页，缺页次数显著减少。</h2><h3 id="四虚拟页式存储管理"><strong>四、虚拟页式存储管理</strong></h3><h4 id="核心思想"><strong>1. 核心思想</strong></h4></li></ul></li><li><strong>按需加载</strong>：仅将当前需要的页加载到内存，其余页暂存外存。<br /></li><li><strong>地址转换流程</strong>：<ol type="1"><li><strong>逻辑地址</strong> → <code>(页号p, 页内偏移o)</code>。<br /></li><li><strong>页表查询</strong>：<ul><li>若页表项有效（P=1），直接获取物理帧号<code>f</code>。<br /></li><li>若无效（P=0），触发<strong>缺页异常</strong>。<br /></li></ul></li><li><strong>物理地址</strong> = <code>f * 页大小 + o</code>。<br />#### <strong>2. 页表项结构（x86）</strong><br />| <strong>标志位</strong> | <strong>含义</strong> |<br />|————|———————————–|<br />| P（驻留位）| 1=页在内存，0=页在外存 |<br />| W（可写） | 1=可写，0=只读 |<br />| U（用户态）| 1=用户态可访问，0=仅内核可访问 |<br />| A（访问位）| 硬件自动置位，记录是否被访问 |<br />| D（修改位）| 1=页被修改，需写回外存 |<br />#### <strong>3. 示例</strong></li></ol></li><li><strong>逻辑地址16位</strong>，物理内存32K，页大小4K：<ul><li>访问<code>8192</code>（逻辑地址）→ 页号2 → 缺页异常（页不在内存）。<br /></li><li>访问<code>32780</code>（逻辑地址）→ 页号8 → 缺页异常（超出物理内存范围）。</li></ul></li></ul><h3 id="五缺页异常处理"><strong>五、缺页异常处理</strong></h3><h4 id="处理流程"><strong>1. 处理流程</strong></h4><ol type="1"><li><strong>分配空闲页帧</strong>：若有空闲物理页，直接分配。<br /></li><li><strong>页面置换</strong>：<ul><li>选择被替换的页<code>q</code>（如LRU算法）。<br /></li><li>若<code>q</code>被修改（D=1），写回外存。<br /></li></ul></li><li><strong>加载新页</strong>：<ul><li>将缺页<code>p</code>从外存加载到物理页帧<code>f</code>。<br /></li><li>更新页表项（P=1，帧号=f）。<br /></li></ul></li><li><strong>重新执行指令</strong>：恢复产生缺页的指令。<br />#### <strong>2. 外存管理</strong></li></ol><ul><li><strong>交换区（Swap Area）</strong>：<ul><li>专门用于存储换出页的磁盘区域。<br /></li><li>需高效管理（如位图记录空闲块）。<br />#### <strong>3. 性能影响</strong></li></ul></li><li><strong>缺页中断开销</strong>：<ul><li>磁盘I/O延迟远高于内存访问（约10^5倍）。<br /></li></ul></li><li><strong>优化方向</strong>：<ul><li><strong>预取</strong>：提前加载可能访问的页。<br /></li><li><strong>页置换算法</strong>：LRU、Clock等减少缺页率。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> 操作系统原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【操作系统原理】 Lecture 7 实验二 物理内存管理</title>
      <link href="/2025/11/05/25-11-5-2-OpSys-7-exp2-phy-mem-man/"/>
      <url>/2025/11/05/25-11-5-2-OpSys-7-exp2-phy-mem-man/</url>
      
        <content type="html"><![CDATA[<h3 id="一x86特权级机制"><strong>一、x86特权级机制</strong></h3><h4 id="特权级简介"><strong>1. 特权级简介</strong></h4><ul><li><strong>保护环（Protection Rings）</strong>：<ul><li><strong>Ring 0</strong>：内核态，最高特权，可执行所有指令（如<code>lgdt</code>）。<br /></li><li><strong>Ring 3</strong>：用户态，最低特权，受限访问硬件资源。<br /></li><li><strong>Ring 1/2</strong>：设备驱动（Linux/ucore未使用）。<br /></li></ul></li><li><strong>特权级检查时机</strong>：<ul><li>访问数据段、页表、中断服务例程（ISR）时，CPU自动验证权限。<br /></li><li><strong>失败后果</strong>：触发通用保护异常（General Protection Fault）。<br />#### <strong>2. 特权级相关寄存器与描述符</strong></li></ul></li><li><strong>段选择子（Segment Selector）</strong>：<ul><li><strong>RPL（Requested Privilege Level）</strong>：请求者特权级（2位）。<br /></li><li><strong>TI（Table Indicator）</strong>：指示使用GDT（0）或LDT（1）。<br /></li><li><strong>索引</strong>：在描述符表中的位置。<br /></li></ul></li><li><strong>段描述符（Segment Descriptor）</strong>：<ul><li><strong>DPL（Descriptor Privilege Level）</strong>：描述符特权级（2位）。<br /></li><li><strong>Base Address</strong>：段基址，<strong>隐藏部分</strong>缓存至段寄存器。<br /></li></ul></li><li><strong>门描述符（Gate Descriptor）</strong>：<ul><li><strong>中断门（Interrupt Gate）</strong>：用于中断处理，清除IF标志。<br /></li><li><strong>陷阱门（Trap Gate）</strong>：用于系统调用，保留IF标志。<br />#### <strong>3. 特权级切换规则</strong></li></ul></li><li><strong>访问段</strong>：<code>MAX(CPL, RPL) &lt;= DPL[段]</code>。<br /></li><li><strong>访问门</strong>：<code>CPL &lt;= DPL[门]</code> 且 <code>CPL &gt;= DPL[段]</code>。<br /></li><li><strong>中断触发特权级切换</strong>：<ul><li><strong>Ring 3 → Ring 0</strong>：硬件自动切换栈，从TSS获取新栈指针。<br /></li><li><strong>Ring 0 → Ring 3</strong>：<code>IRET</code>指令恢复用户态栈。<br />#### <strong>4. TSS（任务状态段）</strong></li></ul></li><li><strong>作用</strong>：存储特权级切换时的栈指针（SS0/ESP0等）。<br /></li><li><strong>初始化流程</strong>：<ol type="1"><li>分配TSS内存（<code>pmm.c</code>）。<br /></li><li>填充TSS描述符到GDT。<br /></li><li><h2 id="加载tss选择子ltr指令">加载TSS选择子（<code>ltr</code>指令）。</h2><h3 id="二x86内存管理单元mmu"><strong>二、x86内存管理单元（MMU）</strong></h3><h4 id="段机制"><strong>1. 段机制</strong></h4></li></ol></li><li><strong>地址转换流程</strong>：<ol type="1"><li><strong>逻辑地址</strong> = <code>(段选择子, 偏移量)</code>。<br /></li><li><strong>段描述符</strong> → 段基址 + 偏移量 = <strong>线性地址</strong>。<br /></li></ol></li><li><strong>GDT初始化</strong>：<ul><li><strong>Bootloader阶段</strong>：基址为<code>0x0</code>，设置<code>CR0.PE=1</code>进入保护模式。<br /></li><li><strong>内核阶段</strong>：基址为<code>-0xC0000000</code>（内核空间高地址映射）。<br />#### <strong>2. 页机制</strong></li></ul></li><li><strong>地址转换流程</strong>：<ol type="1"><li><strong>线性地址</strong>分解为 <code>(页目录索引, 页表索引, 页内偏移)</code>。<br /></li><li><strong>CR3寄存器</strong> → 页目录基址 → 页表基址 → <strong>物理地址</strong>。<br /></li></ol></li><li><strong>页表项（PTE）字段</strong>：<ul><li><strong>R/W</strong>：可写标志（1=可写）。<br /></li><li><strong>U/S</strong>：用户可访问标志（1=Ring 3可访问）。<br /></li><li><strong>A</strong>：访问标志（硬件自动置位）。<br />#### <strong>3. 使能页机制</strong></li></ul></li><li><strong>关键步骤</strong>：<ol type="1"><li>初始化页目录和页表（<code>pmm.c</code>）。<br /></li><li>设置<code>CR0.PG=1</code>（Bit 31）。<br /></li><li><h2 id="更新gdt基址为0x0页机制生效后需线性地址等于物理地址">更新GDT基址为<code>0x0</code>（页机制生效后需线性地址等于物理地址）。</h2><h3 id="三段页式内存管理实现"><strong>三、段页式内存管理实现</strong></h3><h4 id="地址转换全流程"><strong>1. 地址转换全流程</strong></h4><pre class="mermaid">graph LR  A[逻辑地址] --> B[段机制]  B --> C[线性地址]  C --> D[页机制]  D --> E[物理地址]</pre></li></ol></li><li><strong>段机制</strong>：逻辑地址 → 线性地址（基址 + 偏移）。<br /></li><li><strong>页机制</strong>：线性地址 → 物理地址（二级页表查询）。<br />#### <strong>2. uCore内存管理初始化</strong><br />| <strong>阶段</strong> | <strong>CS基址</strong> | <strong>页机制</strong> | <strong>虚拟地址基址</strong> |<br />|————————|————-|———–|—————-|<br />| Bootloader | 0x0 | 禁用 | 0x0 |<br />| 内核初始化（汇编） | -0xC0000000 | 禁用 | 0xC0000000 |<br />| 使能页机制后 | -0xC0000000 | 启用 | 0xC0000000 |<br />| 内核运行时 | 0x0 | 启用 | 0x0 |<br />#### <strong>3. 页表映射建立</strong></li><li><strong>步骤</strong>：<ol type="1"><li>查找页目录项（PDE），若不存在则分配页表。<br /></li><li>查找页表项（PTE），设置物理帧号和权限标志。<br /></li><li><h2 id="返回pte指针供后续操作">返回PTE指针供后续操作。</h2><h3 id="四实验关键点总结"><strong>四、实验关键点总结</strong></h3></li></ol></li></ul><ol type="1"><li><strong>特权级切换</strong>：<ul><li>通过中断门实现用户态到内核态的切换，依赖TSS提供新栈。<br /></li></ul></li><li><strong>段页式映射</strong>：<ul><li>段机制提供逻辑隔离，页机制实现物理内存非连续分配。<br /></li></ul></li><li><strong>页表操作</strong>：<ul><li>动态分配页表项，设置<code>U/S</code>和<code>R/W</code>标志控制访问权限。<br /></li></ul></li><li><strong>地址空间布局</strong>：<ul><li>内核空间高地址映射（<code>0xC0000000</code>）与物理地址的线性映射关系。</li></ul></li></ol><h3 id="五参考资料"><strong>五、参考资料</strong></h3><ul><li><strong>Intel手册</strong>：<ul><li>Vol.3 Chap.3（保护模式内存管理）、Chap.4（分页机制）。<br /></li></ul></li><li><strong>ucore实验</strong>：<ul><li><code>pmm.c</code>：物理内存管理初始化。<br /></li><li><code>entry.S</code>：GDT设置和特权级切换。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> 操作系统原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【操作系统原理】 Lecture 6 物理内存管理：非连续内存分配</title>
      <link href="/2025/11/05/25-11-5-1-OpSys-6-phy-mem-man-discon/"/>
      <url>/2025/11/05/25-11-5-1-OpSys-6-phy-mem-man-discon/</url>
      
        <content type="html"><![CDATA[<h2 id="一非连续内存分配的需求背景">一、非连续内存分配的需求背景</h2><h3 id="设计目标">设计目标</h3><ol type="1"><li><strong>解决连续分配的缺陷</strong>：<ul><li><strong>外部碎片</strong>：内存中存在大量不连续的小空闲块，难以利用。<br /></li><li><strong>内部碎片</strong>：分配的块大于实际需求（如伙伴系统）。<br /></li></ul></li><li><strong>支持灵活的内存布局</strong>：<ul><li>允许程序代码、数据、堆栈等分散在物理内存的不同位置。<br /></li><li>便于实现内存共享和保护（如共享库）。</li></ul></li></ol><h3 id="实现方式">实现方式</h3><ul><li><strong>段式管理</strong>：按逻辑模块划分内存（如代码段、数据段）。<br /></li><li><strong>页式管理</strong>：将内存划分为固定大小的页，按需分配。<br /></li><li><strong>段页式管理</strong>：结合段式逻辑划分与页式物理分配。</li></ul><h2 id="二段式存储管理">二、段式存储管理</h2><h3 id="段地址空间">段地址空间</h3><ol type="1"><li><strong>逻辑结构</strong>：<ul><li>进程地址空间由多个段组成，如：<ul><li>主代码段、子模块代码段、堆栈段、堆数据段。<br /></li></ul></li><li><strong>二维地址</strong>：<code>(段号, 段内偏移)</code>。<br /></li></ul></li><li><strong>非连续性</strong>：<ul><li>各段可独立加载到物理内存的任意位置，无需连续。<br />### 段访问机制</li></ul></li><li><strong>硬件实现</strong>：<ul><li><strong>逻辑地址</strong>：<code>(段选择子, 偏移量)</code>。<br /></li><li><strong>段表（GDT/LDT）</strong>：存储段基址和段限长。<br /></li><li><strong>地址转换</strong>：<ul><li>物理地址 = 段基址 + 偏移量。<br /></li><li>检查偏移量是否超过段限长，否则触发异常。<br /></li></ul></li></ul></li><li><strong>优点</strong>：<ul><li>支持内存共享（如多个进程共享代码段）。<br /></li><li>便于模块化编程和保护。<br /></li></ul></li><li><strong>缺点</strong>：<ul><li>外部碎片问题仍存在（段长度可变）。<br /></li><li>段表查找效率较低。</li></ul></li></ol><h2 id="三页式存储管理">三、页式存储管理</h2><h3 id="核心概念">核心概念</h3><ol type="1"><li><strong>页（Page）</strong>：逻辑地址空间划分为固定大小的块（如4KB）。<br /></li><li><strong>帧（Frame）</strong>：物理内存划分为与页大小相同的块。<br /></li><li><strong>地址表示</strong>：<br /></li></ol><ul><li><strong>逻辑地址</strong>：<code>(页号, 页内偏移)</code>。<br /></li><li><strong>物理地址</strong>：<code>(帧号, 帧内偏移)</code>。<br />### 地址转换流程</li></ul><ol type="1"><li><strong>逻辑地址分解</strong>：<ul><li>页号 <code>p = 逻辑地址 / 页大小</code>。<br /></li><li>页内偏移 <code>o = 逻辑地址 % 页大小</code>。<br /></li></ul></li><li><strong>页表查询</strong>：<ul><li>通过页号 <code>p</code> 查询页表，获取对应帧号 <code>f</code>。<br /></li></ul></li><li><strong>物理地址生成</strong>：<ul><li>物理地址 = <code>f * 页大小 + o</code>。<br />### 优缺点</li></ul></li><li><strong>优点</strong>：<br /></li></ol><ul><li>无外部碎片（仅可能有少量内部碎片）。<br /></li><li>支持虚拟内存（按需加载页）。<br /></li></ul><ol start="2" type="1"><li><strong>缺点</strong>：<br /></li></ol><ul><li>页表占用内存大（每个进程需维护一个页表）。<br /></li><li>地址转换需访问内存两次（一次查页表，一次访存），性能低。</li></ul><h2 id="四页表优化技术">四、页表优化技术</h2><h3 id="快表tlb-translation-lookaside-buffer">快表（TLB, Translation Lookaside Buffer）</h3><ol type="1"><li><strong>作用</strong>：缓存近期访问的页表项（<code>页号 → 帧号</code>映射）。<br /></li><li><strong>工作流程</strong>：<ul><li>首先查询TLB，若命中则直接获得帧号。<br /></li><li>若未命中，查询内存中的页表，并更新TLB。<br /></li></ul></li><li><strong>效果</strong>：显著减少地址转换时间（TLB命中时仅需1次访存）。<br />### 多级页表</li><li><strong>问题</strong>：大地址空间（如64位）导致单级页表占用内存过大。<br /></li><li><strong>解决方案</strong>：<ul><li><strong>二级页表</strong>：<ul><li>一级页表：存储二级页表的基址。<br /></li><li>二级页表：存储实际的页表项。<br /></li></ul></li><li><strong>地址转换</strong>：<ul><li>一级索引 = 页号的高位部分。<br /></li><li>二级索引 = 页号的低位部分。<br /></li></ul></li></ul></li><li><strong>优点</strong>：<ul><li>仅需为实际使用的页分配二级页表，节省内存。<br />### 反置页表</li></ul></li><li><strong>设计目标</strong>：解决大地址空间下页表过大的问题。<br /></li><li><strong>结构</strong>：<ul><li><strong>全局唯一页表</strong>：以物理帧为索引，存储 <code>(进程PID, 页号)</code>。<br /></li><li><strong>Hash表</strong>：通过 <code>(PID, 页号)</code> 计算Hash值，快速定位帧号。<br /></li></ul></li></ol><ul><li><strong>优点</strong>：<br />页表大小固定（与物理内存帧数相关）。<br /></li><li><strong>缺点</strong>：<br />Hash冲突需额外处理，增加复杂度。</li></ul><h2 id="五段页式存储管理">五、段页式存储管理</h2><h3 id="设计需求">设计需求</h3><ul><li><strong>结合段式与页式优点</strong>：<ul><li>段式：支持逻辑模块划分和共享。<br /></li><li>页式：解决外部碎片问题。<br />### 实现机制</li></ul></li></ul><ol type="1"><li><strong>地址分解</strong>：<ul><li>逻辑地址 → <code>(段号, 段内偏移)</code>。<br /></li><li>段内偏移 → <code>(页号, 页内偏移)</code>。<br /></li></ul></li><li><strong>地址转换</strong>：<ul><li><strong>段表</strong>：查询段基址（页表基址）。<br /></li><li><strong>页表</strong>：查询帧号。<br /></li><li>物理地址 = 帧号 * 页大小 + 页内偏移。<br />### 内存共享</li></ul></li></ol><ul><li><strong>共享段</strong>：多个进程可共享同一段（如代码段）。<br /></li><li><strong>共享页</strong>：通过页表映射到同一物理帧。<br />### 优缺点</li><li><strong>优点</strong>：<ul><li>兼具段式逻辑灵活性和页式物理高效性。<br /></li></ul></li><li><strong>缺点</strong>：<ul><li>地址转换需两次查表（段表 + 页表），性能开销大。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> 操作系统原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【操作系统原理】 Lecture 5 物理内存管理：连续内存分配</title>
      <link href="/2025/11/05/25-11-3-8-OpSys-5-phy-mem-con/"/>
      <url>/2025/11/05/25-11-3-8-OpSys-5-phy-mem-con/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机体系结构与内存层次">计算机体系结构与内存层次</h2><h3 id="计算机体系结构">计算机体系结构</h3><ol type="1"><li><strong>基础</strong>：基于Intel® 64和IA-32架构，参考官方手册（Intel® 64 and IA-32 Architectures Software Developer Manuals）。<br /></li><li><strong>核心组件</strong>：<br /></li></ol><ul><li><strong>CPU</strong>：执行指令，生成逻辑地址。<br /></li><li><strong>MMU（内存管理单元）</strong>：将逻辑地址转换为物理地址，支持分段和分页。<br /></li><li><strong>总线</strong>：连接CPU、内存和外设。<br />### 内存层次</li></ul><ol type="1"><li><strong>结构</strong>：<br /></li></ol><ul><li><strong>高速缓存（Cache）</strong>：速度快，容量小，减少CPU访问内存延迟。<br /></li><li><strong>主存（RAM）</strong>：存放运行中的程序和数据。<br /></li><li><strong>外存（磁盘）</strong>：持久化存储，用于交换分区（Swapping）。<br /></li></ul><ol start="2" type="1"><li><strong>性能问题</strong>：<br /></li></ol><ul><li><strong>高速缓存未命中</strong>：需从主存加载数据，延迟增加。<br /></li><li><strong>缺页（Page Fault）</strong>：虚拟内存机制中，访问未加载的页需从磁盘读取。</li></ul><h2 id="操作系统的内存管理方式">操作系统的内存管理方式</h2><ol type="1"><li><strong>操作系统中的内存管理方式</strong><ul><li>重定位（relocation）</li><li>分段（segmentation）</li><li>分页（paging）</li><li>虚拟存储（virtual memory）<br />&gt; 目前多数系统（如 Linux）采用<strong>按需页式虚拟存储</strong>。</li></ul></li><li><strong>实现高度依赖硬件</strong><ul><li>MMU（内存管理单元）：处理 CPU 存储访问请求的硬件</li></ul></li></ol><h2 id="地址空间与地址生成">地址空间与地址生成</h2><h3 id="地址空间定义">地址空间定义</h3><table><thead><tr class="header"><th>空间类型</th><th>定义</th><th>范围表示</th></tr></thead><tbody><tr class="odd"><td>物理地址空间</td><td>硬件支持的地址空间</td><td>0 ~ <span class="math inline">\(MAX_{sys}\)</span></td></tr><tr class="even"><td>逻辑地址空间</td><td>在 CPU 运行的<strong>进程</strong>看到的地址</td><td>0 ~ <span class="math inline">\(MAX_{prog}\)</span></td></tr></tbody></table><h3 id="逻辑地址生成">逻辑地址生成</h3><figure><img src="/image/25-11-3-8-OpSys-5-phy-mem-con/1765805173546.webp" alt="1765805173546" /><figcaption aria-hidden="true">1765805173546</figcaption></figure><h3 id="地址生成过程">地址生成过程</h3><ol type="1"><li><strong>CPU</strong><ul><li>ALU：需要逻辑地址的内存内容</li><li>MMU：进行逻辑地址和物理地址的转换</li><li>CPU 控制逻辑：给总线发送物理地址请求</li></ul></li><li><strong>内存</strong><ul><li>发送物理地址的内容给 CPU</li><li>或接收 CPU 数据到物理地址</li></ul></li><li><strong>操作系统</strong><ul><li>建立逻辑地址 LA 和物理地址 PA 的映射</li></ul></li></ol><h3 id="地址检查">地址检查</h3><figure><img src="/image/25-11-3-8-OpSys-5-phy-mem-con/1765805550322.webp" alt="1765805550322" /><figcaption aria-hidden="true">1765805550322</figcaption></figure><h2 id="连续内存分配">连续内存分配</h2><h3 id="连续内存分配与内存碎片">连续内存分配与内存碎片</h3><dl><dt><strong>连续内存分配</strong></dt><dd>给进程分配一块<strong>不小于</strong>指定大小的连续的物理内存区域。</dd><dt><strong>内存碎片</strong></dt><dd>不能被利用的空闲内存。</dd><dt><strong>外部碎片</strong></dt><dd>分配单元之间未使用的内存。</dd><dt><strong>内部碎片</strong></dt><dd>分配单元之间未使用的内存，取决于分配单元大小是否要取整。</dd></dl><h3 id="动态分区分配策略">动态分区分配策略</h3><ol type="1"><li><strong>动态分区分配</strong><ul><li>当程序被加载执行时，分配一个进程指定大小可变的分区（块、内存块）。</li><li>分区的地址是<strong>连续的</strong>。</li></ul></li><li><strong>数据结构</strong><ul><li>所有进程已分配的分区。</li><li>空闲分区（Empty Block）。</li></ul></li><li><strong>最先匹配策略（First Fit Allocation）</strong><ul><li><p><strong>思路</strong><br />分配 <span class="math inline">\(n\)</span> 字节分区时， 查找并使用不小于 <span class="math inline">\(n\)</span> 的最小空闲分区。</p></li><li><p><strong>实现</strong></p><ul><li>空闲分区列表按<strong>地址顺序</strong>排序。</li><li><strong>分配</strong>过程时，搜索一个合适的分区。</li><li><strong>释放</strong>分区时，检查是否可<strong>与临近的空闲分区合并</strong>。</li></ul></li><li><p><strong>优点</strong></p><ul><li>简单</li><li>高地址大块空闲分区</li></ul></li><li><p><strong>缺点</strong></p><ul><li>外部碎片</li><li>分配大块时较慢</li></ul></li></ul></li><li><strong>最佳匹配策略（Best Fit Allocation）</strong></li></ol><h4 id="碎片整理方法"><strong>2. 碎片整理方法</strong></h4><ul><li><strong>紧凑（Compaction）</strong>：<ul><li>移动内存中的进程，使空闲空间连续。<br /></li><li><strong>缺点</strong>：开销大，需暂停所有进程。<br /></li></ul></li><li><strong>分区对换（Swapping）</strong>：<ul><li>将等待状态的进程换出到外存，释放内存空间。<br /></li><li><strong>流程</strong>：<ul><li>选择等待进程（如P2）。<br /></li><li>将其内存数据写入磁盘。<br /></li><li>回收分区供其他进程使用。</li></ul></li></ul></li></ul><h2 id="四伙伴系统buddy-system">四、伙伴系统（Buddy System）</h2><h3 id="核心思想">核心思想</h3><ul><li><strong>分区规则</strong>：内存划分为大小为<code>2^U</code>的块，分配时按需拆分。<br /></li><li><strong>伙伴关系</strong>：两个大小相同、地址连续的块互为“伙伴”，可合并为更大的块。<br />### 分配与释放流程</li></ul><ol type="1"><li><strong>分配示例</strong>：<br /></li></ol><ul><li>请求100K → 分配128K（<code>2^7</code>）。<br /></li><li>请求240K → 分配256K（<code>2^8</code>）。<br /></li></ul><ol start="2" type="1"><li><strong>合并条件</strong>：<br /></li></ol><ul><li>释放的块与其伙伴均为空闲时，合并为更大的块。<br /></li><li><strong>公式</strong>：<code>buddy_addr = block_addr ^ block_size</code>（异或运算）。<br />### 优缺点</li><li><strong>优点</strong>：分配/释放高效，合并算法简单。<br /></li><li><strong>缺点</strong>：可能产生内部碎片（如请求100K却分配128K）。</li></ul><h2 id="五ucore中的物理内存管理">五、ucore中的物理内存管理</h2><h3 id="数据结构设计">数据结构设计</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pmm_manager</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;              <span class="comment">// 管理器名称</span></span><br><span class="line">    <span class="type">void</span> (*init)(<span class="type">void</span>);            <span class="comment">// 初始化</span></span><br><span class="line">    <span class="type">void</span> (*init_memmap)(<span class="keyword">struct</span> Page *base, <span class="type">size_t</span> n); <span class="comment">// 初始化内存映射</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *(*<span class="title">alloc_pages</span>)(<span class="title">size_t</span> <span class="title">order</span>);</span>        <span class="comment">// 分配页（order=2^n）</span></span><br><span class="line">    <span class="type">void</span> (*free_pages)(<span class="keyword">struct</span> Page *base, <span class="type">size_t</span> n);  <span class="comment">// 释放页</span></span><br><span class="line">    <span class="type">size_t</span> (*nr_free_pages)(<span class="type">void</span>);   <span class="comment">// 获取空闲页数</span></span><br><span class="line">    <span class="type">void</span> (*check)(<span class="type">void</span>);            <span class="comment">// 检查一致性</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="伙伴系统实现">伙伴系统实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pmm_manager</span> <span class="title">buddy_pmm_manager</span> =</span> &#123;</span><br><span class="line">    .name = <span class="string">&quot;buddy_pmm_manager&quot;</span>,</span><br><span class="line">    .init = buddy_init,             <span class="comment">// 初始化空闲块链表</span></span><br><span class="line">    .alloc_pages = buddy_alloc_pages, <span class="comment">// 分配页（按order拆分）</span></span><br><span class="line">    .free_pages = buddy_free_pages,   <span class="comment">// 释放页（尝试合并伙伴）</span></span><br><span class="line">    .check = buddy_check,           <span class="comment">// 检查链表一致性</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="关键函数逻辑">关键函数逻辑</h3><ol type="1"><li><strong><code>buddy_alloc_pages</code></strong>：<br /></li></ol><ul><li>查找满足<code>order</code>的最小空闲块。<br /></li><li>若不存在，拆分更大的块并递归分配。<br /></li></ul><ol start="2" type="1"><li><strong><code>buddy_free_pages</code></strong>：<br /></li></ol><ul><li>标记释放的块为空闲。<br /></li><li>检查伙伴是否空闲，是则合并。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> 操作系统原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【操作系统原理】 Lecture 4 实验一 Bootloader 启动 ucore OS</title>
      <link href="/2025/11/05/25-11-3-7-OpSys-4-exp1-bootloader/"/>
      <url>/2025/11/05/25-11-3-7-OpSys-4-exp1-bootloader/</url>
      
        <content type="html"><![CDATA[<h2 id="一x86启动顺序">一、x86启动顺序</h2><h3 id="启动流程">启动流程</h3><ol type="1"><li><strong>BIOS阶段</strong><br /></li></ol><ul><li><strong>初始状态</strong>：<code>CS=0xF000</code>, <code>EIP=0xFFF0</code>，物理地址为<code>0xFFFFFFF0</code>（BIOS EPROM位置）。<br /></li><li><strong>第一条指令</strong>：长跳转（<code>JMP</code>）到BIOS代码区，更新<code>CS:EIP</code>。<br /></li></ul><ol start="2" type="1"><li><strong>加载Bootloader</strong><br /></li></ol><ul><li>BIOS将存储设备（硬盘/USB）的<strong>主引导扇区（MBR，512字节）</strong>加载到内存<code>0x7C00</code>，并跳转执行。<br /></li></ul><ol start="3" type="1"><li><strong>Bootloader任务</strong><br /></li></ol><ul><li><strong>使能保护模式</strong>：设置<code>CR0</code>寄存器的<code>PE</code>位（Bit 0）。<br /></li><li><strong>加载内核</strong>：从硬盘读取ELF格式的ucore内核到内存固定位置。<br /></li><li><strong>跳转执行</strong>：跳转到ucore入口点，移交控制权。<br />### 实模式与保护模式</li></ul><ol type="1"><li><strong>实模式（历史背景）</strong><br /></li></ol><ul><li><strong>寻址方式</strong>：<code>段基址:偏移量</code>（如<code>CS:IP</code>），物理地址 = <code>段基址*16 + 偏移量</code>。<br /></li><li><strong>限制</strong>：20位地址总线，最大1MB空间（<code>0x00000~0xFFFFF</code>），无保护机制。<br /></li><li><strong>中断处理</strong>：中断向量表（IVT）位于内存低地址，<code>INT n</code>通过<code>N*4</code>获取ISR地址。<br /></li></ul><ol start="2" type="1"><li><strong>保护模式</strong><br /></li></ol><ul><li><strong>段机制</strong>：通过<strong>全局描述符表（GDT）</strong>管理段基址和权限，<code>lgdt</code>指令加载GDT。<br /></li><li><strong>特权级</strong>：段描述符包含DPL（描述符特权级），实现内存访问保护。</li></ul><h2 id="二c函数调用实现">二、C函数调用实现</h2><h3 id="栈帧结构">栈帧结构</h3><ol type="1"><li><strong>关键寄存器</strong>：<br /></li></ol><ul><li><code>EBP</code>：栈帧基址指针，固定指向当前函数栈底。<br /></li><li><code>ESP</code>：栈顶指针，动态变化。<br /></li></ul><ol start="2" type="1"><li><strong>调用过程</strong>：<br /></li><li><strong>参数传递</strong>：从右向左压栈（如<code>func(a, b)</code>先压<code>b</code>再压<code>a</code>）。<br /></li><li><strong>返回地址</strong>：<code>CALL</code>指令自动压入下一条指令地址。<br /></li><li><strong>保存旧EBP</strong>：被调函数保存调用者的<code>EBP</code>，并设置新<code>EBP</code>。<br /></li><li><strong>局部变量</strong>：在栈上分配空间（<code>sub $size, %esp</code>）。<br />### 返回与清理</li><li><strong>返回指令</strong>：<code>RET</code>弹出返回地址到<code>EIP</code>。<br /></li><li><strong>栈平衡</strong>：调用者或被调者负责清理参数（取决于调用约定）。<br /></li><li><strong>寄存器保存</strong>：<br /></li></ol><ul><li><strong>被调者保存</strong>：<code>EBX</code>, <code>ESI</code>, <code>EDI</code>, <code>EBP</code>。<br /></li><li><strong>调用者保存</strong>：<code>EAX</code>, <code>ECX</code>, <code>EDX</code>。</li></ul><h2 id="三gcc内联汇编">三、GCC内联汇编</h2><h3 id="基本语法">基本语法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span> (</span><br><span class="line">    <span class="string">&quot;汇编指令模板&quot;</span>         <span class="comment">// 指令序列</span></span><br><span class="line">    : 输出操作数 (可选)     <span class="comment">// 如 &quot;=r&quot;(var)</span></span><br><span class="line">    : 输入操作数 (可选)     <span class="comment">// 如 &quot;r&quot;(value)</span></span><br><span class="line">    : 修改的寄存器 (可选)   <span class="comment">// 如 &quot;eax&quot;, &quot;memory&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol type="1"><li><strong>约束符</strong>：<br /></li></ol><ul><li><code>"r"</code>：任意通用寄存器。<br /></li><li><code>"a"</code>/<code>"b"</code>/<code>"c"</code>/<code>"d"</code>：对应<code>EAX</code>/<code>EBX</code>/<code>ECX</code>/<code>EDX</code>。<br /></li><li><code>"0"</code>：与第0个操作数相同寄存器。<br />### 示例分析</li></ul><ol type="1"><li><strong>示例1：读取CR0寄存器</strong><br /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> cr0;</span><br><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;movl %%cr0, %0&quot;</span> : <span class="string">&quot;=r&quot;</span>(cr0))</span>; <span class="comment">// 输出到变量cr0</span></span><br></pre></td></tr></table></figure></li><li><strong>示例2：系统调用（INT 0x80）</strong><br /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> __res;</span><br><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">    <span class="string">&quot;int $0x80&quot;</span></span></span><br><span class="line"><span class="params">    : <span class="string">&quot;=a&quot;</span>(__res)        <span class="comment">// 返回值在EAX</span></span></span><br><span class="line"><span class="params">    : <span class="string">&quot;0&quot;</span>(<span class="number">11</span>), <span class="string">&quot;b&quot;</span>(arg1) <span class="comment">// 输入：EAX=11, EBX=arg1</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></li><li><strong><code>volatile</code>关键字</strong>：禁止编译器优化或删除汇编代码。</li></ol><h2 id="四x86中断处理">四、x86中断处理</h2><h3 id="中断源分类">中断源分类</h3><table><colgroup><col style="width: 33%" /><col style="width: 33%" /><col style="width: 33%" /></colgroup><thead><tr class="header"><th>类型</th><th>示例</th><th>触发方式</th></tr></thead><tbody><tr class="odd"><td>外部中断</td><td>串口、硬盘、时钟</td><td>硬件信号</td></tr><tr class="even"><td>软件中断</td><td><code>INT n</code>指令（如系统调用）</td><td>显式指令</td></tr><tr class="odd"><td>异常</td><td>除零错误、页故障</td><td>CPU检测到错误</td></tr></tbody></table><h3 id="中断描述符表idt">中断描述符表（IDT）</h3><ul><li><strong>结构</strong>：每个中断对应一个<strong>门描述符</strong>（中断门/陷阱门），存储ISR地址和特权级。<br /></li><li><strong>加载IDT</strong>：<code>lidt</code>指令加载IDTR寄存器（包含IDT基址和大小）。<br />### 中断处理流程</li></ul><ol type="1"><li><strong>保存上下文</strong>：<ul><li><strong>无特权级切换</strong>：压入<code>EFLAGS</code>, <code>CS</code>, <code>EIP</code>, 错误码（可选）。<br /></li><li><strong>特权级切换</strong>：额外压入<code>SS</code>, <code>ESP</code>，切换到内核栈。<br /></li></ul></li><li><strong>跳转ISR</strong>：根据IDT查找ISR地址并执行。<br /></li><li><strong>返回指令</strong>：<code>IRET</code>恢复<code>EFLAGS</code>, <code>CS</code>, <code>EIP</code>（及<code>SS</code>/<code>ESP</code>）。<br />### 系统调用实现</li></ol><ul><li><strong>方式1</strong>：<code>INT n</code>（如<code>INT 0x80</code>），通过IDT跳转到内核服务。<br /></li><li><strong>方式2</strong>：<code>SYSENTER</code>/<code>SYSEXIT</code>（快速系统调用指令）。</li></ul><h3 id="关键参考资料">关键参考资料</h3><ol type="1"><li><strong>Intel手册</strong>：<ul><li>Vol.3 Chap.3（保护模式内存管理）、Chap.6（中断处理）。<br /></li></ul></li><li><strong>ELF格式</strong>：<a href="http://wiki.osdev.org/ELF">OSDev Wiki</a>。<br /></li><li><strong>GCC内联汇编</strong>：<a href="http://www.ibm.com/developerworks/library/l-ia/index.html">IBM开发者文档</a>。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> 操作系统原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【操作系统原理】 Lecture 3 系统启动、中断、异常和系统调用</title>
      <link href="/2025/11/05/25-11-3-6-OpSys-3-interrupt/"/>
      <url>/2025/11/05/25-11-3-6-OpSys-3-interrupt/</url>
      
        <content type="html"><![CDATA[<h2 id="一计算机启动流程">一、计算机启动流程</h2><ol type="1"><li><strong>启动前的硬件状态</strong><ul><li><strong>CPU状态</strong>：PC 指向固定地址（如 x86 的 <code>0xFFFF0</code>），处于特权态（实模式），地址空间有限（x86 为 1 MB）。<br /></li><li><strong>内存布局</strong>：BIOS 固件位于高地址区域，低地址为加载程序预留空间。<br /></li><li><strong>初始化</strong>：硬件自检（POST）、内存控制器初始化、寄存器复位。<br /></li></ul></li><li><strong>启动阶段</strong><ul><li><strong>BIOS阶段</strong>：<ul><li>执行自检程序，初始化硬件（如键盘、串口）。<br /></li><li>加载磁盘引导扇区（512 字节）到内存 <code>0x7C00</code>，跳转执行。<br /></li></ul></li><li><strong>Bootloader阶段</strong>：<ul><li>加载操作系统内核到内存，跳转至 OS 入口。<br /></li></ul></li><li><strong>OS初始化</strong>：<ul><li>初始化数据结构、外设驱动，建立中断处理机制。<br /></li></ul></li></ul></li><li><strong>启动规范</strong><ul><li><strong>传统BIOS</strong>：MBR（主引导记录）→ 分区引导扇区 → OS 加载。<br /></li><li><strong>UEFI</strong>：更现代的固件接口，支持安全启动和大容量磁盘。</li></ul></li></ol><h2 id="二中断异常与系统调用">二、中断、异常与系统调用</h2><ol type="1"><li><strong>定义与分类</strong><br />| 类型 | 触发方式 | 示例（x86） |<br />| — | — | — |<br />| <strong>中断</strong> | 外部设备信号（如键盘、时钟） | INTR（可屏蔽）、NMI（不可屏蔽） |<br />| <strong>异常</strong> | CPU执行指令时的错误或特殊事件 | 页故障（<code>#PF</code>）、除零错误（<code>#DE</code>） |<br />| <strong>系统调用</strong>| 用户程序主动请求内核服务 | <code>int 0x80</code> 或 <code>syscall</code> 指令 |<br /></li><li><strong>处理机制</strong><ul><li><strong>硬件响应</strong>：CPU 保存当前上下文，根据中断向量表跳转至处理程序。<br /></li><li><strong>软件处理</strong>：<ul><li>中断/异常：执行特定处理程序（如缺页处理）。<br /></li><li>系统调用：通过库函数封装，触发内核服务（如 <code>read()</code>）。<br /></li></ul></li></ul></li><li><strong>关键差异</strong><ul><li><strong>同步性</strong>：中断是异步的，异常和系统调用是同步的。<br /></li><li><strong>特权级切换</strong>：系统调用需从用户态切换到内核态，开销高于普通函数调用。</li></ul></li></ol><h2 id="三系统调用实现以-ucore-为例">三、系统调用实现（以 ucore 为例）</h2><ol type="1"><li><strong>调用流程</strong><br /><pre class="mermaid">   graph LRA["用户程序调用read()"] --> B["库函数syscall()"]B --> C["触发int T_SYSCALL"]C --> D["trapentry.S: alltraps"]D --> E["trap.c: trap()识别系统调用"]E --> F["syscall.c: syscall()分发"]F --> G["sys_read()执行文件读取"]G --> H["返回用户态"]</pre></li><li><strong>关键代码点</strong><ul><li><strong>入口</strong>：<code>trapentry.S</code>的<code>alltraps</code>保存寄存器上下文。<br /></li><li><strong>分发</strong>：<code>syscall.c</code>根据<code>eax</code>寄存器中的系统调用号（如<code>SYS_read</code>）跳转至具体实现。<br /></li><li><strong>参数传递</strong>：通过寄存器（如<code>edx</code>、<code>ecx</code>）传递参数。<br /></li></ul></li><li><strong>示例系统调用</strong><ul><li>文件操作：<code>open</code>、<code>read</code>、<code>write</code>、<code>close</code>。<br /></li><li>进程管理：<code>fork</code>、<code>exec</code>、<code>exit</code>。</li></ul></li></ol><h2 id="四中断处理机制">四、中断处理机制</h2><ol type="1"><li><strong>中断嵌套</strong><ul><li>高优先级中断可打断低优先级中断的处理。<br /></li><li>需通过中断屏蔽寄存器（如x86的EFLAGS.IF）控制。<br /></li></ul></li><li><strong>性能开销</strong><ul><li>上下文保存/恢复、特权级切换导致系统调用比函数调用慢。</li></ul></li></ol><h2 id="五总结">五、总结</h2><p>本章深入分析了计算机从加电启动到 OS 运行的完整流程，重点阐述了中断、异常和系统调用的机制与实现。通过 ucore 示例，展示了系统调用的底层细节（如寄存器传递、中断分发），并对比了不同类型事件的处理差异。理解这些内容是掌握操作系统内核设计的基础，尤其对开发高效、可靠的系统服务至关重要。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> 操作系统原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【操作系统原理】 Lecture 2 实验零 操作实验系统实验环境准备</title>
      <link href="/2025/11/05/25-11-3-5-OpSys-2-exp0-env/"/>
      <url>/2025/11/05/25-11-3-5-OpSys-2-exp0-env/</url>
      
        <content type="html"><![CDATA[<h2 id="一了解操作系统os">一、了解操作系统（OS）</h2><ol type="1"><li><strong>核心概念</strong><ul><li><strong>特权机制</strong>：CPU 通过特权级（如 CPL = 0 为最高特权）保护系统安全，特权指令（如<code>LIDT</code>、<code>MOV CRn</code>）只能在特权态执行，否则触发异常。<br /></li><li><strong>中断与异常管理</strong>：包括外设中断、陷阱中断（如系统调用）和故障中断（如缺页异常）。<br /></li><li><strong>内存管理</strong>：<ul><li>分段（Segmentation）和分页（Paging）机制，实现虚拟内存（Virtual Memory）。<br /></li><li>硬件支持：TLB（快表）、MMU（内存管理单元）。<br /></li></ul></li></ul></li><li><strong>OS设计目标</strong><ul><li>高效管理硬件资源（CPU、内存、外设）。<br /></li><li>提供系统调用接口，实现用户态与内核态切换。</li></ul></li></ol><h2 id="二了解硬件">二、了解硬件</h2><ol type="1"><li><strong>计算机体系结构</strong><ul><li><strong>图灵机模型</strong>：有限状态机，通过读写符号和状态转换实现计算。<br /></li><li><strong>冯·诺依曼架构</strong>：<ul><li>组成：CPU（寄存器、执行单元）、内存、磁盘、键盘、显示器等。<br /></li><li>特点：存储程序，指令与数据共享内存。<br /></li></ul></li></ul></li><li><strong>x86硬件特性</strong><ul><li><strong>特权指令</strong>：仅当CPL=0时可执行，否则触发通用保护异常（如<code>LGDT</code>、<code>STI</code>）。<br /></li><li><strong>关键组件</strong>：<ul><li>BIOS ROM（启动固件）、时钟（中断源）、地址/数据信号线。<br /></li></ul></li><li><strong>实验环境</strong>：ucore OS基于x86架构，需理解硬件与OS的交互（如中断处理、内存地址转换）。</li></ul></li></ol><h2 id="三了解编程ucore实现">三、了解编程（ucore实现）</h2><ol type="1"><li><strong>编程基础</strong><ul><li><strong>语言与工具</strong>：C语言为主，结合汇编（如<code>bootasm.S</code>），编译器生成机器码。<br /></li><li><strong>函数调用</strong>：栈帧管理（<code>ebp</code>/<code>esp</code>寄存器），参数传递与返回值处理。<br /></li></ul></li><li><strong>关键数据结构</strong><ul><li><strong>双向循环链表</strong>：<ul><li>通用设计：<code>list_entry</code>结构嵌入宿主结构（如<code>Page</code>），通过<code>le2page</code>宏反向访问宿主。<br /></li><li>示例：物理内存管理中，<code>free_area</code>通过链表管理空闲页。<br /></li></ul></li><li><strong>内存管理结构</strong>：<ul><li><code>pmm_manager</code>：封装物理内存分配/释放接口（如<code>alloc_pages</code>）。<br /></li></ul></li></ul></li><li><strong>编程技巧</strong><ul><li><strong>宏定义</strong>：<code>offsetof</code>计算成员偏移量，<code>to_struct</code>实现链表节点到宿主结构的转换。<br /></li><li><strong>面向对象思想</strong>：函数指针模拟多态（如<code>pmm_manager</code>的<code>init</code>、<code>alloc_pages</code>）。</li></ul></li></ol><h2 id="四了解实验设计">四、了解实验设计</h2><ol type="1"><li><strong>实验目标</strong><ul><li>通过ucore（&lt;1万行代码）覆盖OS核心功能：启动、内存管理、进程调度、文件系统等。<br /></li><li>强调软硬件协同（如中断处理、页表机制）。<br /></li></ul></li><li><strong>实验内容</strong><br />| 实验编号 | 主题 | 关键内容 |<br />|———-|————————–|————————————————————————–|<br />| Lab1 | 启动与中断 | Bootloader、分段机制、中断处理、串口输出。 |<br />| Lab2 | 物理内存管理 | 页表建立、连续内存分配（如<code>pmm_manager</code>）。 |<br />| Lab3 | 虚拟内存管理 | 缺页异常处理、页替换算法（如FIFO）。 |<br />| Lab4 | 内核线程管理 | 线程创建、上下文切换。 |<br />| Lab5 | 用户进程管理 | 系统调用实现、用户态/内核态切换。 |<br />| Lab6 | 进程调度 | 调度器框架（如Round-Robin）。 |<br />| Lab7 | 同步互斥 | 信号量、条件变量、死锁避免。 |<br />| Lab8 | 文件系统 | VFS抽象层、Simple FS实现、缓存机制。 |</li><li><strong>扩展实验</strong><ul><li>移植到ARM/x86-64架构、支持多页替换算法、集成GO语言等。<br /></li></ul></li><li><strong>学习效果</strong><ul><li>结合理论与实践，深入理解OS全局设计（如中断、内存、进程的关联）。<br /></li><li>掌握大型系统软件分析方法（如模块化设计、硬件交互）。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> 操作系统原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【操作系统原理】 Lecture 1 课程概述</title>
      <link href="/2025/11/05/25-11-3-4-OpSys-1-intro/"/>
      <url>/2025/11/05/25-11-3-4-OpSys-1-intro/</url>
      
        <content type="html"><![CDATA[<h2 id="一课程目标与意义">一、课程目标与意义</h2><ol type="1"><li><strong>学习目的</strong><ul><li>掌握操作系统（OS）的基本原理与实现技术。<br /></li><li>通过开发小型OS实践核心阶段（如中断处理、内存管理）。<br /></li><li>深化对计算机系统的整体理解，提升知识应用能力。<br /></li></ul></li><li><strong>OS的重要性</strong><ul><li>计算机科学的基石，连接硬件、软件与应用的核心支撑。<br /></li><li>贯穿程序语言、编译、体系结构等领域，影响专业素质。</li></ul></li></ol><h3 id="二课程结构与内容">二、课程结构与内容</h3><ol type="1"><li><strong>核心教学内容</strong><ul><li>OS结构、中断与系统调用、内存管理、进程/线程、调度、同步互斥、文件系统、I/O子系统。<br /></li></ul></li><li><strong>实验与实践</strong><ul><li><strong>实验序列</strong>：环境准备→系统启动→物理/虚拟内存管理→内核线程→用户进程→调度→同步→文件系统。<br /></li><li><strong>课程设计</strong>：基于RISC-V的ucore OS内核开发。<br /></li></ul></li><li><strong>参考教材</strong><ul><li>《Operating System Concepts》（恐龙书）<br /></li><li>《Operating Systems: Three Easy Pieces》（OSTEP）</li></ul></li></ol><h2 id="三操作系统核心概念">三、操作系统核心概念</h2><ol type="1"><li><strong>定义与地位</strong><ul><li>OS是管理硬件资源、提供用户接口的系统软件，位于硬件与应用之间（承上启下）。<br /></li></ul></li><li><strong>内核特征</strong><ul><li><strong>并发</strong>：多程序同时运行，需调度管理。<br /></li><li><strong>共享</strong>：资源互斥或同时访问。<br /></li><li><strong>虚拟</strong>：通过抽象化（如虚拟内存）提供独占感。<br /></li><li><strong>异步</strong>：程序执行不可预测，需同步机制。<br /></li></ul></li><li><strong>核心能力</strong><ul><li><strong>抽象/虚拟化</strong>：将复杂硬件转化为简单接口（如文件、进程）。</li></ul></li></ol><h2 id="四操作系统分类与演变">四、操作系统分类与演变</h2><ol type="1"><li><strong>主流OS家族</strong><ul><li><strong>UNIX/BSD</strong>：多用户、多任务系统原型。<br /></li><li><strong>Linux</strong>：开源内核，衍生众多发行版。<br /></li><li><strong>Windows</strong>：基于NT内核，主导桌面市场。<br /></li></ul></li><li><strong>历史演变</strong><ul><li><strong>批处理（1955-1965）</strong>：顺序执行作业。<br /></li><li><strong>多道程序（1965-1980）</strong>：内存多程序复用CPU。<br /></li><li><strong>个人/移动OS</strong>：iOS、Android等面向终端用户。<br /></li></ul></li><li><strong>内核架构</strong><ul><li><strong>宏内核</strong>（如Linux）：功能集中，性能高。<br /></li><li><strong>微内核</strong>（如Minix）：最小化内核，用户态服务通过消息通信。<br /></li><li><strong>外核</strong>：资源库化，应用直接管理硬件。<br /></li><li><strong>虚拟机管理器（VMM）</strong>：虚拟化硬件资源。</li></ul></li></ol><h2 id="五学习挑战与方法">五、学习挑战与方法</h2><ol type="1"><li><strong>挑战</strong><ul><li>知识综合性强（需前置计算机组成、数据结构等）。<br /></li><li>实践要求高（需理解底层机制）。<br /></li></ul></li><li><strong>学习方法</strong><ul><li>结合理论（教材）与实践（实验/ucore开发）。<br /></li><li>关注OS研究前沿（如SIGOPS奖项）。</li></ul></li></ol><h2 id="六成绩评定">六、成绩评定</h2><ul><li>总成绩按比例调整：A+/A/A-（25%）、B+/B/B-（45%）、C+/C/C-（20%）、D+/D/F（10%）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> 操作系统原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【STATS 330】 Handout 3 Parameter Estimation for Generalised Linear Models</title>
      <link href="/2025/11/02/25-11-2-1-STATS330-3-param-esti/"/>
      <url>/2025/11/02/25-11-2-1-STATS330-3-param-esti/</url>
      
        <content type="html"><![CDATA[<h2 id="parameter-estimation">Parameter Estimation</h2><p>Parameter estimation involves determining values for a model’s coefficients (or “parameters”) that “best” fit the data at hand.</p><ul><li>For linear regression models, we can use the sum of the<br />squared residuals(<span class="math inline">\(RSS\)</span>).</li><li>For generalised linear models, we can use the likelihood function(<span class="math inline">\(L(p;x)\)</span>).</li></ul><h2 id="least-squares-estimation">Least Squares Estimation</h2><p>The <strong>residual sum of squares</strong> is given by<br /><span class="math display">\[RSS = \sum_{i = 1}^n (y_i - \hat{\mu_i})^2\]</span></p><p>The lower the <span class="math inline">\(RSS\)</span> is, the “better” the candidate set of the parameter is.</p><p>Least squares estimation looks to minimise the sum of the squared differences between observed and expected values. Negative differences have the same effect as positive differences, and so they are treated in the same way. A consequence of this is that least squares is only appropriate when the response distribution is symmetric.</p><h2 id="maximum-likelihood-estimationmle">Maximum Likelihood Estimation(MLE)</h2><p>In general, for GLMs, we estimate coefficients by maximum likelihood. The likelihood fnction is given by<br /><span class="math display">\[L = \prod_{i = 1}^n f_X(y_i; \beta)\]</span></p><p><span class="math inline">\(L\)</span> represents the probability to observe a result more “extreme” than <span class="math inline">\(y_i\)</span> when applying parameters <span class="math inline">\(\beta\)</span>.</p><p>Maximum likelihood estimation involves finding the <span class="math inline">\(\beta\)</span> parameter values that maximise the likelihood function.</p><p>In practice, log-likelihood function is more calculatable<br /><span class="math display">\[l = \log(L) = \sum_{i = 1}^n \log[f_X(y_i; \beta)]\]</span></p><p>The estimated parameters <span class="math inline">\(\hat{\beta}\)</span> will make <span class="math inline">\(L\)</span> or <span class="math inline">\(l\)</span> be in their maximum.</p><h3 id="r-code">R Code</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fit <span class="operator">=</span> glm<span class="punctuation">(</span>y <span class="operator">~</span> x<span class="punctuation">,</span> data <span class="operator">=</span> df<span class="punctuation">,</span> family <span class="operator">=</span> <span class="string">&quot;poisson&quot;</span><span class="punctuation">)</span></span><br><span class="line">logLik<span class="punctuation">(</span>fit<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> STATS 330 Application and Practice of Statistics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 统计学 </tag>
            
            <tag> R 语言 </tag>
            
            <tag> 数据科学 </tag>
            
            <tag> 奥克兰大学—西南大学合作课程 </tag>
            
            <tag> 外文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【STATS 330】 Handout 2 Explanatory Terms and Interpretation</title>
      <link href="/2025/11/02/25-10-31-1-STATS330-2-explanatory/"/>
      <url>/2025/11/02/25-10-31-1-STATS330-2-explanatory/</url>
      
        <content type="html"><![CDATA[<h2 id="intepretation-numeric-explanatory-variables">Intepretation: Numeric Explanatory Variables</h2><h3 id="linear-regression">Linear Regression</h3><p><span class="math display">\[y_i = \beta_0 + \beta_1 x_i + \epsilon_i \\\\\epsilon \sim {\rm iid \ Normal}(0, \sigma_i^2)\]</span></p><ul><li>When <span class="math inline">\(x\)</span> is zero, <strong>the expected value of the response</strong> is <span class="math inline">\(\beta_0\)</span>.</li><li>For every <strong>one-unit</strong> increase in <span class="math inline">\(x\)</span>, <strong>the expected value</strong> of the response increases by <span class="math inline">\(\beta_1\)</span>.</li></ul><h3 id="poisson-regression">Poisson Regression</h3><p><span class="math display">\[\log(\mu_i) = \beta_0 + \beta_1 x_i \\\\Y_i \sim {\rm Poisson}(\mu_i)\]</span></p><ul><li>When <span class="math inline">\(x\)</span> is zero, <strong>the expected value of the response</strong> is <span class="math inline">\(\beta_0\)</span>.</li><li>For every <strong>one-unit</strong> increase in <span class="math inline">\(x\)</span>, <strong>the log of the expected value</strong> of the response increases by <span class="math inline">\(\beta_1\)</span>(or increases <strong>by</strong> <span class="math inline">\(100[\exp(\beta_1) - 1]\%\)</span>).</li><li>For every <strong><span class="math inline">\(n\)</span>-unit</strong> increase in <span class="math inline">\(x\)</span>, <strong>the expected value</strong> of the response in <strong>multiplied</strong> by <span class="math inline">\(\exp(n \beta_1)\)</span>.</li></ul><h3 id="logistic-regression">Logistic Regression</h3><p><span class="math display">\[{\rm logit}(p_i) = \log(\frac{p_i}{1 - p_i}) = \beta_0 + \beta_i x_i \\\\Y_i \sim {\rm Binomial}(n_i, p_i)\]</span></p><ul><li>When <span class="math inline">\(x\)</span> is zero, the <strong>log-odds</strong> of success are equal to <span class="math inline">\(\beta_0\)</span>.</li><li>For every <strong>one-unit</strong> increase in <span class="math inline">\(x\)</span>, the <strong>log-odds</strong> of success increase by <span class="math inline">\(\beta_1\)</span>(or increases <strong>by</strong> <span class="math inline">\(100[\exp(\beta_1) - 1]\%\)</span>).</li><li>For every <strong>n-unit</strong> increase in <span class="math inline">\(x\)</span>, the odds of success are <strong>multiplied</strong> by <span class="math inline">\(\exp(n\beta_1)\)</span>.</li></ul><h2 id="intepretation-factors">Intepretation: Factors</h2><h3 id="single-variable-model">Single-Variable Model</h3><p>To fit a model with <span class="math inline">\(k\)</span>th factors, we include <span class="math inline">\(k - 1\)</span> dummy variables. For example, if we have a factor with levels <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span>, <span class="math inline">\(C\)</span>, and <span class="math inline">\(D\)</span>, then<br /><span class="math display">\[g(\theta_i) = \beta_0 + \beta_1 b_i + \beta_2 c_i + \beta_3 d_i\]</span><br />where<br />- <span class="math inline">\(b_i = 1\)</span> if the <span class="math inline">\(i\)</span>th observation has level <span class="math inline">\(B\)</span>, otherwise <span class="math inline">\(b_i = 0\)</span>;<br />- <span class="math inline">\(c_i = 1\)</span> if the <span class="math inline">\(i\)</span>th observation has level <span class="math inline">\(C\)</span>, otherwise <span class="math inline">\(c_i = 0\)</span>;<br />- <span class="math inline">\(d_i = 1\)</span> if the <span class="math inline">\(i\)</span>th observation has level <span class="math inline">\(D\)</span>, otherwise <span class="math inline">\(d_i = 0\)</span>;</p><p>In general,<br />- <span class="math inline">\(\beta_0\)</span> is the value of <span class="math inline">\(g(\theta)\)</span> for observations with the baseline level(level <span class="math inline">\(A\)</span> here), and<br />- The coefficient of the dummy variable for the <span class="math inline">\(j\)</span>th level is the difference in <span class="math inline">\(g(\theta)\)</span> between observations with the <span class="math inline">\(j\)</span>th level and<br />those with the baseline level.</p><blockquote><p><strong>Caution</strong>:<br />R automatically chooses the <strong>alphabetically</strong> first factor to be the baseline.<br />To cuntomize the settings, please use:<br /><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f <span class="operator">&lt;-</span> factor<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;A&quot;</span><span class="punctuation">,</span> <span class="string">&quot;B&quot;</span><span class="punctuation">,</span> <span class="string">&quot;C&quot;</span><span class="punctuation">,</span> <span class="string">&quot;A&quot;</span><span class="punctuation">,</span> <span class="string">&quot;B&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">f <span class="operator">&lt;-</span> factor<span class="punctuation">(</span>f<span class="punctuation">,</span> levels <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;B&quot;</span><span class="punctuation">,</span> <span class="string">&quot;A&quot;</span><span class="punctuation">,</span> <span class="string">&quot;C&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><br />Then do the model building normally.</p></blockquote><p>A word of warning:<br />- If we wish to determine if a factor is related to the response variable, we should use the <code>anova()</code> function, rather than relying on the p-values in the <code>summary()</code> table.<br />- It is possible for all p-values in the <code>summary()</code> to be large, even though there is evidence of differences between some of the levels of the factor.<br />- This is because the <code>summary()</code> table only compares the baseline level to others. There may be no evidence of differences from the baseline level, <strong>but there may be evidence of differences between non-baseline levels</strong>.</p><h3 id="multiple-variable-model">Multiple-Variable Model</h3><p>For example<br /><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fit <span class="operator">=</span> glm<span class="punctuation">(</span>mo <span class="operator">~</span> dose <span class="operator">+</span> weight<span class="punctuation">,</span> family <span class="operator">=</span> <span class="string">&quot;poisson&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><br />where <code>dose</code> is factorial and <code>weight</code> is numeric.</p><p>Interpretation is the same as for a single-variable model, but must acknowledge that the statements only hold if all other variables in the model are <strong>kept constant</strong>.</p><p>Please refer page 44(old) or page 172(new) for anaiysis code.</p><h2 id="inteepretation-interactions">Inteepretation: Interactions</h2><p><span class="math display">\[g(\theta_i) = \beta_0 + \beta_1 w_i + \beta_2 h_i + \beta_3 l_i + \beta_4 w_ih_i + \beta_5 w_il_i + \beta_6 h_il_i\]</span><br />We will have an interaction term for every possible pair of terms that can be enumerated by taking a main effect from each variable.</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fit <span class="operator">=</span> glm<span class="punctuation">(</span>y <span class="operator">~</span> w <span class="operator">+</span> h <span class="operator">+</span> l <span class="operator">+</span> w<span class="operator">:</span>h <span class="operator">+</span> w<span class="operator">:</span>l <span class="operator">+</span> h<span class="operator">:</span>l<span class="punctuation">)</span></span><br><span class="line">fit <span class="operator">=</span> glm<span class="punctuation">(</span>y <span class="operator">~</span> w <span class="operator">*</span> h <span class="operator">*</span> l<span class="punctuation">)</span> <span class="comment"># for short.</span></span><br></pre></td></tr></table></figure><p>We can interpret the main effects in the same way as we can for models that do not have an interaction, but these interpretations only hold<br />- At the <strong>baseline level</strong> of the other variable, if the other variable is a <strong>factor</strong>; or<br />- When the other variable is <strong>equal to zero</strong>, if the other variable is <strong>numeric</strong>. This is not necessarily sensible to interpret.</p><h2 id="other-model-statement-syntax">Other Model Statement Syntax</h2><p>If you don’t want to include an intercept term, you can use -1 in your model statement. For example, the code below will fit a linear model assuming <span class="math inline">\(\mu_i = \beta_1 x_i\)</span>.<br /><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fit <span class="operator">=</span> lm<span class="punctuation">(</span>y <span class="operator">~</span> <span class="operator">-</span><span class="number">1</span> <span class="operator">+</span> x<span class="punctuation">,</span> data <span class="operator">=</span> df<span class="punctuation">)</span></span><br></pre></td></tr></table></figure></p><h2 id="offsets">Offsets</h2><p>Sometimes a variable has <strong>a known relationship</strong> with the response variable such that its estimation of its effect is <strong>not necessary</strong>. In this scenario we can sometimes use an offset.</p><h3 id="linear-regression-1">Linear Regression</h3><p>From the example in textbook page 50(old) or page 194(new):<br /><span class="math display">\[\mu_i = \beta_0 + \beta_i south_i + shoe_i\]</span><br />where <span class="math inline">\(shoe\)</span> is an offset, because the increases of <span class="math inline">\(\mu\)</span> and <span class="math inline">\(shoe\)</span> are obvoiusly synchronous.</p><p>An offset can be thought of as a variable in the linear combination that does not have a coefficient to be estimated, or, equivalently, has a coefficient fixed at 1.</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fit <span class="operator">=</span> lm<span class="punctuation">(</span>height <span class="operator">~</span> island<span class="punctuation">,</span> offset <span class="operator">=</span> shoe<span class="punctuation">,</span> data <span class="operator">=</span> height.df<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><h3 id="poisson-regression-1">Poisson Regression</h3><p>Offsets are most commonly used in Poisson regression, because they allow us to incorporate variables that measures the “exposure” of each observation to the events being counted.</p><p>From the example on textbook page 202(new) or page 52(old):<br /><span class="math display">\[\log(\mu_i) = \beta_0 + \beta_1 t_i + \ldots + \log(s_i) \\\\Y_i \sim {\rm Poisson}(\mu_i)\]</span><br />where <span class="math inline">\(\log(s_i)\)</span> is an offset.</p><h2 id="other-glm-arguments">Other <code>glm()</code> Arguments</h2><h3 id="subset"><code>subset</code></h3><p>The subset function allows us to fit our model to only <strong>a subset of the observations</strong> in a data frame. Similarly to subsetting vectors in R, this can be done by <strong>position</strong> or via a <strong>logical statement</strong>.</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fit <span class="operator">=</span> glm<span class="punctuation">(</span>incidents <span class="operator">~</span> time <span class="operator">+</span> type<span class="punctuation">,</span> offset <span class="operator">=</span> <span class="built_in">log</span><span class="punctuation">(</span>service<span class="punctuation">)</span><span class="punctuation">,</span> family <span class="operator">=</span> <span class="string">&quot;poisson&quot;</span><span class="punctuation">,</span> data <span class="operator">=</span> ships.df<span class="punctuation">,</span> subset <span class="operator">=</span> <span class="operator">-</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">17</span><span class="punctuation">,</span> <span class="number">23</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">fit <span class="operator">=</span> glm<span class="punctuation">(</span>incidents <span class="operator">~</span> time <span class="operator">+</span> type<span class="punctuation">,</span> offset <span class="operator">=</span> <span class="built_in">log</span><span class="punctuation">(</span>service<span class="punctuation">)</span><span class="punctuation">,</span> family <span class="operator">=</span> <span class="string">&quot;poisson&quot;</span><span class="punctuation">,</span> data <span class="operator">=</span> ships.df<span class="punctuation">,</span> subset <span class="operator">=</span> <span class="punctuation">(</span>type <span class="operator">!=</span> <span class="string">&quot;D&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><h3 id="na.action"><code>na.action</code></h3><p>The <code>na.action</code> argument controls what happens if you try to fit a model to a data set with missing values.</p><ul><li><code>na.action = na.omit</code> will remove any observations with <strong>missing values</strong> and fit the model. This is sensible enough, but you might not realise this has happened.</li><li><code>na.action = na.fail</code> will result in <code>glm()</code> <strong>returning an error</strong> if there are any missing values.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> STATS 330 Application and Practice of Statistics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 统计学 </tag>
            
            <tag> R 语言 </tag>
            
            <tag> 数据科学 </tag>
            
            <tag> 奥克兰大学—西南大学合作课程 </tag>
            
            <tag> 外文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【STATS 330】 Handout 1 A Synthesis of Generalised Linear Models</title>
      <link href="/2025/10/31/25-10-16-1-STATS330-1-synthesis-glm/"/>
      <url>/2025/10/31/25-10-16-1-STATS330-1-synthesis-glm/</url>
      
        <content type="html"><![CDATA[<h2 id="linear-regression">Linear Regression</h2><p>Simple linear regression model is:<br /><span class="math display">\[y_i = \beta_0 + \beta_1 x_i + \epsilon_i \\\\\epsilon_i \sim {\rm iid \ Normal(0, \sigma^2)}\]</span></p><h2 id="poisson-linear-regression">Poisson Linear Regression</h2><h3 id="macrorhabdus-ornithogaster-chicken-analysis">Macrorhabdus Ornithogaster Chicken Analysis</h3>Textbook Page 23:<br /><img src="/image/25-10-16-1-STATS330-synthesis-glm/mo.webp" /><br /><center><small><div style="color: #666666">Macrorhabdus Ornithogaster Chicken Data</div></small></center><h3 id="data-suitable-for-using-poisson-distribution">Data Suitable for Using Poisson Distribution</h3><p>The Poisson distribution better reflects the nature of the response:<br />- It is a discrete distribution<br />- It is right skewed (but almost symmetric when µ is large)<br />- It does not allow the response to be negative<br />- It assumes that the variance increases with the mean</p><h3 id="poisson-linear-regression-1">Poisson Linear Regression</h3><p>We use a <strong>link function</strong> to map our parameter of interest, <span class="math inline">\(\mu_i\)</span> to the real number line:<br /><span class="math display">\[\log(\mu_i) = \beta_0 + \beta_1 x_i\]</span></p><p>Poisson Regression formula:<br /><span class="math display">\[\mu_i = \exp(\beta_0 + \beta_1 x_i) \\\\Y_i \sim {\rm Poisson}(\mu_i)\]</span></p><h2 id="binomial-linear-regression">Binomial Linear Regression</h2><h3 id="coronary-heart-disease-analysis">Coronary Heart Disease Analysis</h3><p><img src="/image/25-10-16-1-STATS330-synthesis-glm/chd.webp" /></p><h3 id="data-suitable-for-using-binomial-distribution">Data Suitable for Using Binomial Distribution</h3><p>The binomial distribution better reflects the nature of the<br />response:<br />- It is a discrete distribution.<br />- It acknowledges that the number of successes associated with the <span class="math inline">\(i\)</span>th observation must be an integer between <span class="math inline">\(0\)</span> and <span class="math inline">\(n_i\)</span>.<br />- It accounts for nonconstant variance in a sensible way.</p><h3 id="binomial-linear-regression-1">Binomial Linear Regression</h3><p>For logistic regression, the standard link function is the logit function:<br /><span class="math display">\[{\rm logit}(p_i) = \log(\frac{p_i}{1 - p_i}) = \beta_0 + \beta_i x_i\]</span></p><p>Binomial linear regression formula:<br /><span class="math display">\[p_i = \frac{\exp(\beta_0 + \beta_i x_i)}{1 + \exp(\beta_0 + \beta_i x_i)} \\\\Y_i \sim {\rm Binomial}(n_i, p_i)\]</span></p><h2 id="generalized-linear-model">Generalized Linear Model</h2><p><span class="math display">\[g(\theta_i) = \beta_0 + \beta_1 x_i + \ldots \\\\Y_i \sim {\rm Distribution}(\theta_i, \gamma_i)\]</span></p><p>Code:<br /><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fit <span class="operator">=</span> glm<span class="punctuation">(</span>y <span class="operator">~</span> x<span class="punctuation">,</span> family <span class="operator">=</span> <span class="string">&quot;distribution&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure></p><blockquote><p><strong>Caution</strong>:<br /><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lm<span class="punctuation">(</span>y <span class="operator">~</span> x<span class="punctuation">,</span> data <span class="operator">=</span> df<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><br />is the same as<br /><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm<span class="punctuation">(</span>y <span class="operator">~</span> x<span class="punctuation">,</span> data <span class="operator">=</span> df<span class="punctuation">,</span> family <span class="operator">=</span> <span class="string">&quot;gaussian&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure></p></blockquote><h2 id="matrix-represetation">Matrix Represetation</h2><p><span class="math display">\[g(\boldsymbol{\theta}) = \textit{\textbf{X}}\boldsymbol{\beta}\]</span></p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">[</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><mi>g</mi><mo stretchy="false">(</mo><msub><mi>θ</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mtd></mtr><mtr><mtd><mi>g</mi><mo stretchy="false">(</mo><msub><mi>θ</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mtd></mtr><mtr><mtd><mi>g</mi><mo stretchy="false">(</mo><msub><mi>θ</mi><mn>3</mn></msub><mo stretchy="false">)</mo></mtd></mtr><mtr><mtd><mi>g</mi><mo stretchy="false">(</mo><msub><mi>θ</mi><mn>4</mn></msub><mo stretchy="false">)</mo></mtd></mtr><mtr><mtd><mrow><mo>⋮</mo></mrow></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">]</mo></mrow><mo>=</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">[</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><mn>1</mn></mtd><mtd><msub><mi>x</mi><mn>1</mn></msub></mtd></mtr><mtr><mtd><mn>1</mn></mtd><mtd><msub><mi>x</mi><mn>2</mn></msub></mtd></mtr><mtr><mtd><mn>1</mn></mtd><mtd><msub><mi>x</mi><mn>3</mn></msub></mtd></mtr><mtr><mtd><mn>1</mn></mtd><mtd><msub><mi>x</mi><mn>4</mn></msub></mtd></mtr><mtr><mtd><mrow><mo>⋮</mo></mrow></mtd><mtd><mrow><mo>⋮</mo></mrow></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">]</mo></mrow><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">[</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><msub><mi>β</mi><mn>0</mn></msub></mtd></mtr><mtr><mtd><msub><mi>β</mi><mn>1</mn></msub></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">]</mo></mrow><mo>=</mo><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">[</mo><mtable columnspacing="1em" rowspacing="4pt"><mtr><mtd><msub><mi>β</mi><mn>0</mn></msub><mo>+</mo><msub><mi>β</mi><mn>1</mn></msub><msub><mi>x</mi><mn>1</mn></msub></mtd></mtr><mtr><mtd><msub><mi>β</mi><mn>0</mn></msub><mo>+</mo><msub><mi>β</mi><mn>1</mn></msub><msub><mi>x</mi><mn>2</mn></msub></mtd></mtr><mtr><mtd><msub><mi>β</mi><mn>0</mn></msub><mo>+</mo><msub><mi>β</mi><mn>1</mn></msub><msub><mi>x</mi><mn>3</mn></msub></mtd></mtr><mtr><mtd><msub><mi>β</mi><mn>0</mn></msub><mo>+</mo><msub><mi>β</mi><mn>1</mn></msub><msub><mi>x</mi><mn>4</mn></msub></mtd></mtr><mtr><mtd><mrow><mo>⋮</mo></mrow></mtd></mtr></mtable><mo data-mjx-texclass="CLOSE">]</mo></mrow></math></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> STATS 330 Application and Practice of Statistics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 统计学 </tag>
            
            <tag> R 语言 </tag>
            
            <tag> 数据科学 </tag>
            
            <tag> 奥克兰大学—西南大学合作课程 </tag>
            
            <tag> 外文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Hexo 折腾手册】 （零）准备</title>
      <link href="/2025/10/29/25-10-29-1-HexoBui-intro/"/>
      <url>/2025/10/29/25-10-29-1-HexoBui-intro/</url>
      
        <content type="html"><![CDATA[<h2 id="一什么是博客网站">一、什么是博客网站？</h2><p>博客是一种通常由个人维护、按时间顺序发布文章的在线平台，它既是作者表达观点、分享知识与记录生活的数字空间，也是与读者进行互动交流的社区。其内容包罗万象，从技术、旅行到美食、时事无所不包，凭借其个性化、即时性和互动性的特点，博客不仅塑造了无数网络意见领袖，也极大地丰富了互联网的内容生态，成为信息传播与思想碰撞的重要载体。一般来讲，仅用静态网站就可完成博客网站的本职工作。</p><h2 id="二什么是静态网站">二、什么是静态网站？</h2><p>静态网站是由预先构建好的 HTML、CSS 和 JavaScript 等固定文件组成的网页，其内容对所有访问者都完全相同，不会根据用户交互或时间而改变。由于服务器只需直接发送这些现成文件，无需执行复杂的数据库查询或服务器端脚本，静态网站因此具有加载速度快、安全性高、托管成本低且易于维护的优点，非常适合用于作品集、文档站点、企业宣传页等内容更新不频繁的场景。由于服务器端只管发送文件，不做计算，因此使用纯前端技术即可实现。</p><h2 id="三什么是前端技术">三、什么是前端技术？</h2><p>前端技术是指用于构建用户在浏览器中直接交互的网页界面的一系列技术和工具，核心包括HTML（结构）、CSS（样式）和JavaScript（行为），以及各类现代框架如 React、Vue 和 Angular 等。前端技术不仅关注页面的美观与交互体验，还涉及响应式设计、性能优化、可访问性和跨浏览器兼容性，是连接用户与后端服务的桥梁，对提升用户体验和产品价值至关重要。</p><h2 id="四环境准备">四、环境准备</h2><p>你的<a href="https://www.bilibili.com/video/BV1Sh4y197V9/?spm_id_from=333.337.search-card.all.click&amp;vd_source=db9a6ea0eb211a378d71c7ae1c33c3d2" title="电脑">颠佬</a>需要安装：<br />- <a href="https://nodejs.cn/download/">Node.js</a><br />- <a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git">Git</a><br />- 一个趁手的文本编辑器</p><h3 id="node.js">Node.js</h3><p>参考教程<a href="https://www.runoob.com/nodejs/nodejs-install-setup.html">Node.js 安装配置 - 菜鸟教程</a>。</p><p>记得带上 npm。</p><h3 id="git">Git</h3><p>我确信那个安装网页已经给出了很好的教程。</p><p>如果您认为教程不够完善，请继续参考教程<a href="https://www.runoob.com/git/git-tutorial.html">Git 教程 - 菜鸟教程</a></p><h3 id="一个趁手的文本编辑器">一个趁手的文本编辑器</h3><p>这个没有唯一的答案。我认为一个趁手的开发博客的文本编辑器至少要满足：</p><ul><li>能编辑文本（妃话）。</li><li>对 Markdown 语言有部分适配（网页文章一般用 Markdown 撰写）。</li></ul><p>这里推荐：<br />1. <strong><a href="https://www.jetbrains.com/webstorm/">JetBrains WebStorm</a></strong><br />一个专业的前端编程 IDE。在之前替代的功能基础上，还增加了<br />- 多种 Web 前端语言代码适配（高亮、提示、调试、导航等）。<br />- Git 图形化版本管理。<br />- 插件功能扩展。<br />- 文件树视图。<br />- 当然还有每个 IDE 都想插把手的 AI 等。</p><pre><code>只是 WebStorm **原则上**是要收费的（非商业使用似乎是不收费的）。而且对于只是写写 Markdown 来说未免也太专业了。  [WebStorm 基础使用教程](https://www.bilibili.com/video/BV1f54y1q755/?share_source=copy_web&amp;vd_source=bfc7780b4d87787a0b9eb0f559d0c029)</code></pre><ol start="2" type="1"><li><p><strong><a href="https://code.visualstudio.com/">Visual Studio Code（本人在用）</a></strong><br />微修死丢丢扣的是微软出品的一款轻量开源的文本编辑器，原生带有 JavaScript、TypeScript、Markdown 代码高亮，此外还有原生 Markdown 预览。文件树视图也可快速帮用户定位文件。微修死丢丢扣的具有丰富的插件生态，上述提到的功能均可通过插件进行增强。<br /><a href="https://www.bilibili.com/video/BV1mh9NYvEwH/?spm_id_from=333.337.search-card.all.click&amp;vd_source=db9a6ea0eb211a378d71c7ae1c33c3d2">Visual Studio Code 基础使用</a></p></li><li><p><strong><a href="https://typoraio.cn/">Typora</a></strong><br />Typora 是一款专业的 Markdown 综合编辑器。Typora 具有优秀的“所见即所得”的编辑模式，原生支持大量 Markdown 语法（标题、强调、引用、图片、LaTeX 公式、代码与代码块等），具有一站式的功能覆盖。Typora 同样支持文件树视图，方便用户快速查找。<br />Typora <strong>原则上</strong>也是收费的。不同于以上提到的面向编程的编辑器，Typora 仅在 Markdown 相关文件格式支持最佳，在编辑其他种类格式的配置文件时可能造成格式误认造成高亮错误。<br /><a href="https://www.bilibili.com/video/BV1kq4y1y7Hn/?spm_id_from=333.337.search-card.all.click&amp;vd_source=db9a6ea0eb211a378d71c7ae1c33c3d2">Typora 基础使用</a></p></li><li><p><strong>Windows Notepad</strong><br />Windows 系统下按下 <code>Win + R</code>，输入 <code>notepad</code>，你将启动世界上最为圣洁的文本编辑器——记事本！（连 Linux Vim 都有 Markdown 高亮啊喂）<br />自 Windows 11.2504.50.0，记事本对 Markdown 还真有部分支持（做了一半的预览，哪怕有高亮也行啊）。</p></li></ol><h3 id="服务器配置">服务器配置</h3><p>这部分我就不太了解了，毕竟我的网站不是在单独的服务器上的。</p><p>引流：<br />- <a href="https://zbshlv.fun/2025/03/06/hexo部署到服务器上/">hexo部署到服务器上 - zbshlv</a><br />- <a href="https://zhuanlan.zhihu.com/p/120743882">将hexo个人博客部署到个人云服务器–最详细踩坑教程 - GanAHE</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 网站 </category>
          
          <category> Hexo </category>
          
          <category> Hexo 网站搭建与配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 网站 </tag>
            
            <tag> Hexo 折腾手册 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网站渲染测试</title>
      <link href="/2025/10/21/25-10-21-1-HexoDev-test-post/"/>
      <url>/2025/10/21/25-10-21-1-HexoDev-test-post/</url>
      
        <content type="html"><![CDATA[<p>这是一个用于测试网站渲染功能的帖子，如果发现异常请及时报告作者哦（如果是可选语法或标明我不常用就不用了哈）！</p><h2 id="一markdown-标题语法">一、Markdown 标题语法</h2><h3 id="标准语法">1. 标准语法</h3><h1 id="一级标题">一级标题</h1><h1>使用 HTML 标签的一级标题</h1><h2 id="二级标题">二级标题</h2><h2>使用 HTML 标签的二级标题</h2><h3 id="三级标题">三级标题</h3><h3>使用 HTML 标签的三级标题</h3><h4 id="四级标题">四级标题</h4><h4>使用 HTML 标签的四级标题</h4><h5 id="五级标题">五级标题</h5><h5>使用 HTML 标签的五级标题</h5><h6 id="六级标题">六级标题</h6><h6>使用 HTML 标签的六级标题</h6><h3 id="可选语法">2. 可选语法</h3><h1 id="一级标题-1">一级标题</h1><h2 id="二级标题-1">二级标题</h2><h2 id="二markdown-段落语法">二、Markdown 段落语法</h2><p>（正文）逸一时，误一世。逸久逸久罢已龄。</p><p>（HTML 正文）逸一时，误一世。逸久逸久罢已龄。</p><h2 id="三markdown-换行语法">三、Markdown 换行语法</h2><p>第一段</p><p>第二段</p><p>使用行尾两空格换行<br />使用行尾两空格换行</p><p>使用 HTML 标签换行<br>使用 HTML 标签换行</p><h2 id="四markdown-强调语法">四、Markdown 强调语法</h2><p>不好，我被<strong>星号加粗</strong>了！</p><p>不好，我被 <strong>下划线加粗</strong> 了！（我不常用）</p><p>不好，我被<strong>HTML 加粗</strong>了！（我不常用）</p><p>不好，我被<em>星号加斜体</em>了！<br />Has this font been adapted to <em>italics</em>?<br />Этот шрифт адаптирован для <em>русской</em> курсивной версии?<br />Αυτό το γραμματοσειρά έχει προσαρμοστεί για πλάγια γράμματα στα <em>ελληνικά</em>;</p><p>不好，我被 <em>下划线加斜体</em> 了！（我不常用）</p><p>不好，我被<i>HTML 加斜体</i>了！</p><p>不好，我被<em>HTML 强调性加斜体</em>了！（我不常用）</p><p>不好，我被<strong><em>星号加粗斜体</em></strong>了！</p><p>不好，我被 <strong><em>下划线加粗斜体</em></strong> 了！（我不常用）</p><p>不好，我被 <strong><em>HTML 加粗斜体</strong></em> 了！（我不常用）</p><h2 id="五markdown-引用语法">五、Markdown 引用语法</h2><p>你 Daddy 我曾经说过：<br />&gt; 你在成都只能算得上是个<br />&gt;<br />&gt; 萝莉！</p><h2 id="六markdown-列表语法">六、Markdown 列表语法</h2><ol type="1"><li>逸一时，</li><li>误一世。</li><li>逸久逸久罢已龄。</li></ol><ul><li>逸一时，</li><li>误一世。</li><li>逸久逸久罢已龄。</li></ul><h2 id="七代码语法">七、代码语法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python Highlighting Test</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 基本配置</span></span><br><span class="line"><span class="comment"># level=logging.DE<span class="doctag">BUG:</span> 设置记录的最低级别为 DEBUG</span></span><br><span class="line"><span class="comment"># format=&#x27;...&#x27;: 设置日志的输出格式</span></span><br><span class="line">logging.basicConfig(</span><br><span class="line">    level=logging.DEBUG,</span><br><span class="line">    <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*C Highlighting Test*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123; <span class="comment">// Main Function</span></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入两个整数: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;它们的和是: %d\n&quot;</span>, add(x, y));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Linux Script Highlighting Test</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置警告阈值（百分比）</span></span><br><span class="line">THRESHOLD=90</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取根分区当前使用率，并去掉百分号</span></span><br><span class="line">USAGE=$(<span class="built_in">df</span> / | <span class="built_in">tail</span> -1 | awk <span class="string">&#x27;&#123;print $5&#125;&#x27;</span> | sed <span class="string">&#x27;s/%//&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较使用率与阈值</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$USAGE</span>&quot;</span> -gt <span class="string">&quot;<span class="variable">$THRESHOLD</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;警告：磁盘空间不足！当前使用率 <span class="variable">$&#123;USAGE&#125;</span>%。&quot;</span> | mail -s <span class="string">&quot;磁盘空间警告&quot;</span> your_email@example.com</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># R Highlighting Test</span></span><br><span class="line"><span class="comment"># 加载ggplot2包并绘制散点图</span></span><br><span class="line">library<span class="punctuation">(</span>ggplot2<span class="punctuation">)</span></span><br><span class="line">ggplot<span class="punctuation">(</span>iris<span class="punctuation">,</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> Sepal.Length<span class="punctuation">,</span> y <span class="operator">=</span> Sepal.Width<span class="punctuation">,</span> color <span class="operator">=</span> Species<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">    geom_point<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">    theme_minimal<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% MATLAB Highlighting Test</span></span><br><span class="line"><span class="comment">% 定义系数矩阵A和结果向量b</span></span><br><span class="line">A = [<span class="number">2</span>, <span class="number">1</span>; <span class="number">-1</span>, <span class="number">3</span>];</span><br><span class="line">b = [<span class="number">5</span>; <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">% 求解线性方程组 Ax = b</span></span><br><span class="line">x = A \ b; <span class="comment">% 使用反斜杠运算符</span></span><br><span class="line"><span class="built_in">disp</span>(x);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Plain Text Test</span><br><span class="line"></span><br><span class="line">什么？我就会这些语言啊。</span><br></pre></td></tr></table></figure><p>（行内代码）<br />这个网站是由 <code>Markdown 语言</code> 文章组成的。</p><h2 id="八markdown-链接语法">八、Markdown 链接语法</h2><p>有问题，找<a href="https://www.baidu.com/">度娘</a></p><p>有问题，找<a href="https://www.baidu.com/" title="你不会连百度都不会吧">有悬浮标题的度娘</a></p><p>有问题，找<a href="https://www.baidu.com/" class="uri">https://www.baidu.com/</a></p><p>有问题，找 <strong><a href="https://www.baidu.com/">加粗的度娘</a></strong></p><p>有问题，找 <em><a href="https://www.baidu.com/">加斜体的度娘</a></em></p><p>有问题，找 <a href="https://www.baidu.com/"><code>变成代码的度娘</code></a></p><h2 id="九markdown-图片语法">九、Markdown 图片语法</h2><p>（由于 Hexo 与 VSCode 对图片路径解释的差异，本图再源代码库内无法用 VSCode 显示）<br /><img src="/image/background/ping_an_station.webp" alt="平安站" /></p><h2 id="十markdown-转义字符语法">十、Markdown 转义字符语法</h2><p>（不应该被渲染为列表）<br />- 逸一时，<br />- 误一世。<br />- 逸久逸久罢已龄。</p><h2 id="十一markdown-表格">十一、Markdown 表格</h2><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><tbody><tr class="odd"><td>Date</td><td>Sept. 28, 2025</td></tr><tr class="even"><td>Description</td><td>The first formal version of <a href="/">remy-campanella.github.io</a>. Basic functions are ready and <code>hexo clean</code>ed.</td></tr></tbody></table><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th>Subject</th><th>Content</th></tr></thead><tbody><tr class="odd"><td>Date</td><td>Sept. 28, 2025</td></tr><tr class="even"><td>Description</td><td>The first formal version of <a href="/">remy-campanella.github.io</a>. Basic functions are ready and <code>hexo clean</code>ed.</td></tr></tbody></table><ol type="1"><li><strong>带缩进的表格</strong><br />| Subject | Content |<br />| — | — |<br />| Date | Sept. 28, 2025 |<br />| Description | The first formal version of <a href="/">remy-campanella.github.io</a>. Basic functions are ready and <code>hexo clean</code>ed. |</li></ol><h2 id="十二-markdown-latex">十二、 Markdown LaTeX</h2><p><strong>Probability Mass Function(pmf)</strong> <span class="math inline">\(f_X(x)\)</span><br /><span class="math display">\[f_X(x) = {\rm P}(X = x)  \ \text{for all possible} \ x\]</span></p><p><strong>Uniform Distribution</strong><br /><span class="math display">\[f_X(x) = \begin{cases}    \frac{1}{b - a} &amp; a &lt; x &lt; b \\\\    0 &amp; \text{otherwise}\end{cases}\]</span></p><p>（带缩进的公式们）<br />1. <strong>Probability Mass Function(pmf)</strong> <span class="math inline">\(f_X(x)\)</span><br /><span class="math display">\[   f_X(x) = {\rm P}(X = x)  \ \text{for all possible} \ x   \]</span></p><ol start="2" type="1"><li><strong>Uniform Distribution</strong><br /><span class="math display">\[f_X(x) = \begin{cases}    \frac{1}{b - a} &amp; a &lt; x &lt; b \\\\    0 &amp; \text{otherwise}\end{cases}\]</span></li></ol>]]></content>
      
      
      <categories>
          
          <category> 本站 </category>
          
          <category> 更新 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> log </tag>
            
            <tag> Node.js </tag>
            
            <tag> 前端工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【STATS 330】 Introduction</title>
      <link href="/2025/10/20/25-10-16-1-STATS330-intro/"/>
      <url>/2025/10/20/25-10-16-1-STATS330-intro/</url>
      
        <content type="html"><![CDATA[<p>This course is about statistical modelling. We will expand on the <strong>generalised linear model (GLM)</strong> encountered in STATS 201/8. It comprises four parts:</p><ol type="1"><li>Generalised linear models</li><li>Simulation and bootstrapping</li><li>Regression models for prediction</li><li>Regression models for explanation</li></ol><p>This course provides a versatile statistical toolbox that is useful in a range of fields, including almost all subjects in business and economics, along with experimental or social science.</p><p><a href="https://courseoutline.auckland.ac.nz/dco/course/STATS/330/1215">Course Link</a></p><p>Prof. Jing Liu’s Email: <em>liu.jing@aukland.ac.nz</em></p><h2 id="focus">Focus</h2><ul><li>Understanding</li><li>Modelling: Choose a model.</li><li>Interpreting: Understanding why you’ve done this.</li><li>Programming</li></ul><h2 id="reminiscences-de-stats-210">Reminiscences de STATS 210</h2><h3 id="distributions">Distributions</h3><ol type="1"><li><p><strong>Probability Mass Function(pmf)</strong> <span class="math inline">\(f_X(x)\)</span><br /><span class="math display">\[f_X(x) = {\rm P}(X = x)  \ \text{for all possible} \ x\]</span></p></li><li><p><strong>Cumulative Distribution Function(cmf)</strong> <span class="math inline">\(F_X(x)\)</span><br /><span class="math display">\[F_X(x) = P(X \leq x), x \in \mathbf{R}\]</span></p></li></ol><h3 id="frequently-used-distributions">Frequently Used Distributions</h3><ol type="1"><li><p><strong>Bernoulli Distribution</strong><br /><span class="math display">\[Y \sim {\rm Berrnoulli}(p)\]</span><br /><span class="math display">\[f_Y(y) = \begin{cases}     p &amp; y = 1 \\\\     1 - p &amp; y = 0 \end{cases}\]</span><br /><span class="math display">\[F_Y(y) = \begin{cases}     0 &amp; y &lt; 0 \\\\     1 - p &amp; 0 \leq y &lt; 1 \\\\     1 &amp; y \geq 1 \end{cases}\]</span><br /><span class="math display">\[\mathbb{E}[Y] = p, {\rm Var}(Y) = p(1 - p)\]</span></p></li><li><p><strong>Binominal Distribution</strong><br />Let <span class="math inline">\(X\)</span> be the number of “successes” in <span class="math inline">\(n\)</span> independent Bernoulli trials, where each trial has a probability <span class="math inline">\(p\)</span> of “success”.<br /><span class="math display">\[Y \sim {\rm Binominal}(n, p)\]</span><br /><span class="math display">\[f_X(x) = \binom{n}{x}p^x(1 - p)^{n - x} \\\\x \in \mathbf{N}\]</span><br /><span class="math display">\[\mathbb{E}[Y] = np, {\rm Var}(Y) = np(1 - p)\]</span></p></li><li><p><strong>Hypergeometric Distribution</strong><br />Let <span class="math inline">\(X\)</span> be the number of “successes” in <span class="math inline">\(n\)</span> draws from a finite number of items <span class="math inline">\(N\)</span>, of which <span class="math inline">\(M\)</span> are “successes”.<br /><span class="math display">\[Y \sim {\rm Hypergeometric}(n, M, n)\]</span><br /><span class="math display">\[f_X(x) = \frac{\binom{M}{X}\binom{N - M}{n - x}}{\binom{N}{n}} \\\\x \in [\max(0, n - N + M), \min(n, M)] \cap \mathbf{Z}\]</span><br /><span class="math display">\[\mathbb{E}[Y] = \frac{nM}{N}, {\rm Var}(Y) = n \frac{M}{N}(1 - \frac{M}{N}) \frac{N - n}{N - 1}\]</span></p></li><li><p><strong>Poisson Distribution</strong><br />A Poisson process counts the number of events occurring in a fixed time (or space),when events occur independently, at a constant average rate of <span class="math inline">\(\lambda\)</span> per unit time and events cannot occur simultaneously.<br /><span class="math display">\[Y \sim {\rm Poisson}(\lambda)\]</span><br /><span class="math display">\[f_X(x) = \frac{\lambda^x}{x!}e^{-\lambda} \\\\x \in \mathbf{N}\]</span><br /><span class="math display">\[\mathbb{E}[Y] = \lambda, {\rm Var}(Y) = \lambda\]</span></p></li><li><p><strong>Negative Binominal Distribution</strong><br />Let <span class="math inline">\(X\)</span> be the number of “failures” before the <span class="math inline">\(k\)</span>th “success” in a sequence of independent Bernoulli trials with the probability of “success” on each trial being <span class="math inline">\(p\)</span>.<br /><span class="math display">\[Y \sim {\rm NegBin}(k, p)\]</span><br /><span class="math display">\[f_X(x) = \binom{k + x - 1}{x} p^k (1 - p)^x \\\\x \in \mathbf{N}\]</span><br /><span class="math display">\[\mathbb{E}[Y] = \frac{k(1 - p)}{p}, {\rm Var}(Y) = \frac{k(1 - p)}{p^2}\]</span></p></li><li><p><strong>Geometric Distribution</strong><br />Let <span class="math inline">\(X\)</span> be the number of “failures” before the first “success” occurs in a sequence of independent Bernoulli trials with the probability of “success” on each trial being <span class="math inline">\(p\)</span>.<br /><span class="math display">\[Y \sim {\rm Geometric}(p)\]</span><br /><span class="math display">\[f_X(x) = (1 - p)^xp \\\\x \in \mathbf{N}\]</span><br /><span class="math display">\[\mathbb{E}[Y] = \frac{1 - p}{p}, {\rm Var}(Y) = \frac{1 - p}{p^2}\]</span></p></li><li><p><strong>Uniform Distribution</strong><br />We define a Uniform random variable on the interval <span class="math inline">\(a &lt; x &lt; b\)</span> as what is often intuitively thought of as a “completely random” number between <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>.<br /><span class="math display">\[X \sim {\rm Uniform}(a, b)\]</span><br /><span class="math display">\[f_X(x) = \begin{cases}     \frac{1}{b - a} &amp; a &lt; x &lt; b \\\\     0 &amp; \text{otherwise} \end{cases}\]</span><br /><span class="math display">\[\mathbb{E}[Y] = \frac{a + b}{2}, {\rm Var}(Y) = \frac{(b - a)^2}{12}\]</span></p></li><li><p><strong>Exponential Distribution</strong><br />We have defined the Exponential distribution to be the distribution of the waiting time (time between events) in a Poisson process with rate <span class="math inline">\(\lambda\)</span>.<br /><span class="math display">\[X \sim {\rm Exponential}(\lambda)\]</span><br /><span class="math display">\[f_X(x) = \begin{cases}     \lambda e^{-\lambda x} &amp; x &gt; 0 \\\\     0 &amp; x \leq 0 \end{cases}\]</span><br /><span class="math display">\[\mathbb{E}[Y] = \frac{1}{\lambda}, {\rm Var}(Y) = \frac{1}{\lambda^2}\]</span></p></li><li><p><strong>Normal Distribution</strong><br />It is probably the most important distribution in statistics, mainly because of its link with the Central Limit Theorem.<br /><span class="math display">\[X \sim {\rm Normal}(\mu, \sigma^2)\]</span><br /><span class="math display">\[f_X(x) = \frac{1}{\sqrt{2 \pi \sigma^2}}e^{\frac{-(x - \mu)^2}{2 \sigma^2}} \\\\x \in \mathbf{R}\]</span><br /><span class="math display">\[\mathbb{E}[Y] = \mu, {\rm Var}(Y) = \sigma^2\]</span></p></li><li><p><strong>Chi-squared Distribution</strong><br />The Chi-squared distribution with <span class="math inline">\(\nu\)</span> degrees of freedom, <span class="math inline">\(\chi_\nu^2\)</span>, is a special case of the Gamma distribution. Note that <span class="math inline">\(\nu &gt; 0\)</span> and in many statistical settings, <span class="math inline">\(\nu\)</span> is an integer.<br /><span class="math display">\[Y \sim \chi_\nu^2 = {\rm Gamma}(k = \frac{\nu}{2}, \lambda = \frac{1}{2})\]</span><br /><span class="math display">\[\mathbb{E}[Y] = \frac{k}{\lambda} = \nu, {\rm Var}(Y) = \frac{k}{\lambda^2} = 2 \nu\]</span></p><p>Interestingly,<br /><span class="math display">\[{\rm Exponential}(\lambda = \frac{1}{2}) = {\rm Gamma}(k = 1, \lambda = \frac{1}{2}) = \chi_{\nu = 2}^2\]</span></p></li></ol><h2 id="reminiscences-de-stats-201">Reminiscences de STATS 201</h2><h3 id="basic-data-analysis-process">Basic Data Analysis Process</h3><ul><li>Read data. <code>df = read.table(&lt;path&gt;, header = &lt;T/F&gt;)</code>.</li><li>Plot data. <code>plot(y ~ x, data = df)</code>.<ul><li>Trendscatter plot. <code>library(s20x)</code>, <code>trendscatter(y ~ x, data = df)</code>.</li></ul></li><li>Fit model. <code>lm(y ~ x, data = df)</code>, <em>e.t.c.</em><ul><li>Verify and improve model. <code>plot(fit)</code>/<code>modelcheck(fit)</code>, <code>summary(fit)</code>.</li></ul></li><li>Predict. <code>predict(fit, newdata = data)</code>.</li><li>Method and assumption checks.</li><li>Executive summary.</li></ul><h3 id="frequently-used-regression">Frequently Used Regression</h3><ol type="1"><li><p><strong>Simple Linear Regression Model</strong></p><ul><li><p><strong>Formula</strong><br /><span class="math display">\[y_i = \beta_0 + \beta_1 x_i + \epsilon_i \\\\\epsilon_i \sim {\rm iid \ Normal(0, \sigma^2)}\]</span></p></li><li><p><strong>Code</strong><br /><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fit <span class="operator">=</span> lm<span class="punctuation">(</span>y <span class="operator">~</span> x<span class="punctuation">,</span> data <span class="operator">=</span> df<span class="punctuation">)</span></span><br></pre></td></tr></table></figure></p></li></ul></li><li><p><strong>Quadratic Linear Regression Model</strong></p><ul><li><p><strong>Formula</strong><br /><span class="math display">\[y_i = \beta_0 + \beta_1 x_i + \beta_2 x_i^2 + \epsilon_i \\\\\epsilon_i \sim {\rm iid \ Normal(0, \sigma^2)}\]</span></p></li><li><p><strong>Code</strong><br /><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fit <span class="operator">=</span> lm<span class="punctuation">(</span>y <span class="operator">~</span> x <span class="operator">+</span> I<span class="punctuation">(</span>x<span class="operator">^</span><span class="number">2</span><span class="punctuation">)</span><span class="punctuation">,</span> data <span class="operator">=</span> df<span class="punctuation">)</span></span><br></pre></td></tr></table></figure></p></li></ul><p>This can be extended into polynomial situations.</p></li><li><p><strong>Linear Models with Categorical(Factor) Explanatory Variables</strong></p><ul><li><strong>Formula(for example)</strong><br /><span class="math display">\[Exam_i = \beta_0 + \beta_1 \cdot Attend.Yes_i + \epsilon_i \\\\\epsilon_i \sim {\rm iid \ Normal(0, \sigma^2)}\]</span></li><li><strong>Code</strong><br /><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">examAttend.fit <span class="operator">=</span> lm<span class="punctuation">(</span>Exam <span class="operator">~</span> Attend<span class="punctuation">,</span> data <span class="operator">=</span> Stats20x.df<span class="punctuation">)</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>Multiplicative Linear Model</strong></p><ul><li><p><strong>Function</strong><br /><span class="math display">\[\log(y_i) = \beta_0 + \beta_1 x_i + \epsilon_i \\\\\epsilon_i \sim {\rm iid \ Normal(0, \sigma^2)}\]</span></p></li><li><p><strong>Code</strong><br /><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fit <span class="operator">=</span> lm<span class="punctuation">(</span><span class="built_in">log</span><span class="punctuation">(</span>y<span class="punctuation">)</span> <span class="operator">~</span> x<span class="punctuation">,</span> data <span class="operator">=</span> df<span class="punctuation">)</span></span><br></pre></td></tr></table></figure></p></li></ul></li><li><p><strong>Power Law Linear Model</strong></p><ul><li><strong>Formula</strong><br /><span class="math display">\[\log(y_i) = \beta_0 + \beta_i \log(x_i) + \epsilon_i \\\\\epsilon_i \sim {\rm iid \ Normal(0, \sigma^2)}\]</span></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> STATS 330 Application and Practice of Statistics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 介绍 </tag>
            
            <tag> 统计学 </tag>
            
            <tag> R 语言 </tag>
            
            <tag> 数据科学 </tag>
            
            <tag> 奥克兰大学—西南大学合作课程 </tag>
            
            <tag> 外文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【软件工程学习】 第二章 可行性研究</title>
      <link href="/2025/10/15/25-10-15-2-SoftEng-2-feasibility/"/>
      <url>/2025/10/15/25-10-15-2-SoftEng-2-feasibility/</url>
      
        <content type="html"><![CDATA[<h2 id="可行性研究的任务">2.1 可行性研究的任务</h2><ol type="1"><li><p><strong>任务</strong><br />并非任何问题都有简单明显的解决办法。如果问题没有可行的解，那么花费在这项工程上的任何时间、人力、软硬件资源和经费，都是无谓的浪费。可行性研究的目的，就是用<strong>最小的代价</strong>在<strong>尽可能短的时间内</strong>确定<strong>问题是否能够解决</strong>。</p></li><li><p><strong>分析过程</strong></p><ul><li>分析和澄清问题定义。</li><li>导出系统逻辑模型。</li><li>探索若干种可选的主要解法。</li></ul></li></ol><h2 id="可行性研究过程">2.2 可行性研究过程</h2><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th>步骤</th><th></th></tr></thead><tbody><tr class="odd"><td><strong>复查</strong>系统规模和目标</td><td>实质上是为了确保分析员正在解决的问题确实是要求他解决的问题。</td></tr><tr class="even"><td>研究目前<strong>正在使用</strong>的系统</td><td>新系统必须要完成旧系统的基本功能；新系统必须要解决旧系统的问题。</td></tr><tr class="odd"><td>导出新系统的<strong>高层逻辑模型</strong></td><td>参考现有系统的逻辑模型，设想目标系统的逻辑模型，最后根据目标系统的逻辑模型建造新的物理系统。</td></tr><tr class="even"><td>进一步<strong>定义</strong>问题</td><td>在之前的基础上再次定义问题，构成循环，直到提出的逻辑模型完全符合系统目标。</td></tr><tr class="odd"><td>导出和评价供选择的<strong>解法</strong></td><td>为每个解法考虑操作、经济方面的可行性，制定实现进度表。</td></tr><tr class="even"><td>推荐行动<strong>方针</strong></td><td></td></tr><tr class="odd"><td>草拟开发<strong>计划书</strong></td><td>制定工程进度表，资源需要情况，系统生命周期每个阶段的成本。</td></tr><tr class="even"><td>写<strong>文档</strong>提交审查</td><td>应该把上述可行性研究各个步骤的工作结果写成清晰的文档，请用户、客户组织的负责人及评审组审查，以决定是否继续这项工程及是否接受分析员推荐的方案。</td></tr></tbody></table><h2 id="系统流程图">2.3 系统流程图</h2><ol type="1"><li><p><strong>描述</strong><br />系统流程图是概括地描绘物理系统的传统工具。<br />系统流程图表达的是<strong>数据在系统各部件之间流动的情况</strong>，而不是对数据进行加工处理的控制过程，因此尽管系统流程图的某些符号和程序流程图的符号形式相同，但是它却是物理数据流图而<strong>不是程序流程图</strong>。</p></li><li><p><strong>基本思想</strong><br />用图形符号以<strong>黑盒子形式</strong>描绘组成系统的每个部件（程序、文档、数据库、人工过程等）。</p></li></ol><h3 id="符号">2.3.1 符号</h3><p><img src="/image/25-10-15-2-SoftEng-feasibility/1764116691758.webp" alt="1764116691758" /><br /><img src="/image/25-10-15-2-SoftEng-feasibility/1764116701110.webp" alt="1764116701110" /></p><h3 id="实例">2.3.2 实例</h3><p>某装配厂有一座存放零件的仓库，仓库中现有的各种零件的数量以及每种零件的库存量临界值等数据记录在库存清单主文件中。当仓库中零件数量有变化时，应该及时修改库存清单主文件，如果哪种零件的库存量少于它的库存量临界值，则应该报告给采购部门以便订货，规定每天向采购部门送一次订货报告。</p><p>该装配厂使用一台小型计算机处理更新库存清单主文件和产生订货报告的任务。零件库存量的每一次变化称为一个事务，由放在仓库中的CRT终端输入到计算机中；系统中的库存清单程序对事务进行处理，更新存储在磁盘上的库存清单主文件，并且把必要的订货信息写在磁带上。最后，每天由报告生成程序读一次磁带，并且打印出订货报告。</p><figure><img src="/image/25-10-15-2-SoftEng-feasibility/1764116801187.webp" alt="1764116801187" /><figcaption aria-hidden="true">1764116801187</figcaption></figure><h3 id="分层">2.3.3 分层</h3><p>首先用一张<strong>高层次</strong>的系统流程图描绘系统总体概貌，表明系统的关键功能。然后分别把每个关键功能<strong>扩展到适当的详细程度</strong>，画在单独的一页纸上。这种分层次的描绘方法便于阅读者按<strong>从抽象到具体</strong>的过程逐步深入地了解一个复杂的系统。</p><h2 id="数据流图">2.4 数据流图</h2><dl><dt><strong>数据流图</strong></dt><dd>数据流图（DFD）是一种图形化技术，它描绘<strong>信息流和数据</strong>从输入移动到输出的过程中所经受的<strong>变换</strong>。</dd></dl><h3 id="符号-1">2.4.1 符号</h3><figure><img src="/image/25-10-15-2-SoftEng-feasibility/1764117535757.webp" alt="1764117535757" /><figcaption aria-hidden="true">1764117535757</figcaption></figure><h3 id="例子">2.4.2 例子</h3><ol type="1"><li><p><strong>示例</strong><br />假设一家工厂的采购部每天需要一张订货报表，报表按零件编号排序，表中列出所有需要再次订货的零件。对于每个需要再次订货的零件应该列出下述数据：零件编号，零件名称，订货数量，目前价格，主要供应者，次要供应者。零件入库或出库称为事务，通过放在仓库中的 CRT 终端把事务报告给订货系统。当某种零件的库存数量少于库存量临界值时就应该再次订货。</p></li><li><p><strong>分析</strong></p><ul><li><p><strong>从问题描述中提取数据流图的成分</strong></p><details><p>首先考虑数据的<strong>源点和终点</strong>，从上面对系统的描述可以知道“采购部每天需要一张订货报表”，“通过放在仓库中的 CRT 终端把事务报告给订货系统”，所以采购员是数据终点，而仓库管理员是数据源点。</p></details></li><li><p><strong>分析没有明显提到的需要</strong></p><details><p>“采购部需要报表”，因此必须有一个用于产生报表的处理。事务的后果是改变零件库存量，然而任何改变数据的操作都是处理，因此对事务进行的加工是另一个处理。</p></details></li><li><p><strong>考虑数据流与数据存储</strong></p><details><p>系统把订货报表送给采购部，因此订货报表是一个数据流；事务需要从仓库送到系统中，显然事务是另一个数据流。产生报表和处理事务这两个处理在时间上明显不匹配——每当有一个事务发生时立即处理它，然而每天只产生一次订货报表。因此，用来产生订货报表的数据必须存放一段时间，也就是应该有一个数据存储。</p></details></li></ul><figure><img src="/image/25-10-15-2-SoftEng-feasibility/1764119219174.webp" alt="1764119219174" /><figcaption aria-hidden="true">1764119219174</figcaption></figure></li><li><p><strong>作图</strong><br />逐步细化作图。</p><table><colgroup><col style="width: 33%" /><col style="width: 33%" /><col style="width: 33%" /></colgroup><thead><tr class="header"><th>顶层模块</th><th>描绘系统的主要功能</th><th>对功能级数据流图中描绘的系统主要功能进一步细化</th></tr></thead><tbody><tr class="odd"><td><img src="/image/25-10-15-2-SoftEng-feasibility/1764119322208.webp" alt="1764119322208" /></td><td><img src="/image/25-10-15-2-SoftEng-feasibility/1764119333484.webp" alt="1764119333484" /></td><td><img src="/image/25-10-15-2-SoftEng-feasibility/1764119346711.webp" alt="1764119346711" /></td></tr></tbody></table></li></ol><h3 id="命名">2.4.3 命名</h3><ol type="1"><li><p><strong>数据流命名时应注意的问题</strong></p><ul><li>名字应代表整个数据流的内容。</li><li>不要使用空洞的、缺乏具体含义的名字。</li><li>在为某个数据流（或数据存储）起名字时遇到了困难，则很可能是因为对数据流图分解不恰当造成的，应该试试重新分解。</li></ul></li><li><p><strong>为处理命名时应注意的问题</strong></p><ul><li>通常先为数据流命名，然后再为与之相关联的处理命名。</li><li>名字应该反映整个处理的功能，而不是它的一部分功能。</li><li>名字最好由一个具体的及物动词加上一个具体的宾语组成。</li><li>通常名字中仅包括一个动词，如果必须用两个动词才能描述整个处理的功能，则把这个处理再分解成两个处理可能更恰当些。</li><li>如果在为某个处理命名时遇到困难，则很可能是发现了分解不当的迹象，应考虑重新分解。</li></ul></li></ol><h3 id="用途">2.4.4 用途</h3><ul><li><p>画数据流图的基本目的是利用它作为交流信息的工具。</p></li><li><p>数据流图的另一个主要用途是作为分析和设计的工具。</p></li><li><p>数据流图辅助物理系统的设计时，以图中不同处理的定时要求为指南，能够在数据流图上画出许多组自动化边界，每组自动化边界可能意味着一个不同的物理系统</p></li></ul><h2 id="数据字典">2.5 数据字典</h2><dl><dt>数据字典</dt><dd>数据字典是关于数据的信息的集合，也就是对数据流图中包含的所有元素的定义的集合。</dd></dl><h3 id="内容">2.5.1 内容</h3><p>一般说来，数据字典应该由对数据流、数据流分量、处理、数据存储的定义组成。</p><h3 id="定义数据的方法">2.5.2 定义数据的方法</h3><ol type="1"><li><p><strong>数据元素组成数据的方式</strong><br />由数据元素组成数据的方式只有下述 3 种基本类型</p><table><tbody><tr class="odd"><td>顺序</td><td>以确定次序连接两个或多个分量</td></tr><tr class="even"><td>选择</td><td>从两个或多个可能的元素中选取一个</td></tr><tr class="odd"><td>重复</td><td>把指定的分量重复零次或多次</td></tr></tbody></table></li><li><p><strong>第四种关系算符</strong></p><table><thead><tr class="header"><th>算符</th><th>含义</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(=\)</span></td><td>等价于、定义为</td></tr><tr class="even"><td><span class="math inline">\(+\)</span></td><td>和，连接两个分量</td></tr><tr class="odd"><td><span class="math inline">\([]\)</span></td><td>或，从方括弧内列出的若干个分量中选择一个，元素以 | 分隔</td></tr><tr class="even"><td>{}</td><td>重复</td></tr><tr class="odd"><td><span class="math inline">\(()\)</span></td><td>可选</td></tr></tbody></table></li></ol><h3 id="数据字典的用途">2.5.3 数据字典的用途</h3><ul><li>作为分析阶段的工具</li><li>包含的每个数据元素的控制信息是很有价值的</li><li>是开发数据库的第一步，而且是很有价值的一步</li></ul><h3 id="数据字典的实现">2.5.4 数据字典的实现</h3><p>在开发小型软件系统时暂时没有数据字典处理程序，建议采用卡片形式书写数据字典，每张卡片上保存描述一个数据的信息。</p><figure><img src="/image/25-10-15-2-SoftEng-feasibility/1764120794302.webp" alt="1764120794302" /><figcaption aria-hidden="true">1764120794302</figcaption></figure><h3 id="成本效益分析">2.5.5 成本效益分析</h3><p>软件开发成本主要表现为人力消耗（乘以平均工资则得到开发费用）。成本估计不是精确的科学，因此应该使用几种不同的估计技术以便相互校验。</p><ol type="1"><li><p><strong>代码行技术</strong></p></li><li><p><strong>任务分解技术</strong><br />任务分解技术最常用的办法是按开发阶段划分任务。</p></li><li><p><strong>自动估计成本技术</strong></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【软件工程学习】 第一章 软件工程概述</title>
      <link href="/2025/10/15/25-10-15-1-SoftEng-1-intro/"/>
      <url>/2025/10/15/25-10-15-1-SoftEng-1-intro/</url>
      
        <content type="html"><![CDATA[<h2 id="一软件工程的价值与应用场景">一、软件工程的价值与应用场景</h2><ol type="1"><li><p><strong>实际用途</strong></p><ul><li>国家考试（如软考）、工作面试（如亚麻面试）、毕业设计、读研。</li><li>参与需求分析、撰写需求/设计报告、招标书/投标书、项目申请书。</li><li>开发原型（需掌握原型工具）、开发软件（需学习开发框架）。</li><li>绘制模型图/流程图、AI开发APP等。</li></ul></li><li><p><strong>工作场景</strong></p><ul><li>文档撰写、模型设计、原型开发、前后端分离开发、系统设计等。</li></ul></li></ol><h2 id="二软件工程学科与教材分析">二、软件工程学科与教材分析</h2><ol type="1"><li><p><strong>经典教材</strong></p><ul><li>《Software Engineering: A Practitioner’s Approach》（2020年）：涵盖软件过程、建模、质量、项目管理等。</li><li>《软件工程导论》（2013年）：传统生命周期与面向对象方法。</li><li>《面向对象软件工程：敏捷统一方法》（2014/2023年）：强调领域建模、架构设计、交互建模等。</li><li>《软件工程：谷歌的实践》（2022年）：聚焦文化、流程、工具（如代码评审、CI/CD）。</li></ul></li><li><p><strong>学科演变</strong></p><ul><li>从传统软件工程→面向对象→敏捷开发→系统工程。</li><li>新趋势：低代码、AI开发、产品化（从Project到Product）。</li></ul></li></ol><h2 id="三软件工程核心内容">三、软件工程核心内容</h2><ol type="1"><li><p><strong>关键主题</strong></p><ul><li><strong>需求分析</strong>：用户故事、用例建模、领域模型。</li><li><strong>设计</strong>：架构设计、OOD（如亚麻面试）、设计模式、UI/UX。</li><li><strong>实现</strong>：前后端分离、组件化、框架化（如Vue+Node.js）。</li><li><strong>测试与维护</strong>：单元测试、持续集成/交付（CI/CD）。</li><li><strong>项目管理</strong>：风险管理、配置管理、团队协作。</li></ul></li><li><p><strong>工具与技术</strong></p><ul><li>原型工具（如Axure）、版本控制（Git）、低代码平台、AI开发工具。</li></ul></li></ol><h2 id="四软件工程的新发展与挑战">四、软件工程的新发展与挑战</h2><ol type="1"><li><p><strong>新趋势</strong></p><ul><li><strong>产品化</strong>：从定制开发转向标准化产品（产品经理角色凸显）。</li><li><strong>AI与低代码</strong>：AI辅助开发、低代码平台降低开发门槛。</li><li><strong>系统工程</strong>：重视整体设计（如北美系统设计面试）。</li></ul></li><li><p><strong>行业困境</strong></p><ul><li>软件工程与开发框架脱节，部分高校停招软件工程专业。</li><li>需平衡理论（如建模、文档）与实践（如框架、工具）。</li></ul></li></ol><h2 id="五学习建议">五、学习建议</h2><ol type="1"><li><p><strong>核心技能</strong></p><ul><li>掌握软件建模（UML）、文档撰写、原型工具。</li><li>学习前后端框架（如Vue、Node.js）或低代码开发。</li><li>熟悉开源软件、AI开发工具。</li></ul></li><li><p><strong>实践方向</strong></p><ul><li>开发小型项目（如班级管理系统、微信小程序）。</li><li>参与需求分析、设计、测试全流程。</li></ul></li></ol><h2 id="六案例与工具展示">六、案例与工具展示</h2><ol type="1"><li><p><strong>项目案例</strong></p><ul><li>校园日历、课堂抽问程序、班级积分系统等（结合Vue+Node.js、MVC等）。</li></ul></li><li><p><strong>工具应用</strong></p><ul><li>Git/GitHub版本管理、Axure原型设计、AI辅助开发。</li></ul></li></ol><h2 id="七总结">七、总结</h2><p>软件工程是连接理论与实践的桥梁，需结合传统方法（如需求分析、设计）与新技术（如AI、低代码）。学习重点应放在建模能力、工具使用、框架实践及行业趋势适应上，同时关注团队协作与项目管理。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 介绍 </tag>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【计算机组成原理】 第四章 数值的机器运算</title>
      <link href="/2025/10/15/25-10-14-4-CompOrg-4-machine-calculation/"/>
      <url>/2025/10/15/25-10-14-4-CompOrg-4-machine-calculation/</url>
      
        <content type="html"><![CDATA[<h2 id="基本算数运算的实现">4.1 基本算数运算的实现</h2><h3 id="加法器">4.1.1 加法器</h3><ol type="1"><li><p><strong>全加器逻辑与真值表</strong><br />（略）</p></li><li><p><strong>逻辑表达式</strong><br /><span class="math display">\[S_i = A_i \oplus B_i \oplus C_{i - 1} \\\\C_i = A_iB_i + (A_i \oplus B_i)C_{i - 1}\]</span></p></li><li><p><strong>串行与并行</strong></p><table><colgroup><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /></colgroup><thead><tr class="header"><th>种类</th><th>方法</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr class="odd"><td>串行加法器</td><td>数据逐位送入一个加法器进行计算</td><td>器件少、成本低</td><td>速度慢</td></tr><tr class="even"><td>并行加法器</td><td>由多个全加器组成，位数多少取决于字长</td><td>速度高</td><td>加法运算最长时间问题</td></tr></tbody></table></li></ol><h3 id="进位的产生与传递">4.2.2 进位的产生与传递</h3><p>设进位传递函数<br /><span class="math display">\[P_i = A_i \oplus B_i  \ \text{（进位传递函数）} \\\\G_i = A_iB_i\]</span></p><p>则<br /><span class="math display">\[C_n = G_n + P_nC_{n - 1}\]</span></p><p>串行进位加法器的总延迟时间与字长成<strong>正比</strong>。设一级与门、或门的延迟时间为<span class="math inline">\(ty\)</span>，每一级全加器延迟为<span class="math inline">\(2ty\)</span>，从<span class="math inline">\(C_0\)</span>到<span class="math inline">\(C_N\)</span>的最长时间为<span class="math inline">\(2nty\)</span>。</p><h3 id="并行加法器的快速进位">4.1.3 并行加法器的快速进位</h3><ol type="1"><li><p><strong>并行进位</strong><br />又称先行进位、同时进位，各级信号同时形成。<br /><span class="math display">\[C_n = \sum_{i = 0}^n(\prod_{k = i + 1}^nP_k)C_i\]</span></p><p>可见十分甚至九分得麻烦啊（悲）。</p></li><li><p><strong>分组并行进位</strong></p><ul><li><strong>单级先行进位（将多位分为几组，组内并行进位，组间串行进位）</strong><br /><img src="/image/25-10-14-4-CompOrg-machine-calculation/1761126616059.jpg" alt="1761126616059" /></li><li><strong>多级先行进位（将多位分为几组，组内并行进位，组间并行行进位）</strong><br /><img src="/image/25-10-14-4-CompOrg-machine-calculation/1761126672774.jpg" alt="1761126672774" /></li></ul></li></ol><h2 id="定点加减运算">4.2 定点加减运算</h2><h3 id="原码加减运算">4.2.1 原码加减运算</h3><ol type="1"><li><p><strong>减法转加法</strong><br />大多数机器只设置加法器而不设置减法器。<br /><span class="math display">\[|X| - |Y| = |X| + |Y|_{\text{变补}}\]</span></p></li><li><p><strong>规则</strong></p><ul><li>参加运算的操作数取其绝对值。</li><li>若做加法运算，则两数直接相加；若做减法运算，则将减数<strong>先变一次补</strong>，再进行加法操作。</li><li>运算之后，可能有两种情况：<ul><li>有进位，结果为正，即得到正确的结果。</li><li>无进位，结果为负，则应<strong>再变一次补</strong>，才能得到正确的结果。</li></ul></li><li><strong>结果加上符号位。</strong></li></ul><p>通常，把运算之前的变补称为<strong>前变补</strong>，运算之后的变补称为<strong>后变补</strong>。</p><blockquote><p>变补即二进制数<strong>所有位</strong>取反再加一。</p></blockquote></li></ol><h3 id="补码加减运算">4.2.2 补码加减运算</h3><ol type="1"><li><p><strong>补码加法</strong><br />两数之和的补码等于两数补码之和。<br /><span class="math display">\[(X + Y)_补 = X_补 + Y_补\]</span></p><p>证明略。</p></li><li><p><strong>补码减法</strong><br />由补码加法易得<br /><span class="math display">\[(X - Y)_补 = X_补 + (-Y)_补\]</span></p><p>进一步<br /><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo stretchy="false">(</mo><mi>X</mi><mo>−</mo><mi>Y</mi><msub><mo stretchy="false">)</mo><mo>补</mo></msub><mo>=</mo><msub><mi>X</mi><mo>补</mo></msub><mo>+</mo><mo stretchy="false">(</mo><msub><mi>Y</mi><mo>补</mo></msub><msub><mo stretchy="false">)</mo><mrow><mo>变补</mo></mrow></msub></math></p><p>证明略。</p></li><li><p><strong>规则</strong></p><ul><li>参加运算的两个操作数均用补码表示。</li><li>符号位作为数的一部分参加运算。</li><li>若做加法运算，则两数直接相加；若做减法运算，则将被减数与减数的<strong>机器负数</strong>相加。</li><li>运算结果<strong>仍用补码表示</strong>。</li></ul></li><li><p><strong>符号扩展</strong></p><ul><li>有时需要将定位数的位数增加。</li><li>正数：原有形式的符号位移动到新形式的符号位上，新表示形式的所有附加位都用“0”进行填充。</li><li>负数：<ul><li>原码：原码表示负数的符号扩展方法与正数相同，只不过此时符号位为“1”而已。</li><li>补码：原有形式的符号位移动到新形式的符号位上，新表示形式的所有附加位都用“1”进行填充。</li></ul></li></ul><blockquote><p>因此，补码扩展的规则实际为：所有附加位均用<strong>符号位</strong>填充。</p></blockquote></li></ol><h3 id="补码的溢出判断与检测方法">4.2.3 补码的溢出判断与检测方法</h3><ol type="1"><li><strong>溢出的产生</strong><ul><li>成因：运算结果超出了机器所能表示的范围。</li><li>两数相加产生的溢出为<strong>正溢</strong>，两负数相加产生的溢出为<strong>负溢</strong>。</li></ul></li><li><strong>溢出检测方法</strong><br />设被操作数为<span class="math inline">\(X_补\)</span>，操作数为<span class="math inline">\(Y_补\)</span>，和（差）为<span class="math inline">\(S_补\)</span><br /><span class="math display">\[X_补 = X_s, X_1X_2 \ldots X_n \\\\Y_补 = Y_s, Y_1Y_2 \ldots Y_n \\\\S_补 = S_s, S_1S_2 \ldots S_n \\\\\]</span><ul><li><p><strong>采用一个符号位</strong><br />当<span class="math inline">\(X_s = Y_s = 0\)</span>，<span class="math inline">\(S_s = 1\)</span>时，产生正溢；<span class="math inline">\(X_s = Y_s = 1\)</span>，<span class="math inline">\(S_s = 0\)</span>时，产生负溢。</p><p>故溢出判断条件<br /><span class="math display">\[O = \bar{X_s}\bar{Y_s}S_s + X_sY_s\bar{S_s}\]</span></p></li><li><p><strong>采用进位位</strong><br />两数运算时产生进位为<br /><span class="math display">\[C_s, C_1C_2 \ldots C_n\]</span></p><p>两正数相加，当最高有效位产生进位（<span class="math inline">\(C_1 = 1\)</span>）而符号位不产生进位（<span class="math inline">\(C_s = 0\)</span>）时，发生正溢；两负数相加，当最高有效位不产生进位（<span class="math inline">\(C_1 = 0\)</span>）而符号位产生进位（<span class="math inline">\(C_s = 0\)</span>）时，发生负溢。<br /><span class="math display">\[O = \bar{C_s}C_1 + C_s\bar{C_1} = C_s \oplus C_1\]</span></p></li><li><p><strong>采用变形补码（双符号位补码）</strong><br />将符号位扩展为两个<span class="math inline">\(X_{s1} = X_{s2} = X_s\)</span>，并直接参与运算。</p><table><thead><tr class="header"><th>表现</th><th>含义</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(S_{s1}S_{s2} = 00\)</span></td><td>正数，无溢出</td></tr><tr class="even"><td><span class="math inline">\(S_{s1}S_{s2} = 01\)</span></td><td>正溢</td></tr><tr class="odd"><td><span class="math inline">\(S_{s1}S_{s2} = 10\)</span></td><td>负溢</td></tr><tr class="even"><td><span class="math inline">\(S_{s1}S_{s2} = 11\)</span></td><td>负数，无溢出</td></tr></tbody></table><p>为了尽可能减少代价，在采用双符号位方案时，操作数和结果在寄存器和主存中仍保持单符号位，仅在运算时再扩充为双符号位。</p></li></ul></li></ol><h3 id="补码定点加减运算的实现">4.2.4 补码定点加减运算的实现</h3><figure><img src="/image/25-10-14-4-CompOrg-machine-calculation/1761181181558.jpg" alt="1761181181558" /><figcaption aria-hidden="true">1761181181558</figcaption></figure><h2 id="带符号数的移位和舍入操作">4.3 带符号数的移位和舍入操作</h2><p>实现乘除运算的方案：</p><ul><li>软件实现，机器内无乘除指令。</li><li>增加逻辑线路，将乘除转为加减，机器内有乘除指令。</li><li>机器内设有专门的乘除运算器与乘除指令。</li></ul><h3 id="带符号数的移位操作">4.3.1 带符号数的移位操作</h3><ol type="1"><li><p><strong>原码的移位规则</strong><br />不论正数还是负数，在左移或右移时，符号位均不变，空出位一律以“0”补入。</p></li><li><p><strong>补码的移位规则</strong></p><ul><li><p><strong>正数</strong><br />符号位不变，不论左移或右移，空出位一律以“0”补入。</p></li><li><p><strong>负数</strong><br />符号位不变，左移后的空出位补“0”，右移后的空出位补“1”。</p></li></ul></li><li><p><strong>移位功能的实现</strong></p><blockquote><p>注意：移位器与移位寄存器不同，它本身只有移位功能，没有寄存功能，所以移位之后的结果一定要保存到有关寄存器中。</p></blockquote></li></ol><h3 id="带符号数的舍入操作">4.3.2 带符号数的舍入操作</h3><p>设我们需要将 <span class="math inline">\(p + q\)</span> 位的数（二进制）舍入到前 <span class="math inline">\(p\)</span> 位。</p><ul><li><p><strong>恒舍（切断）</strong><br />无论 <span class="math inline">\(p + 1\)</span> 位为何数值，都将后 <span class="math inline">\(q\)</span> 位舍去。</p></li><li><p><strong>冯 · 诺伊曼舍入法（恒置 <span class="math inline">\(1\)</span> 法）</strong><br />无论 <span class="math inline">\(p + 1\)</span> 位为何数值，都将第 <span class="math inline">\(p\)</span> 位置为 <span class="math inline">\(1\)</span>，并将后 <span class="math inline">\(q\)</span> 位舍去。</p></li><li><p><strong>下舍上入法</strong><br />若 <span class="math inline">\(p + 1\)</span> 位为 <span class="math inline">\(0\)</span> 则舍，若 <span class="math inline">\(p + 1\)</span> 位为 <span class="math inline">\(1\)</span> 则入。</p></li><li><p><strong>查表舍入法（ROM 舍入法）</strong><br />根据在 ROM 中存放的一个表进行舍入。通常，ROM 表的容量为 <span class="math inline">\(2^K\)</span> 个单元，每个单元字长为 <span class="math inline">\(K - 1\)</span> 位。舍人处理表的内容设置一般采用的方法是：当 <span class="math inline">\(K\)</span> 位数据的高 <span class="math inline">\(K - 1\)</span> 位为全 <span class="math inline">\(1\)</span> 时，让那些单元按恒舍法填人 <span class="math inline">\(K - 1\)</span> 位为全 <span class="math inline">\(1\)</span>，其余单元都按下舍上人法来填其内容。例如，4 位数经 ROM 查表，舍人成 3 位结果，其 ROM 的地址和内容的对应关系如表所示。<br /><img src="/image/25-10-14-4-CompOrg-machine-calculation/1761308449547.jpg" alt="1761308449547" /></p></li></ul><h2 id="定点乘法运算">4.4 定点乘法运算</h2><h3 id="原码一位乘法">4.4.1 原码一位乘法</h3><ol type="1"><li><p><strong>算法</strong><br />由手算竖式乘法演变而来。</p><p>乘积绝对值 <span class="math inline">\(P\)</span>，符号<span class="math inline">\(P_s\)</span><br /><span class="math display">\[P = |X| \times |Y| \\\\P_s = X_s \oplus Y_s\]</span></p><ul><li><ol type="1"><li>参加运算的操作数取其绝对值。</li></ol></li><li><ol start="2" type="1"><li>令乘数的最低位为判断位，若为 <span class="math inline">\(1\)</span>，加被乘数；若为 <span class="math inline">\(0\)</span>，不加被乘数（加 <span class="math inline">\(0\)</span>） 。</li></ol></li><li><ol start="3" type="1"><li>累加后的部分积以及乘数右移一位。</li></ol></li><li><ol start="4" type="1"><li>重复 <span class="math inline">\(n\)</span> 次 (2) 和 (3) 。</li></ol></li><li><ol start="5" type="1"><li>符号位单独处理，同号为正，异号为负。</li></ol></li></ul></li><li><p><strong>原码一位乘法运算的实现</strong></p></li></ol><h3 id="补码一位乘法">4.4.2 补码一位乘法</h3><ol type="1"><li><p><strong>校正法</strong><br />补码的符号位参加运算。将 <span class="math inline">\(X_补\)</span> 与 <span class="math inline">\(Y_补\)</span> 按原码一位乘法运算，最后将结果加以矫正，得到正确的 <span class="math inline">\((X \times Y)_补\)</span>。</p><ul><li>当 <span class="math inline">\(Y &gt; 0\)</span>，按原码乘法运算，移位时按<strong>补码规则</strong>进行。</li><li>当 <span class="math inline">\(Y &lt; 0\)</span>，忽略 <span class="math inline">\(Y_补\)</span> 符号位，按原码乘法运算，最后加上 <span class="math inline">\((-X)_补\)</span> 矫正。</li><li>综上，<br /><span class="math display">\[(X \times Y)_补 = X_补 \times 0;Y_1 \ldots Y_n + (-X)_补Y_s\]</span></li></ul></li><li><p><strong>比较法（Booth 乘法）</strong><br />由校正法公式，<br /><span class="math display">\[(X \times Y)_补 = X_补 \times \sum_{i = 0}^n (Y_{i + 1} - Y_i)2^{-n}\]</span><br />其中 <span class="math inline">\(Y_0 = Y_s\)</span>。</p><p>可得递推公式<br /><span class="math display">\[(Z_0)_{\text{补}} = 0 \\\\(Z_1)_{\text{补}} = 2^{-1} \left\{ (Z_0)_{\text{补}} + (Y_{n+1} - Y_n)(X)_{\text{补}} \right\} \\\\(Z_2)_{\text{补}} = 2^{-1} \left\{ (Z_1)_{\text{补}} + (Y_n - Y_{n-1})(X)_{\text{补}} \right\} \\\\(Z_n)_{\text{补}} = 2^{-1} \left\{ (Z_{n - 1})_{\text{补}} + (Y_2 - Y_1)(X)_{\text{补}} \right\} \\\\\]</span></p><p>其中 <span class="math inline">\(Y_{n + 1}\)</span> 为附加位，初值为 <span class="math inline">\(0\)</span>。初值为 <span class="math inline">\(0\)</span> 时不影响运算。</p><p>总结得<br /><span class="math display">\[[X \times Y]_{\text{补}} = [Z_n]_{\text{补}} + (Y_1 - Y_s)[X]_{\text{补}}\]</span></p><p><strong>Booth 乘法规则</strong>：</p><ul><li><p>参加运算的数用补码表示。</p></li><li><p>符号位参加运算</p></li><li><p>乘数后面附加一位 <span class="math inline">\(Y_{n + 1} = 0\)</span>。</p></li><li><p>由于每求一次部分积要右移一位，所以乘数的最低两位 <span class="math inline">\(Y_n\)</span>、<span class="math inline">\(Y_{n + 1}\)</span>的值决定了每次应执行的操作，如表所示。</p><table><thead><tr class="header"><th><span class="math inline">\(Y_n\)</span>、<span class="math inline">\(Y_{n + 1}\)</span></th><th>操作</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(00\)</span></td><td>原部分积 <span class="math inline">\(+ 0\)</span>，右移一位</td></tr><tr class="even"><td><span class="math inline">\(01\)</span></td><td>原部分积 <span class="math inline">\(+ X_补\)</span>，右移一位</td></tr><tr class="odd"><td><span class="math inline">\(10\)</span></td><td>原部分积 <span class="math inline">\(+ (-X)_补\)</span>，右移一位</td></tr><tr class="even"><td><span class="math inline">\(11\)</span></td><td>原部分积 <span class="math inline">\(+ 0\)</span>，右移一位</td></tr></tbody></table></li><li><p>移位按补码规则进行。</p></li><li><p>做 <span class="math inline">\(n + 1\)</span> 此累加，<span class="math inline">\(n\)</span> 次移位，第 <span class="math inline">\(n + 1\)</span> 次不移位。</p></li></ul></li><li><p><strong>Booth 乘法的实现</strong></p></li></ol><h3 id="补码两位乘法">4.4.3 补码两位乘法</h3><p>即每次处理乘数的两位。设上次乘法的部分积为 <span class="math inline">\(Z^\prime_{\text{补}}\)</span>，本次部分积为 <span class="math inline">\(Z^\prime_{\text{补}}\)</span>，则<br /><span class="math display">\[Z^\prime_{\text{补}} = 2^{-1}[Z_补 + (Y_{i + 1} - Y_i)]X_补 \\\\Z^\prime_{\text{补}} = 2^{-2}[Z_补 + (Y_{i + 1} + Y_i -2Y_{i - 1})]X_补\]</span></p><p>故使用 <span class="math inline">\(Y_{n - 1}Y_nY_{n + 1}\)</span> 作为判断位，操作规则</p><table><thead><tr class="header"><th>判断位 <span class="math inline">\(Y_{n-1}Y_nY_{n+1}\)</span></th><th>操作</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(0 0 0\)</span></td><td>原部分积 <span class="math inline">\(+ 0\)</span>，右移两位</td></tr><tr class="even"><td><span class="math inline">\(0 0 1\)</span></td><td>原部分积 <span class="math inline">\(+ X_补\)</span>，右移两位</td></tr><tr class="odd"><td><span class="math inline">\(0 1 0\)</span></td><td>原部分积 <span class="math inline">\(+ X_补\)</span>，右移两位</td></tr><tr class="even"><td><span class="math inline">\(0 1 1\)</span></td><td>原部分积 <span class="math inline">\(+ 2(X_补)\)</span>，右移两位</td></tr><tr class="odd"><td><span class="math inline">\(1 0 0\)</span></td><td>原部分积 <span class="math inline">\(+ 2(-X)_补\)</span>，右移两位</td></tr><tr class="even"><td><span class="math inline">\(1 0 1\)</span></td><td>原部分积 <span class="math inline">\(+ (-X)_补\)</span>，右移两位</td></tr><tr class="odd"><td><span class="math inline">\(1 1 0\)</span></td><td>原部分积 <span class="math inline">\(+ (-X)_补\)</span>，右移两位</td></tr><tr class="even"><td><span class="math inline">\(1 1 1\)</span></td><td>原部分积 <span class="math inline">\(+ 0\)</span>，右移两位</td></tr></tbody></table><p>被乘数和部分积取 <span class="math inline">\(3\)</span> 个符号位，当乘数的数值位 <span class="math inline">\(n\)</span> 为偶数时，乘数取 <span class="math inline">\(2\)</span> 个符号位，共需作<span class="math inline">\(\frac{n}{2} + 1\)</span>次累加，<span class="math inline">\(\frac{n}{2}\)</span>次移位（最后一次不移位）;当 <span class="math inline">\(n\)</span> 为奇数时，乘数只需 <span class="math inline">\(1\)</span> 个符号位,共需<span class="math inline">\(\frac{n}{2} + 1\)</span> 次累加和移位，但最后一次仅移一位。</p><p>总结<br /><img src="/image/25-10-14-4-CompOrg-machine-calculation/1761479777896.jpg" alt="1761479777896" /></p><h3 id="阵列乘法器">4.4.4 阵列乘法器</h3><h2 id="定点除法运算">4.5 定点除法运算</h2><h3 id="原码除法运算">4.5.1 原码除法运算</h3><ol type="1"><li><p><strong>比较法</strong><br />此方法模拟手工除法，通过比较大小来上商。</p><ul><li><strong>初始化</strong>：将被除数（或部分余数）存入寄存器 <span class="math inline">\(A\)</span>，除数存入寄存器 <span class="math inline">\(B\)</span>，商寄存器 <span class="math inline">\(C\)</span> 清零。</li><li><strong>上商与运算</strong>：<ul><li>若 <span class="math inline">\(A \geq B\)</span>，则商上 <span class="math inline">\(1\)</span>（写入寄存器 <span class="math inline">\(C\)</span> 的最低位），并执行 <span class="math inline">\(A \leftarrow A - B\)</span>。</li><li>若 <span class="math inline">\(A &lt; B\)</span>，则商上 <span class="math inline">\(0\)</span>（写入寄存器 <span class="math inline">\(C\)</span> 的最低位），<span class="math inline">\(A\)</span> 寄存器内容不变。</li></ul></li><li><strong>移位</strong>：将寄存器 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(C\)</span> 联合左移一位。</li><li>重复以上步骤，直到上的精度已达到。</li></ul></li><li><p><strong>恢复余数法</strong><br />此方法先做减法试探，不够减时再恢复余数。</p><ul><li><strong>初始化</strong>：将被除数存入寄存器 <span class="math inline">\(A\)</span>，除数存入寄存器 <span class="math inline">\(B\)</span>，商寄存器 <span class="math inline">\(C\)</span> 清零。</li><li><strong>减法试探</strong>：执行 <span class="math inline">\(A \leftarrow A - B\)</span>。</li><li><strong>判断与上商</strong>：<ul><li>若部分余数 <span class="math inline">\(A\)</span> 为正，表示够减，则商上 <span class="math inline">\(1\)</span>。</li><li>若部分余数 <span class="math inline">\(A\)</span> 为负，表示不够减，则商上 <span class="math inline">\(0\)</span>，并执行 恢复余数 操作：<span class="math inline">\(A \leftarrow A + B\)</span>。</li></ul></li><li><strong>移位</strong>：将寄存器 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(C\)</span> 联合左移一位。</li><li><strong>循环</strong>：重复步骤 2 ~ 4，直到商的位数满足要求为止。</li></ul></li><li><p><strong>原码加减交替法（不恢复余数法）</strong><br />此方法是对恢复余数法的改进，避免了恢复余数的步骤。</p><ul><li><strong>初始化</strong>：将被除数绝对值存入寄存器 <span class="math inline">\(A\)</span>，除数绝对值存入寄存器 <span class="math inline">\(B\)</span>，商寄存器 <span class="math inline">\(C\)</span> 清零。</li><li><strong>第一次操作</strong>：执行 <span class="math inline">\(A \leftarrow A - B\)</span>。</li><li><strong>判断与上商</strong>：<ul><li>若部分余数 <span class="math inline">\(A\)</span> 为正，商上 <span class="math inline">\(1\)</span>。</li><li>若部分余数 <span class="math inline">\(A\)</span> 为负，商上 <span class="math inline">\(0\)</span>。</li></ul></li><li><strong>移位与下一步运算</strong>：将寄存器 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(C\)</span> 联合左移一位。<ul><li>若上次商为 <span class="math inline">\(1\)</span>，则本次执行减法：<span class="math inline">\(A \leftarrow A - B\)</span>。</li><li>若上次商为 <span class="math inline">\(0\)</span>，则本次执行加法：<span class="math inline">\(A \leftarrow A + B\)</span>。</li></ul></li><li><strong>循环</strong>：重复步骤 3 ~ 4，共进行 <span class="math inline">\(n\)</span> 次（<span class="math inline">\(n\)</span> 为除数数值位位数）。</li><li><strong>最终处理</strong>：<ul><li><strong>符号处理</strong>：商的符号由被除数和除数的符号位异或决定。</li><li><strong>余数修正</strong>：若最终余数为负，必须执行一次恢复余数操作（<span class="math inline">\(A \leftarrow A + B\)</span>），此时不再左移。</li></ul></li></ul></li></ol><h3 id="补码除法运算">4.5.2 补码除法运算</h3><p>被除数和除数都用补码表示，符号位参加运算，商和余数也用补码表示。</p><ol type="1"><li><p><strong>初始化</strong><br />将被除数绝对值存入寄存器 <span class="math inline">\(A\)</span>，除数绝对值存入寄存器 <span class="math inline">\(B\)</span>，商寄存器 <span class="math inline">\(C\)</span> 清零。</p></li><li><p><strong>够减判断与上商</strong><br /><img src="/image/25-10-14-4-CompOrg-machine-calculation/1761482112716.jpg" alt="1761482112716" /></p></li><li><p><strong>商符的确定</strong><br />第一次得出的商即为商符。</p></li><li><p><strong>新部分余数</strong><br /><span class="math display">\[(r_{i + 1})\_{\text{补}} = 2(r_{i})_{\text{补}} + (1 - 2Q_1)Y\_{\text{补}}\]</span><br /><span class="math inline">\(Q_i\)</span> 表示第 <span class="math inline">\(i\)</span> 步的商。<br /><img src="/image/25-10-14-4-CompOrg-machine-calculation/1763985533565.webp" alt="1763985533565" /></p></li><li><p><strong>末位恒置 1</strong><br />商为 <span class="math inline">\(n\)</span> 位，运算次数 <span class="math inline">\(n + 1\)</span> 次，商的最末一位恒为 1，误差最大为 <span class="math inline">\(2^{-n}\)</span>。</p></li></ol><h3 id="阵列除法器">4.5.3 阵列除法器</h3><p><img src="/image/25-10-14-4-CompOrg-machine-calculation/1763985743907.webp" alt="1763985743907" /><br />图中 CAS 为可控加法减法单元。输入控制端为 0 则做加法，为 1 则做减法。</p><h2 id="规格化浮点运算">4.6 规格化浮点运算</h2><p>设两个非 0 规格化浮点数为<br /><span class="math display">\[A = M_A \times 2^{E_A} \\\\B = M_B \times 2^{E_B}\]</span></p><h3 id="浮点加法运算">4.6.1 浮点加法运算</h3><ol type="1"><li><strong>浮点数加减运算步骤</strong><ul><li><p><strong>对阶</strong><br />使两数阶码相等。</p><p><span class="math display">\[\Delta E = E_A - E_B\]</span></p><table><thead><tr class="header"><th>阶码差</th><th>操作</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\Delta E = 0\)</span></td><td>不操作</td></tr><tr class="even"><td><span class="math inline">\(\Delta E &gt; 0\)</span></td><td><span class="math inline">\(M_B\)</span> 右移，<span class="math inline">\(E_B\)</span> 自增，直至 <span class="math inline">\(E_B = E_A\)</span></td></tr><tr class="odd"><td><span class="math inline">\(\Delta E &lt; 0\)</span></td><td><span class="math inline">\(M_A\)</span> 右移，<span class="math inline">\(E_A\)</span> 自增，直至 <span class="math inline">\(E_A = E_B\)</span></td></tr></tbody></table><p>对阶规则：小阶向大阶看齐。</p></li></ul></li></ol><p /><ul><li><strong>尾数加减</strong><br />结果尾数<br /><span class="math display">\[M_C = M_A \pm M_B\]</span></li></ul><p /><ul><li><p><strong>规格化</strong><br />规格化尾数应满足<br /><span class="math display">\[\frac{1}{2} \leq |M| &lt; 1\]</span></p><p>上一步结束后规格化 <span class="math inline">\(M_C\)</span></p><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th>特征</th><th>操作</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(00.1XXX\)</span>、<span class="math inline">\(11.0XXX\)</span></td><td>已规格化</td></tr><tr class="even"><td><span class="math inline">\(00.0XXX\)</span>、<span class="math inline">\(11.1XXX\)</span></td><td>左规，<span class="math inline">\(M_C\)</span> 左移，<span class="math inline">\(E_C\)</span> 自减，直至规格化</td></tr><tr class="odd"><td><span class="math inline">\(01.XXXX\)</span>、<span class="math inline">\(10.XXXX\)</span></td><td>在定点加减中称为溢出，但这里进行右规，<span class="math inline">\(M_C\)</span> 右移，<span class="math inline">\(E_C\)</span> 自增，直至规格化</td></tr></tbody></table></li></ul><p /><ul><li><p><strong>舍入</strong><br />常用恒舍法，即精度之外的位无条件舍弃。</p></li><li><p><strong>溢出判断</strong><br />浮点数溢出由阶码决定，若阶码也使用双符号补码，</p><table><thead><tr class="header"><th><span class="math inline">\((E_C)_{\text{补}}\)</span></th><th>操作</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(01, XXX\)</span></td><td>上溢，浮点数真正溢出，需做溢出中断处理</td></tr><tr class="even"><td><span class="math inline">\(10, XXX\)</span></td><td>下溢，浮点值趋近 0，按机器零处理</td></tr></tbody></table></li></ul><ol start="2" type="1"><li><strong>举例</strong><br /><span class="math display">\[(0.101110)_2 \times 2^{-(01)_2} + (0.101011)_2 \times 2^{-(10)_2} = (0.110001)_2 \times 2^{-(10)_2}\]</span></li></ol><h3 id="浮点乘除运算">4.6.2 浮点乘除运算</h3><ol type="1"><li><p><strong>乘法</strong><br /><span class="math display">\[A \times B = (M_A \times M_B) \times 2^{E_A + E_B}\]</span></p><ul><li><p><strong>阶码相加</strong><br />阶码用补码表示，相加后无需校正。<br />阶码用移码表示，相加后要减去偏置值 <span class="math inline">\(2^n\)</span>。</p></li><li><p><strong>尾数相乘</strong><br />同定点乘法。</p></li><li><p><strong>尾数结果规格化</strong><br />尾数结果 <span class="math inline">\(M_C\)</span> 一定满足<br /><span class="math display">\[\frac{1}{4} \leq |M_C| \leq 1\]</span></p><table><thead><tr class="header"><th><span class="math inline">\(M_C\)</span></th><th>操作</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\geq \frac{1}{2}\)</span></td><td>已规格化</td></tr><tr class="even"><td><span class="math inline">\(&lt; \frac{1}{2}\)</span></td><td>左规一次，发生下溢则按机器零处理</td></tr></tbody></table></li></ul></li></ol><h2 id="十进制整数加法运算">4.7 十进制整数加法运算</h2><h3 id="一位十进制加法运算">4.7.1 一位十进制加法运算</h3><ol type="1"><li><strong>8421 码加法运算</strong><ul><li>两数相加，逢二进一。</li><li>（十进制）和小于 9，不作校正；和大于 9，作 + 6 校正，产生向上一位进位。</li></ul></li><li><strong>余 3 码加法运算</strong><ul><li>两数相加，逢二进一。</li><li>（十进制）和无进位，减 3 校正；和有进位，加 3 校正。</li></ul></li></ol><h3 id="十进制加法器">4.7.2 十进制加法器</h3><ol type="1"><li><p><strong>8421 码加法器</strong><br /><img src="/image/25-10-14-4-CompOrg-machine-calculation/1763990699489.webp" alt="1763990699489" /><br />图中 FA 为全加器，HA 为半加器。</p></li><li><p><strong>余 3 码加法器</strong><br /><img src="/image/25-10-14-4-CompOrg-machine-calculation/1763990790119.webp" alt="1763990790119" /><br />由运算法则知校正前后最后一位必相反，故使用非门简化。</p></li></ol><h3 id="多位十进制加法">4.7.3 多位十进制加法</h3><p>多位十进制加法可完全遵照一位十进制数加法规则。</p><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th>8421 码</th><th>余 3 码</th></tr></thead><tbody><tr class="odd"><td><img src="/image/25-10-14-4-CompOrg-machine-calculation/1763991116150.webp" alt="1763991116150" /></td><td><img src="/image/25-10-14-4-CompOrg-machine-calculation/1763991133301.webp" alt="1763991133301" /></td></tr></tbody></table><h2 id="逻辑运算与实现">4.8 逻辑运算与实现</h2><ol type="1"><li><p><strong>逻辑非</strong><br />按位<strong>取反</strong>。</p></li><li><p><strong>逻辑乘</strong><br />将两数相应位进行<strong>按位或</strong>操作。</p></li><li><p><strong>逻辑加</strong><br />将两数相应位进行<strong>按位与</strong>操作。</p></li><li><p><strong>逻辑异或</strong><br />将两数相应位进行<strong>按位异或</strong>（求<strong>模 2 和</strong>）操作。</p></li></ol><h2 id="运算器的基本组成与实例">4.9 运算器的基本组成与实例</h2><h3 id="运算器结构">4.9.1 运算器结构</h3><ol type="1"><li><p><strong>运算器的基本组成</strong><br />ALU、寄存器组、判别逻辑和控制电路。</p><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th>带多路选择器的运算器</th><th>带输入锁存器的运算器</th></tr></thead><tbody><tr class="odd"><td>各寄存器可以独立、多路地将数据送至 ALU 的多路选择器，使 ALU 有选择地同时获得两路输入数据。<br></td><td>运算器的内部总线是一组双向传送的数据线。为了进行双操作数之间的运算操作，ALU 输入端前设置了一级锁存器，可暂存操作数。</td></tr><tr class="even"><td><img src="/image/25-10-14-4-CompOrg-machine-calculation/1764032867687.webp" alt="1764032867687" /></td><td><img src="/image/25-10-14-4-CompOrg-machine-calculation/1763991916324.webp" alt="1763991916324" /></td></tr></tbody></table></li><li><p><strong>运算器的内部总线结构</strong></p><ul><li><p><strong>单总线结构运算器</strong><br />一次双操作数运算需分成三步，较慢。</p></li><li><p><strong>双、三总线结构运算器</strong></p><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th>双总线结构运算器</th><th>三总线结构运算器</th></tr></thead><tbody><tr class="odd"><td>两根总线传入两操作数，因为总线被操作数占用，运行结果需经缓存器输出</td><td>运算结果由第三条总线输出，算数与逻辑操作可在一步内完成</td></tr><tr class="even"><td><img src="/image/25-10-14-4-CompOrg-machine-calculation/1764032867687.webp" alt="1764032867687" /></td><td><img src="/image/25-10-14-4-CompOrg-machine-calculation/1764032879988.webp" alt="1764032879988" /></td></tr></tbody></table></li></ul></li></ol><h3 id="alu-举例">4.9.2 ALU 举例</h3><ol type="1"><li><p><strong>ALU 电路</strong><br />加减乘除都可归结为加法运算，所以 ALU 核心首先应该是一个并行加法器，同时能执行逻辑运算。</p></li><li><p><strong>4 位 ALU 芯片</strong><br />74181 为典型的 4 位 ALU 芯片。接收两个操作数，能进行 16 种算术运算和 16 种逻辑运算。<br /><img src="/image/25-10-14-4-CompOrg-machine-calculation/1764033234725.webp" alt="1764033234725" /><br /><img src="/image/25-10-14-4-CompOrg-machine-calculation/1764033283314.jpg" alt="1764033283314" /></p></li><li><p><strong>ALU 的应用</strong><br />74181 可以采用并行进位或串行进位（连接底一片的 C<sub>n+4</sub> 与高一片的 C<sub>n</sub>）。<br />并行进位时需要 74182 进行先行进位。<br /><img src="/image/25-10-14-4-CompOrg-machine-calculation/1764033593574.webp" alt="1764033593574" /></p></li></ol><h3 id="浮点运算器举例">4.9.3 浮点运算器举例</h3><p>微机系统往往配有专门的浮点运算部件，如 80x87 浮点协处理器。</p><ol type="1"><li><p><strong>80x87 的数据格式</strong><br /><img src="/image/25-10-14-4-CompOrg-machine-calculation/1764033767777.webp" alt="1764033767777" /></p></li><li><p><strong>80x87 的内部结构</strong><br /><img src="/image/25-10-14-4-CompOrg-machine-calculation/1764033813657.webp" alt="1764033813657" /></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【计算机组成原理】 第三章 指令系统</title>
      <link href="/2025/10/15/25-10-14-3-CompOrg-3-command-system/"/>
      <url>/2025/10/15/25-10-14-3-CompOrg-3-command-system/</url>
      
        <content type="html"><![CDATA[<h2 id="指令格式">3.1 指令格式</h2><ol type="1"><li><p><strong>基本格式</strong></p><table><tbody><tr class="odd"><td>操作码字段</td><td>地址码字段</td></tr></tbody></table></li><li><p><strong>地址码结构</strong><br />对于一般的双操作数运算指令，除去<strong>操作码（Operation Code）</strong>，还包含</p><ul><li>第一操作数地址 <span class="math inline">\(A_1\)</span>，</li><li>第二操作数地址 <span class="math inline">\(A_2\)</span>，</li><li>操作结果存放地址 <span class="math inline">\(A_3\)</span>，</li><li>下一条指令地址 <span class="math inline">\(A_4\)</span>。</li></ul></li><li><p><strong>指令结构</strong></p><ul><li><strong>四地址指令</strong><ul><li>含义：<span class="math inline">\((A_1) OP (A_2) \rightarrow A_3\)</span></li><li>直观，但太长，不实际。</li></ul></li><li><strong>三地址指令</strong><ul><li>含义：<span class="math inline">\((A_1) OP (A_2) \rightarrow A_3\)</span>，<span class="math inline">\((PC) + 1 \rightarrow PC\)</span></li><li>每执行一条指令，<strong>程序计数器（PC）</strong> 自增。</li><li>仍然较长，在大、中型计算机使用。</li><li>适用于向量、矩阵运算。</li></ul></li><li><strong>二地址指令</strong><ul><li>含义：<span class="math inline">\((A_1) OP (A_2) \rightarrow A_1\)</span>，<span class="math inline">\(\rm (PC) + 1 \rightarrow PC\)</span></li><li><span class="math inline">\(A_1\)</span> 为<strong>目的操作数地址</strong>，<span class="math inline">\(A_2\)</span>为<strong>源操作数地址</strong>。<span class="math inline">\(A_1\)</span>中原内容会被破坏。</li><li>至少需要访问<strong>四次主存</strong>。</li></ul></li><li><strong>一地址指令</strong><ul><li>含义：<span class="math inline">\((Acc) OP (A_1) \rightarrow Acc\)</span>，<span class="math inline">\((PC) + 1 \rightarrow PC\)</span></li><li>另一个操作数在<strong>累加寄存器（Accumulator）</strong> 中，操作结果也存入累加寄存器，用于累加操作、连续运算。</li><li>只需访问<strong>两次</strong>主存。</li></ul></li><li><strong>零地址指令</strong><ul><li>只有操作码，没有地址码。</li><li>操作数从堆栈顶部<strong>弹出</strong>，结果<strong>压入</strong>堆栈。<br /></li><li>用于<strong>嵌套、递归</strong>。</li></ul><blockquote><p><strong>堆（Heap）</strong> 是程序运行时用于动态分配内存的一块区域。与栈不同，堆的内存分配和释放通常由程序员手动控制（如 C/C++ 中的 <code>malloc</code>/<code>free</code>），或者由垃圾回收机制自动管理（如 Java、Python）。堆空间较大，但分配和释放效率较低，且容易出现内存碎片。<br /><strong>栈（Stack）</strong> 是程序运行时自动分配和释放的内存区域，主要用于存放函数的参数、局部变量等。栈由系统自动管理，内存连续，分配和释放速度快，但容量有限。栈的操作方式类似于数据结构中的栈，即“先进后出”。<br /><strong>堆栈</strong>通常指“栈”，尤其是在底层和系统编程中；少数情况下也可指“堆和栈”的总称。</p></blockquote></li><li><strong>规律</strong><br />地址数越少：<ul><li>程序越<strong>长</strong>。</li><li>程序存储量<strong>越小</strong>。</li><li>执行速度<strong>越低</strong>。</li></ul></li></ul></li><li><p><strong>操作码编码</strong></p><ul><li><p><strong>规整型（定长）编码</strong><br />操作码位数、位置固定。设系统共有 <span class="math inline">\(m\)</span> 条指令，<span class="math inline">\(N\)</span> 位操作码字段，则<br /><span class="math display">\[m \leq 2^N \\N \geq \log_2m\]</span></p><p>可简化硬件设计，减少编译时间，用于字长较长的大、中型计算机与超级小型计算机。</p></li><li><p><strong>非规整型（变长）编码</strong><br />操作码位数不固定，分散放在指令字不同位置上。压缩指令操作码字段平均长度。</p><ul><li><strong>扩展操作码法</strong><ul><li>假设某指令最长 16 位，4 位一组可作为三地址指令，操作码 0000 ~ 1110。</li><li>将前四位固定为 1111（扩展窗口），剩下 12 为可作为二地址指令，操作码 1111 0000 ~ 1111 1110。</li><li>同理，一地址指令操作码 1111 1111 0000 ~ 1111 1111 1110。</li><li>特殊地，零地址指令操作码 1111 1111 1111 0000 ~ 1111 1111 1111 111<strong>1</strong>。（此处<strong>无需扩展窗口</strong>）</li></ul>使操作数多的指令操作码字段长尽量短，操作数少的指令操作码字段长尽量长。<br />要求：<ul><li>不允许短码是长码的前缀。</li><li>操作码不能重复。</li></ul></li></ul></li></ul></li></ol><h2 id="寻址技术">3.2 寻址技术</h2><p>寻找操作数的地址或下一条指令的地址，包括编址方式和寻址方式。</p><ol type="1"><li><strong>编址方式</strong><br />对各种存储设备进行编码的方式。<ul><li><strong>编址单位</strong><ul><li>字编址：编址单位与访问单位相一致。</li><li>字节编址：编址单位与一字节相一致。字节编址方式存在地址信息浪费。</li><li>位编址：浪费更大。</li></ul></li><li><strong>位数</strong><ul><li>与<strong>主存容量</strong>和<strong>编址单位</strong>有关。</li></ul></li></ul></li><li><strong>寻址方式</strong><ul><li>指令寻址、数据寻址。</li><li>顺序寻址、跳跃寻址。</li></ul></li><li><strong>数据寻址</strong><br />根据地址码寻找真实操作数地址。<ul><li><strong>立即寻址</strong><ul><li>指令中直接存放操作数本身，这样的数称为<strong>立即数</strong>。</li><li>操作数不能被修改，长度受指令长度限制，用于赋初值或提供常数。</li></ul></li><li><strong>寄存器寻址</strong><ul><li>给出某通用寄存器编号 <span class="math inline">\(R_i\)</span>，寄存器中为操作数。<span class="math inline">\(S = (R_i)\)</span>。</li><li>速度快，地址码字段短，<strong>几乎所用计算机都使用</strong>。</li></ul></li><li><strong>直接寻址</strong><ul><li>地址码 <span class="math inline">\(A\)</span> 即为操作数有效地址形式地址等于有效地址，<span class="math inline">\(EA = A\)</span>，<span class="math inline">\(S = (A)\)</span>。</li><li>不需寻址运算，简单，便于硬件实现，但地址空间受地址码字段位数限制。</li></ul></li><li><strong>间接寻址</strong><ul><li>地址码为主存中存储操作数的单元的地址。指令中划出标明直接（<span class="math inline">\(@ = 0\)</span>）或间接（<span class="math inline">\(@ = 1\)</span>）寻址的标志位。<span class="math inline">\(EA = (A)\)</span>，<span class="math inline">\(S = ((A))\)</span>。</li><li>分为一级间接寻址与多级间接寻址。</li></ul></li><li><strong>寄存器间接寻址</strong><ul><li>通用寄存器给出主存中存储操作数的单元的地址。<span class="math inline">\(S = ((R_i))\)</span>。</li><li>指令较短，只需一次访存。</li></ul></li><li><strong>变址寻址</strong><ul><li>将编址寄存器 <span class="math inline">\(R_x\)</span> 内容与地址码 <span class="math inline">\(A\)</span> 相加得到有效地址，<span class="math inline">\(EA = (R_x) + A\)</span>，<span class="math inline">\(S = (EA)\)</span>。</li><li>频繁修改地址时只需修改变址值，用于成批数据处理。</li></ul></li><li><strong>基址寻址</strong><ul><li><p>将基址寄存器 <span class="math inline">\(R_b\)</span> 内容与指令中位移量 <span class="math inline">\(D\)</span> 相加得到有效地址，<span class="math inline">\(EA = (R_b) + D\)</span>，<span class="math inline">\(S = ((R_b) + D)\)</span>。</p></li><li><p>将用户编程时的逻辑地址转化为物理地址。</p></li><li><p>区别</p><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><tbody><tr class="odd"><td>变址寻址</td><td>变址寻址是面向用户的，用于访问字符串、向量和数组等成批数据</td></tr><tr class="even"><td>基址寻址</td><td>基址寻址面向系统，主要用于逻辑地址和物理地址的变换，用以解决程序在主存中的再定位和扩大寻址空间等向题</td></tr></tbody></table></li></ul></li><li><strong>相对寻址</strong><ul><li>由程序计数器提供基准地址，指令中地址码作为位移量 <span class="math inline">\(D\)</span>。<span class="math inline">\(EA = (PC) + D\)</span>。</li></ul></li><li><strong>页面寻址</strong><ul><li><p>将整个主存空间分成若干大小相同的区，每个区成为<strong>一页</strong>。</p></li><li><p>分类</p><table><tbody><tr class="odd"><td>基页（零页寻址）</td><td><span class="math inline">\(EA = 0 // A\)</span>，操作数在零页面中。</td></tr><tr class="even"><td>当前页寻址</td><td>页面地址为程序计数器高位内容，<span class="math inline">\(EA = (PC)_H // A\)</span>。</td></tr><tr class="odd"><td>页寄存器地址</td><td>页寄存器提供页面地址。</td></tr></tbody></table></li><li><p>寻址方式标识<br /></p><center><p><img src="/image/Summaries/1758960780042.png" width = "300" height = "207" alt="移码和真值的映射" align=center /></p></center></li></ul></li></ul></li><li><strong>变型或组合寻址方式</strong><ul><li><strong>自增型寄存器间址和自减型寄存器间址</strong><ul><li>自增寻址时，寄存器 <span class="math inline">\(R_i\)</span> 内容为有效地址，<span class="math inline">\(EA = (R_i), R \leftarrow (R_i) + d\)</span>。<span class="math inline">\(d\)</span> 为修改量，记作<span class="math inline">\((R_i)+\)</span>，表示先操作后修改。</li><li>自减寻址时，<span class="math inline">\(R_i \leftarrow (R_i) - d, EA = (R_i)\)</span>，记作 <span class="math inline">\(-(R_i)\)</span>，表示先修改后操作。</li></ul></li><li><strong>扩展变址方式</strong><ul><li><strong>前变址寻址方式</strong><br /><span class="math inline">\(EA = ((R_x) + A), S = (((R_x) + A))\)</span>。</li><li><strong>后变址寻址方式</strong><br /><span class="math inline">\(EA = (R_x) + (A), S = ((R_x) + (A))\)</span>。</li><li><strong>基址变址寻址</strong><br />基址寄存器 <span class="math inline">\(R_b\)</span>，变址寄存器 <span class="math inline">\(R_x\)</span>，位移量 <span class="math inline">\(D\)</span>，<span class="math inline">\(EA = (R_b) + (R_x) + D\)</span>。</li></ul></li></ul></li></ol><h2 id="堆栈与堆栈操作">3.3 堆栈与堆栈操作</h2><ol type="1"><li><p><strong>寄存器堆栈</strong><br />用一组专门的寄存器构成的堆栈，也称<strong>硬堆栈</strong>。具有自动推移功能。栈顶位置固定，无栈顶指针。</p></li><li><p><strong>存储器堆栈</strong><br />从主存中划出一段区域作为堆栈，也称<strong>软堆栈</strong>。栈底固定，需要专门的硬件寄存器作为栈顶指针（SP）。</p><ul><li>自底向上生成堆栈</li><li>自顶向下生成堆栈</li></ul></li><li><p><strong>堆栈操作</strong></p></li></ol><h2 id="指令类型">3.4 指令类型</h2><ol type="1"><li><strong>数据传送类指令</strong><ul><li><p><strong>一般传送指令 MOV</strong><br />数据从源地址传送到目的地址，而源地址不变</p></li><li><p><strong>堆栈操作指令 PUSH，POP</strong></p></li><li><p><strong>数据交换指令</strong></p></li></ul></li><li><strong>运算类指令</strong><ul><li><p><strong>算数运算类指令</strong></p></li><li><p><strong>逻辑运算类指令</strong></p><ul><li><strong>按位测（位检查）</strong><br /></li><li><strong>按位清（位清除）</strong><br /></li><li><strong>按位置（位设置）</strong></li><li><strong>按位修改</strong><br /></li><li><strong>判符合</strong></li></ul></li></ul></li><li><strong>移位类指令</strong><ul><li><strong>算数移位</strong></li><li><strong>逻辑移位</strong></li><li><strong>循环移位</strong></li></ul></li><li><strong>程序控制类指令</strong><ul><li><strong>转移指令</strong><br /></li><li><strong>子程序调用指令</strong></li></ul></li><li><strong>输入输出类指令</strong><ul><li><strong>独立编址的 I/O 指令</strong></li><li><strong>统一编址的 I/O 指令</strong></li></ul></li><li><strong>80x86 指令系统举例</strong><ul><li>MOV</li><li>PUSH/POP</li><li>加减、比较</li><li>乘除</li><li>BCD、ASCII 运算</li><li>基本逻辑指令</li><li>位测试指令</li><li>移位与循环指令</li><li>转移控制指令</li><li>子程序调用与返回指令</li><li>输入输出指令</li></ul></li></ol><h2 id="指令系统的发展">3.5 指令系统的发展</h2><ol type="1"><li><p><strong>x86 架构的扩展指令集</strong></p><ul><li>MMX（Multi Media eXtension）</li><li>SSE（Streaming SIMD Extension）</li><li>3DNow</li><li>SSE2</li><li>SSE3</li><li>SSE4</li><li>SSE5</li><li>AVX（Advanced Vector eXtension）</li><li>FMA（Fused Multiply Accumulate）</li></ul></li><li><p><strong>从复杂指令系统道精简指令系统</strong></p></li><li><p><strong>VLIW（Very Long Instruction Word） 和 EPIC（Explicit Parallel Instruction Code）</strong></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【计算机组成原理】 第二章 数据的机器层次表示</title>
      <link href="/2025/10/15/25-10-14-2-CompOrg-2-data-represent/"/>
      <url>/2025/10/15/25-10-14-2-CompOrg-2-data-represent/</url>
      
        <content type="html"><![CDATA[<h2 id="数值数据的表示">2.1 数值数据的表示</h2><ol type="1"><li><p><strong>无符号数</strong><br />整个机器字长全部二进制位位数值位。<br />范围 <span class="math inline">\([0, 2^n - 1]\)</span>。</p></li><li><p><strong>原码</strong><br />将最高位设为符号位，其余位数值位，与真值相同。<br />其中，<span class="math inline">\([+0]_原 = 00000\)</span>，<span class="math inline">\([-0]_原 = 10000\)</span>。<br />原码实现乘除简单，实现加减复杂。<br />范围 <span class="math inline">\([-(2^{n - 1} - 1), 2^{n - 1} - 1]\)</span>。</p></li><li><p><strong>补码</strong><br />正数补码与原码相同，负数补码为真值数值按位取反，在最低位加 1。<br />其中，<span class="math inline">\([+0]_补 = [-0]_补 = 00000\)</span>。<br />范围 <span class="math inline">\([-2^{n - 1}, 2^{n - 1} - 1]\)</span>。</p></li><li><p><strong>反码</strong><br />正数反码与原码相同，负数补码为真值数值按位取反。<br />其中，<span class="math inline">\([+0]_原 = 00000\)</span>，<span class="math inline">\([-0]_原 = 11111\)</span>。<br />范围 <span class="math inline">\([-(2^{n - 1} - 1), 2^{n - 1} - 1]\)</span>。</p></li></ol><h2 id="机器数的定点表示与浮点表示">2.2 机器数的定点表示与浮点表示</h2><ol type="1"><li><p><strong>定点小数</strong><br />即纯小数（<span class="math inline">\(-1 &lt; x &lt; 1\)</span>），小数点位置固定，整数位被取代为符号位。设机器字长 <span class="math inline">\(n + 1\)</span> 位，原码、反码范围 <span class="math inline">\([-(1 - 2^{-n}), 1 - 2^{-n}]\)</span>，补码 <span class="math inline">\([-1, 1 - 2^{-n}]\)</span>。<br /></p><center><p><img src="/image/Summaries/1757250188210.png" width = "300" height = "130" alt="兼容性示意" align=center /></p></center></li><li><p><strong>定点整数</strong><br />纯整数（<span class="math inline">\(\mathbb{Z}\)</span>），小数点位置固定。</p></li><li><p><strong>浮点数</strong><br />浮点数<span class="math inline">\(N\)</span>为<br /><span class="math display">\[N = M \cdot r^E\]</span><br /><span class="math inline">\(E\)</span> 为<strong>阶码（Exponent）</strong>，<span class="math inline">\(M\)</span> 为<strong>尾数（Mantissa）</strong>，<span class="math inline">\(r\)</span> 为阶码的<strong>底</strong>，暂取 <span class="math inline">\(r = 2\)</span>。</p></li><li><p><strong>规格化浮点数</strong><br />为充分利用尾数有效位，规定规格化浮点数尾数最高位必须有效，即<br /><span class="math display">\[|M| \in [\frac{1}{r}, 1)\]</span><br />&gt; <span class="math inline">\(\frac{1}{2}\)</span>的原码为规格化数，补码不是；<span class="math inline">\(-1\)</span>无法用原码表示，补码为规格化数。</p><p>浮点数典型值<br /><img src="/image/Summaries/1757676990902.png" alt="1757676990902" /></p></li><li><p><strong>浮点数阶码的移码表示法</strong></p><ul><li>移码<br />移码可将带符号数映射到正数域。<br /><span class="math display">\[[X]_移 = X + 偏置值\]</span><br />设补码长度为 <span class="math inline">\(n\)</span> 位，偏置值则为 <span class="math inline">\(2^n\)</span> ，即<br /><center><img src="/image/Summaries/1757677423598.png" width = "300" height = "165" alt="移码和真值的映射" align=center /></center></li><li>移码的性质<ul><li>最高位为 <span class="math inline">\(0\)</span> 表示负数，最高位为 <span class="math inline">\(1\)</span> 表示正数。</li><li><span class="math inline">\([+0]_移 = [-0]_移 = 10000000\)</span></li><li>可将移码视为无符号数，直接按无符号数规则比较大小。</li><li>将某数的补码最高位取反即可得移码。</li></ul></li><li>作用<ul><li>便于比较浮点数大小。</li><li>简化判零电路。</li></ul></li></ul></li><li><p><strong>尾数基数 <span class="math inline">\(r\)</span></strong></p><ul><li>尾数基数可影响<ul><li>可表示数得范围。</li><li>数在数轴上的分布。</li><li>可表示数的精度。</li><li>运算的精度损失</li></ul></li></ul></li><li><p><strong>IEEE 754 标准浮点数</strong></p><ul><li>格式<br /><img src="/image/Summaries/1757678303857.png" alt="1757678303857" /><br /></li><li>三种浮点数<br /><img src="/image/Summaries/1757678382268.png" alt="1757678382268" /><br />注意，偏置值为<span class="math inline">\(2^{n - 1} - 1\)</span>，<span class="math inline">\(n\)</span>为阶码长度。<br />对于规格化的二进制浮点数，最高数值位总是<span class="math inline">\(1\)</span>，可隐含尾数数值长度实际为<span class="math inline">\(24\)</span>、<span class="math inline">\(53\)</span>、<span class="math inline">\(65\)</span>位。</li></ul></li><li><p><strong>IEEE 754 标准浮点数（十六进制写法）与十进制数的互相转化</strong></p><ul><li>将十进制数转为短浮点数<ul><li><p>把十进制数转换为二进制数（非标准）。<br /></p></li><li><p>规格化。<br /></p></li><li><p>计算阶码的移码（偏置值 + 阶码真值）。</p></li><li><p>以尾数符号、阶码移码、<strong>尾数数值（去除需隐含的位）</strong> 的顺序拼接二进制数。</p><blockquote><p>位数如果不足 23 位则向后补足 23 位。</p></blockquote></li><li><p>四位为一组，写出十六进制数。</p></li></ul></li><li>将短浮点数转为十六进制数<ul><li>将十六进制数写为二进制数，分离出尾数符号、阶码移码、<strong>尾数数值（无需隐含的位）</strong>。</li><li>计算阶码真值。</li><li>写出规格化二进制数（<strong>原隐含位与尾数数值合并</strong>）。</li><li>非规格化（尾数与乘方合并，即移位）。</li><li>转换位十进制数。</li><li><font color="red"><strong>加上符号。</strong></font></li></ul></li></ul><p>IEEE 754 短浮点数与规格化浮点数 <span class="math inline">\(v\)</span> 的关系<br /><span class="math display">\[v = (-1)^S \cdot (1.f) \cdot 2^{E - 127}\]</span></p><p><span class="math inline">\(S\)</span> 为符号位，<span class="math inline">\(E\)</span> 为移码阶码，<span class="math inline">\(f\)</span> 为尾数小数部分。</p></li><li><p><strong>定点、浮点表示法与定点、浮点计算机</strong></p><ul><li><p>定点、浮点表示法的区别</p><table><colgroup><col style="width: 33%" /><col style="width: 33%" /><col style="width: 33%" /></colgroup><thead><tr class="header"><th></th><th>定点表示法</th><th>浮点表示法</th></tr></thead><tbody><tr class="odd"><td>数值范围</td><td>小，分布均匀</td><td>大，越靠近原点越密集</td></tr><tr class="even"><td>精度（等字长）</td><td>高</td><td>低</td></tr><tr class="odd"><td>运算</td><td>简单</td><td>复杂</td></tr><tr class="even"><td>溢出处理</td><td>超出表示范围一定溢出</td><td>超出尾数范围不一定溢出，阶码范围也超出时才溢出</td></tr></tbody></table></li><li><p>定点机与浮点机</p><ul><li>定点机：所有操作均为定点数，浮点运算需借助软件子程序。</li><li>定点机 + 浮点运算部件</li><li>浮点机：具有浮点运算指令与基本浮点运算器。</li></ul></li></ul></li></ol><h2 id="非数值数据的表示">2.3 非数值数据的表示</h2><ol type="1"><li><strong>字符、字符串的表示</strong><ul><li>ASCII：7 位二进制。</li><li>存放<ul><li>向量存放法：最简单、最节省空间。</li><li>串表法：链表形式，但主存利用率下降。</li></ul></li></ul></li><li><strong>汉字编码</strong><ul><li>GB 2312—80（国标码）：两个字节，用低七位编码。</li><li>区位码：区号—位号（十六进制）。关系<br /><span class="math display">\[国标码 = 区位码（十六进制）+ 2020\rm H\]</span><br /></li><li>机内码：处理中西文兼容。<br /><span class="math display">\[机内码 = 国标码 + 8080\rm H\]</span></li><li>字形码：汉字点阵中，笔画索道之处记为<span class="math inline">\(1\)</span>。</li></ul></li><li><strong>统一代码（Unicode）</strong></li></ol><h2 id="十进制数与数串的表示">2.4 十进制数与数串的表示</h2><ol type="1"><li><strong>二进制编码的十进制数（Binary Code Decimal，BCD）</strong><br /><img src="/image/Summaries/1757683990139.png" alt="1757683990139" /><ul><li>8421 码：1010~1111为非法码。</li><li>2421 码<ul><li><strong>对 9 的自补码</strong>：自身按位取反得到该数对 9 的补数。</li><li>0101~1010 为非法码。</li></ul></li><li>余 3 码：一种无权码，为 8421 码加 <strong>0011</strong>。</li><li>Gray 码<ul><li>无权码</li><li>相邻两个码只有一位不同。</li><li>首尾两个码也只有一位不同。</li><li>非法码视具体方案而定。</li></ul></li></ul></li><li><strong>十进制数串</strong><ul><li>非压缩的十进制数串<br />即字符串，一个字节存放一个十进制数或符号 ASCII 码。<ul><li>前分隔式数字串：符号位占用单独一个字节，放在数值位之前，正号 ASCII 码为<code>2BH</code>，负号为 <code>2DH</code>。</li><li>后嵌入式字符串：正数不变，负数将 <code>40H</code> 与最低数值位相加，数字 0 ~ 9 编码为 <code>70H</code> ~ <code>79H</code>。<br />非压缩的十进制数串主要用于<strong>非数值处理</strong>。</li></ul></li><li>压缩的十进制数串<br />一个字节存放<strong>两位 BCD 码</strong>表示的十进制数，一个压缩的十进制数串占用连续的多字节，符号位占半字节，存放在最低数值位之后。</li></ul></li></ol><h2 id="不同类型的数据表示举例">2.5 不同类型的数据表示举例</h2><ol type="1"><li><strong>C 语言</strong><br /></li><li><strong>现代微型计算机系统中的数据表示</strong></li></ol><h2 id="数据校验码">2.6 数据校验码</h2><ol type="1"><li><p><strong>奇偶校验</strong></p><ul><li>在有效信息前加一个校验位，得到校验码。</li><li>校验位将<strong>使校验码中 1 的个数</strong>为奇数（奇校验）或偶数（偶校验）。<strong>奇校验不存在全 0 代码，使用更多。</strong></li><li>校验出错时，表明一定有错，但不知何处出错。</li></ul></li><li><p><strong>交叉奇偶校验</strong><br />不仅每一个字节有奇偶校验，全部字节同一位也设置一个奇偶校验位置做纵向校验。可以发现两位同时出错的情况。</p></li><li><p><strong>汉明（Hamming）校验码</strong><br />在有效信息位中插入几个校验位形成汉明码，使码距较均匀地拉大，并把每一个二进制位分配到几个就校验组中。某一位出错时可引起几个校验位地值发生变化。</p></li><li><p><strong>循环冗余校验码（Cyclic Redundancy Check, CRC）</strong><br /></p><center><p><img src="/image/Summaries/1757750927649.png" width = "300" height = "168" alt="移码和真值的映射" align=center /></p></center><ul><li>把带编码的<span class="math inline">\(N\)</span>位有效信息表示为多项式<span class="math inline">\(M(X)\)</span>。</li><li>将<span class="math inline">\(M(X)\)</span>左移<span class="math inline">\(K\)</span>位得<span class="math inline">\(M(X) \cdot X^K\)</span>，再用另一个约定得多项式<span class="math inline">\(G(X)\)</span>（<span class="math inline">\(K + 1\)</span>位）去除，得到余数<span class="math inline">\(R(X)\)</span>，与有效位拼接后得到CRC。</li><li>余数与出错位序号之间有唯一关系。</li><li>生成多项式的选择<ul><li>任何一位发生错误都使余数不为<span class="math inline">\(0\)</span>。</li><li>不同位发生错误使余数不同。</li><li>对余数做模<span class="math inline">\(2\)</span>除法，应使余数循环。</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【计算机组成原理】 第一章 概论</title>
      <link href="/2025/10/15/25-10-14-1-CompOrg-1-intro/"/>
      <url>/2025/10/15/25-10-14-1-CompOrg-1-intro/</url>
      
        <content type="html"><![CDATA[<h1 id="教材">教材</h1><p><a href="http://tup.tsinghua.edu.cn/bookscenter/book_08395002.html">计算机组成原理（第四版） 蒋本珊 清华大学出版社</a></p><h1 id="第一章-概论">第一章 概论</h1><h2 id="电子计算机与存储程序控制">1.1 电子计算机与存储程序控制</h2><ol type="1"><li><p><strong>存储程序的计算机</strong><br />世界上第一台数字计算机：美国 ENIAC（1946）。<br />早期存储程序控制的计算机：美国 EDVAC（Von Neumann, 1951），英国 EDSAC（1949）。</p></li><li><p><strong>存储程序概念（Von Neumann, 1945）</strong></p><ul><li>计算机硬件应由五大基本部件组成。</li><li>计算机内部采用二进制表示指令和数据。</li><li>将程序与原始数据存入存储器中，在启动计算机工作。</li></ul></li></ol><h2 id="计算机的硬件组成">1.2 计算机的硬件组成</h2><ol type="1"><li><p><strong>计算机的主要部件</strong></p><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><tbody><tr class="odd"><td>输入设备</td><td>将人们编好的程序和原始数据输送到计算机中，并将其转化为计算机内部所能识别和接受的信息方式的部件</td></tr><tr class="even"><td>输出设备</td><td>将计算机的处理结果以人或其他设备所能接收的形式送出计算机的设备</td></tr><tr class="odd"><td>存储器</td><td>用于存放程序和数据的部件</td></tr><tr class="even"><td>运算器</td><td>对信息进行处理和运算的部件，又称算数逻辑运算部件（Arithmetic and Logical Unit, ALU）</td></tr><tr class="odd"><td>控制器</td><td>按照人们预先确定的操作步骤，控制整个计算机各部件有条不紊地自动工作地部件</td></tr></tbody></table></li><li><p><strong>计算机各部件的连接</strong></p><ul><li><p>小微型机的典型结构：总线结构<br />总线（Bus）：一组能为多个部件服务的公共信息传送线路，分时地发送与接收各部件地信息。</p><table><colgroup><col style="width: 33%" /><col style="width: 33%" /><col style="width: 33%" /></colgroup><thead><tr class="header"><th>总线</th><th>结构</th><th>功能</th></tr></thead><tbody><tr class="odd"><td>地址总线（Address Bus）</td><td>单方向、多根线</td><td>CPU 向主存、外设传输地址</td></tr><tr class="even"><td>数据总线（Data Bus）</td><td>双方向、多根线</td><td>CPU 向主存、外设读入、送出数据</td></tr><tr class="odd"><td>控制总线（Control Bus）</td><td>双方向、多根线</td><td>CPU 送出控制命令和主存、外设向CPU反馈信号</td></tr></tbody></table></li><li><p>大、中型计算机的典型结构：通道结构<br />更着重于系统扩大与效率提高。在系统连接上分为四级：主机、通道、设备控制器和外部设备。</p></li></ul></li><li><p><strong>计算机设计者观察到的计算机硬件系统</strong><br /></p><center><p><img src="/image/Summaries/1757150813397.png" width = "300" height = "388" alt="计算机设计者观察到的计算机硬件系统" align=center /></p></center></li><li><p><strong>存储器设计思想</strong></p><ul><li><p>冯·诺伊曼（普林斯顿）结构<br />指令和数据不加区别地混合存储在统一存储器中，共享数据总线。<br /></p><center><p><img src="/image/Summaries/1757154345657.png" width = "300" height = "154" alt="冯·诺伊曼结构" align=center /></p></center><p>冯·诺伊曼结构不能同时取指令和数据，且易造成总线拥挤。</p></li><li><p>哈佛结构<br />存储分为程序存储器（PM）和数据存储器(DM)。<br /></p><center><p><img src="/image/Summaries/1757154663091.png" width = "435" height = "150" alt="冯·诺伊曼结构" align=center /></p></center><blockquote><p>缺点：硬件复杂、空间利用低、不灵活。</p></blockquote></li></ul><p>现在常将高速缓冲器（Cache）采用哈佛结构，主存采用冯·诺伊曼结构。</p></li></ol><h2 id="计算机系统">1.3 计算机系统</h2><ol type="1"><li><p><strong>硬件与软件的关系</strong><br />软件与硬件没有明确界线。</p><table><thead><tr class="header"><th>做法</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>硬件软化</td><td>增强系统的功能和适应性</td></tr><tr class="even"><td>软件硬化</td><td>降低软件时间开销</td></tr></tbody></table></li><li><p><strong>固件（Firmware, A. Opler, 1967）</strong><br />存储在能永久保存信息的器件（如 ROM）中的<u><b>程序</b></u>，是具有软件功能的硬件。</p></li><li><p><strong>系列机</strong><br />一个厂家生产的，具有相同系统结构，但具有不同组成和实现的一系列不同型号的机器。</p></li><li><p><strong>软件兼容</strong><br />旧软件能在新机器上使用。<br /></p><center><p><img src="/image/Summaries/1757156556399.png" width = "300" height = "289" alt="兼容性示意" align=center /></p></center><p>软件必须保证向后兼容，争取做到向上兼容。</p></li><li><p><strong>计算机系统的多层次结构</strong><br /></p><center><p><img src="/image/Summaries/1757156735992.png" width = "500" height = "530" alt="计算机系统的多层次结构" align=center /></p></center></li><li><p><strong>实际机器与虚拟机器</strong></p><table><tbody><tr class="odd"><td>实际机器</td><td>由硬件和固件实现的机器</td></tr><tr class="even"><td>虚拟机器</td><td>只对某级观察者存在，不关心下级工作，以软件为主</td></tr></tbody></table></li></ol><h2 id="计算机的工作过程和主要性能指标">1.4 计算机的工作过程和主要性能指标</h2><ol type="1"><li><strong>工作过程</strong><ul><li>将程序读到主存中。</li><li>逐条取出指令执行。</li></ul></li><li><strong>性能指标</strong><ul><li>机器字长<br />参与运算的数的基本位数，一般等于内部寄存器大小。字指“数据字”。<br /></li><li>数据通路宽度<br />数据总线一次能并行传送信息的位数。</li><li>主存容量<br /></li><li>运算速度<ul><li>吞吐量、响应时间<br />吞吐量：系统单位时间内处理请求的数量。<br />响应时间：CPU 时间加等待时间。</li><li>CPU 主频、CPU 时钟周期<br />主频：CPU 数字脉冲信号频率。为时钟周期的倒数。</li><li>CPI<br />CPI（Cycles per Instruction）：每条指令所用的周期数。<br />IPC（Instructions per Cycle）：每周期执行的指令数。<br /><span class="math display">\[{\rm IPC} = \frac{1}{\rm CPI}\]</span></li><li>CPU 执行时间<br /><span class="math display">\[\rm CPU 执行时间 = \frac{CPU 时钟周期数}{时钟频率} = \frac{指令数 \times CPI}{时钟频率}\]</span></li><li>MIPS（Millon Instructions per Second），MFLOPS（Millon Floating-point Operations per Second）<br /><span class="math display">\[\rm MIPS = \frac{指令条数}{执行时间 \times 10^{6}} = \frac{主频}{CPI} = 主频 \times IPC\]</span><br /><span class="math display">\[\rm MFLOPS = \frac{浮点操作次数}{执行时间 \times 10^{6}}\]</span></li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 学习 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 介绍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【新功能特辑】不蒜子访问量统计</title>
      <link href="/2025/09/30/25-9-30-1_HexoDev_ver-desc-1_1_0/"/>
      <url>/2025/09/30/25-9-30-1_HexoDev_ver-desc-1_1_0/</url>
      
        <content type="html"><![CDATA[<p>自源代码库版本 <code>1.1.0</code> 起，本站引入<a href="https://busuanzi.ibruce.info/">不蒜子网页访问量统计服务</a>，以提供更准确的访问量统计。</p><h2 id="用户隐私说明">用户隐私说明</h2><p><a href="https://busuanzi.ibruce.info/">不蒜子网页访问量统计服务</a>提供两种统计：页面访问量统计和用户访问量统计。页面访问量统计仅记录页面被访问的动作，用户访问量统计仅收集用户 IP 地址进行去重。这里的 IP 地址只能大致判断用户所在的国家和地区，难以得知用户更私密的信息。且不蒜子是轻量级的统计服务，没有收集用户隐私的服务。</p><h2 id="顺带一提">顺带一提</h2><h3 id="为什么要引入这个服务">为什么要引入这个服务？</h3><p>要回答这个问题，就要了解 Hexo + Butterfly 自带的页面访问量统计<strong>为什么不行</strong>。</p><p>简单来讲，原版页面访问量统计是<strong>可覆盖的</strong>，一次新部署之后访问量统计可能会改变，甚至丢失。回顾网站部署前的命令行操作（我的操作）：<br /><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hexo clean <span class="comment"># 清除缓存，为新功能做准备。</span></span><br><span class="line">hexo generate <span class="comment"># 执行 Markdown 转 HTML、生成搜索索引文件等操作。</span></span><br><span class="line">hexo server <span class="comment"># 在本机上进行**调试**。即便是在服务器上执行此命令也不等同于正式启动服务。</span></span><br><span class="line">hexo server --drafts <span class="comment"># 调试，且展示草稿。</span></span><br><span class="line"></span><br><span class="line">hexo deploy <span class="comment"># 部署服务器，包括 `hexo generate`。</span></span><br></pre></td></tr></table></figure><br />&gt; 注意：<code>hexo deploy</code> 不会自动启动服务，自动启动服务功能是 Github Pages 给的。</p><p>这里，访问量统计被当作了缓存，在 <code>hexo clean</code> 被清理。即便访问量统计能保留，这也是作者在调试时产生的访问统计量，真正的访问量还在线上等着被覆盖呢（悲）。</p><p>这就是静态网站的缺陷：<strong>仅有的数据易被视作缓存，难以长期存储</strong>。这引出了第三方服务的意义之一：<strong>使纯静态网站拥有动态网站的功能，统计的数据更加有意义</strong>。</p><h3 id="这个服务是怎么实现的">这个服务是怎么实现的？</h3><p>不蒜子通过 JavaScript 异步请求实现数据统计，无需复杂的后端配置。其核心流程分为两步：<br />- 前端嵌入代码：在网站页面中插入一段 JS 脚本，用于触发统计请求。<br />- 后端计数服务：接收请求后，根据访问来源（IP、页面 URL 等）更新数据库中的 PV（页面浏览量）和 UV（独立访客数）。</p><p>不蒜子使用轻量级数据库（如 Redis）存储统计数据，以键值对形式记录：<br />| 服务 | 算法 | 功能 |<br />| — | — | — |<br />| 页面访问量统计 | PV（Page View）算法 | 每个 URL 对应一个计数器，长期统计页面被访问的次数 |<br />| 用户访问量统计 | UV（User View）算法 | 在 PV 算法的基础上，将用户一天内的访问视作一次，得到独立访客数 |</p><h3 id="那我缺的-dhcp-这一块的谁给我补啊">那我缺的 DHCP 这一块的谁给我补啊？</h3><p>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）是一个网络管理协议，它的核心作用是<strong>自动地为网络中的设备分配 IP 地址及其他相关网络配置参数</strong>。是网络 IP 分配的常用技术。</p><p>也就是说，用户的 IP 地址是随时变化的，IP 与用户不是一一对应的关系，这可能会使不蒜子将一个用户识别为多个用户，UV 算法准确度降低。您目前在网站上看到的统计量是 PV 算法的。</p><h3 id="怎么配置">怎么配置？</h3><p>通用的办法是，在这个数字要显示的地方（比如模板）嵌入统计代码：<br /><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//api.busuanzi.cc/static/3.6.9/busuanzi.min.js&quot;</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">本站总访问量 <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_site_pv&quot;</span>&gt;</span>加载中...<span class="tag">&lt;/<span class="name">span</span>&gt;</span> 次</span><br><span class="line">本站总访客数 <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_site_uv&quot;</span>&gt;</span>加载中...<span class="tag">&lt;/<span class="name">span</span>&gt;</span> 人</span><br><span class="line">本页总阅读量 <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_page_pv&quot;</span>&gt;</span>加载中...<span class="tag">&lt;/<span class="name">span</span>&gt;</span> 次</span><br><span class="line">本页总访客数 <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_page_uv&quot;</span>&gt;</span>加载中...<span class="tag">&lt;/<span class="name">span</span>&gt;</span> 人</span><br><span class="line"></span><br><span class="line">本站今日访问量 <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_today_site_pv&quot;</span>&gt;</span>加载中...<span class="tag">&lt;/<span class="name">span</span>&gt;</span> 次</span><br><span class="line">本站今日访客数 <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_today_site_uv&quot;</span>&gt;</span>加载中...<span class="tag">&lt;/<span class="name">span</span>&gt;</span> 人</span><br><span class="line">本页今日阅读量 <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_today_page_pv&quot;</span>&gt;</span>加载中...<span class="tag">&lt;/<span class="name">span</span>&gt;</span> 次</span><br><span class="line">本页今日访客数 <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_today_page_uv&quot;</span>&gt;</span>加载中...<span class="tag">&lt;/<span class="name">span</span>&gt;</span> 人</span><br></pre></td></tr></table></figure></p><p>如果使用的是 Butterfly 主题，可以更改<code>\theme\butterfly\layout\widget\card_webinfo.pug</code>：<br /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">script.</span><br><span class="line">    function checkPv()&#123; </span><br><span class="line">        var init_pv = parseInt(!&#123;theme.busuanzi.init_pv&#125;)</span><br><span class="line">        var pv = document.getElementById(&quot;busuanzi_value_site_pv&quot;)</span><br><span class="line">        if (pv.innerText === &#x27;&#x27;)&#123;</span><br><span class="line">        setTimeout(checkPv, 100)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            pv.innerText = parseInt(pv.innerText) + init_pv</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">script checkPv()</span><br><span class="line"></span><br><span class="line">script.</span><br><span class="line">    function checkUv()&#123; </span><br><span class="line">        var init_uv = parseInt(!&#123;theme.busuanzi.init_uv&#125;)</span><br><span class="line">        var uv = document.getElementById(&quot;busuanzi_value_site_uv&quot;)</span><br><span class="line">        if (uv.innerText === &#x27;&#x27;)&#123;</span><br><span class="line">        setTimeout(checkUv, 100)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            uv.innerText = parseInt(uv.innerText) + init_uv</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">script checkUv()</span><br></pre></td></tr></table></figure><br />&gt; 注意：要把原有代码全部注释。VSCode 批量注释/批量去注释快捷键 <code>Ctrl + /</code>。</p><p>这样，PV 统计量就出现在“浏览量”的位置上了。</p><h2 id="request-for-comments">Request for Comments</h2><p>有些说法是我查的，有些说法是我 AI 的，有些说法是我疑？悟！的。如有谬误，欢迎指正。</p>]]></content>
      
      
      <categories>
          
          <category> 本站 </category>
          
          <category> 更新 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网站源库开发日志</title>
      <link href="/2025/09/28/25-9-28-1_HexoDev-log/"/>
      <url>/2025/09/28/25-9-28-1_HexoDev-log/</url>
      
        <content type="html"><![CDATA[<blockquote><p>注意：<br />1. 这是网站源代码库的日志，不是网站部署库的日志。<br />2. 本日志关注网站功能的添加、删除、更改与问题修复，与文章内容的增减无关。</p></blockquote><h3 id="source-1.0.0">Source 1.0.0</h3><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><tbody><tr class="odd"><td>Date</td><td>Sept. 28, 2025</td></tr><tr class="even"><td>Description</td><td>The first formal version of <a href="/">remy-campanella.github.io</a>. Basic functions are ready and <code>hexo clean</code>ed.</td></tr></tbody></table><h3 id="source-1.0.1">Source 1.0.1</h3><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><tbody><tr class="odd"><td>Date</td><td>Sept. 28, 2025</td></tr><tr class="even"><td>Description</td><td>Fixed “the wrong user directed by”Follow me” button” problem.</td></tr></tbody></table><h3 id="source-1.1.0">Source 1.1.0</h3><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><tbody><tr class="odd"><td>Date</td><td>Sept. 30, 2025</td></tr><tr class="even"><td>Description</td><td>Added Busuanzi page view statistics.</td></tr><tr class="odd"><td>Article Report</td><td><a href="/2025/9/30/busuanzi/">【新功能特辑】不蒜子访问量统计</a></td></tr></tbody></table><h3 id="source-1.2.0">Source 1.2.0</h3><table><tbody><tr class="odd"><td>Date</td><td>Oct. 20, 2025</td></tr><tr class="even"><td>Description</td><td>Added LaTeX support and Image Lazyload.</td></tr></tbody></table><h3 id="source-1.2.1">Source 1.2.1</h3><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><tbody><tr class="odd"><td>Date</td><td>Oct. 21, 2025</td></tr><tr class="even"><td>Description</td><td>Replaced renders(<code>hexo-renderer-pandoc</code>, <code>hexo-math</code>, <code>hexo-filter-mathjax</code>) with <code>hexo-renderer-markdown-it</code> to fix LaTeX and table(when indentation) render error. Also added <code>hexo-lazyload-image</code> to speed up loading.</td></tr></tbody></table><h3 id="source-1.2.2">Source 1.2.2</h3><table><tbody><tr class="odd"><td>Date</td><td>Oct. 28, 2025</td></tr><tr class="even"><td>Description</td><td>Adjusted fonts used on the website.</td></tr></tbody></table><h3 id="source-1.2.3">Source 1.2.3</h3><table><tbody><tr class="odd"><td>Date</td><td>Oct. 29, 2025</td></tr><tr class="even"><td>Description</td><td>Fixed the render mistake of the font Simsun.</td></tr></tbody></table><h3 id="source-1.3.0">Source 1.3.0</h3><table><tbody><tr class="odd"><td>Date</td><td>Nov. 5, 2025</td></tr></tbody></table><h4 id="description">Description</h4><ol type="1"><li><p>Basically determined the font scheme for the website.<br /><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> url(<span class="string">&quot;https://fontsapi.zeoseven.com/285/main/result.css&quot;</span>); <span class="comment">/*&quot;Noto Serif CJK&quot;*/</span></span><br><span class="line"><span class="keyword">@import</span> url(<span class="string">&quot;https://fontsapi.zeoseven.com/447/main/result.css&quot;</span>); <span class="comment">/* &quot;Cascadia Code&quot; */</span></span><br><span class="line"><span class="keyword">@import</span> url(...); <span class="comment">/*a very long url for Nimbus Roman(ZSFT-603) and I don&#x27;t know why. */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span>, <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&quot;ZSFT-603&quot;</span>, <span class="string">&quot;Noto Serif CJK&quot;</span>, serif;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">code</span>, pre &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&quot;Cascadia Code&quot;</span>, <span class="string">&quot;Noto Serif CJK&quot;</span>, sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.comment</span> &#123; <span class="comment">/*, .c1, .cm, .c, .cdo*/</span></span><br><span class="line">    <span class="attribute">font-style</span>: italic;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">0.4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>Added Markdown Mermaid support.</p></li></ol><h3 id="source-1.4.0">Source 1.4.0</h3><table><tbody><tr class="odd"><td>Date</td><td>Nov. 19, 2025</td></tr><tr class="even"><td>Keywords</td><td>render, LaTeX</td></tr></tbody></table><h4 id="description-1">Description</h4><ol type="1"><li><p><strong>Fix</strong> Fixed serveral LaTeX rendering problems by introducing <a href="https://github.com/hexojs/hexo-renderer-pandoc"><code>hexo-renderer-pandoc</code></a>.</p></li><li><p><strong>Fix</strong> Disabled code font ligatures for better readability.<br /><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">code</span>, pre &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&quot;Cascadia Code&quot;</span>, <span class="string">&quot;Noto Serif CJK&quot;</span>, sans-serif;</span><br><span class="line">    <span class="attribute">font-variant-ligatures</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><strong>Add</strong> Added more markdown syntaxes by introduced more <code>hexo-renderer-markdown-it</code> subextensions:</p><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th>Name</th><th>Description</th></tr></thead><tbody><tr class="odd"><td><code>markdown-it-abbr</code></td><td>Added abbreviations using <code>*[]:</code></td></tr><tr class="even"><td><code>markdown-it-cjk-breaks</code></td><td>Suppresses linebreaks between east asian characters.</td></tr><tr class="odd"><td><code>markdown-it-deflist</code></td><td>Added definition list using <code>:</code>.</td></tr><tr class="even"><td><code>markdown-it-emoji</code></td><td>Render shortcuts into emojis <code>:)</code>.</td></tr><tr class="odd"><td><code>markdown-it-footnote</code></td><td>Added footnote and inline footnote using <code>[^ ]</code>.</td></tr><tr class="even"><td><code>markdown-it-ins</code></td><td>Added insert tag using <code>++++</code>.</td></tr><tr class="odd"><td><code>markdown-it-sub</code></td><td>Added subscript using <code>~~</code>.</td></tr><tr class="even"><td><code>markdown-it-sup</code></td><td>Added superscript using <code>^^</code>.</td></tr><tr class="odd"><td><code>markdown-it-mark</code></td><td>Added hignlight using <code>====</code></td></tr><tr class="even"><td><code>markdown-it-checkbox</code></td><td>Added checkbox using <code>[] [x]</code>.</td></tr><tr class="odd"><td><code>markdown-it-imsize</code></td><td>Added image size control using <code>![]( =axb)</code>.</td></tr><tr class="even"><td><code>markdown-it-expandable</code></td><td>Added <code>&lt;details&gt;</code> and <code>&lt;summary&gt;</code> syntax <code>++++++</code>.</td></tr><tr class="odd"><td><code>markdown-it-container</code></td><td>Create custom containers using custom functions.</td></tr></tbody></table><p>See details in <a href="https://github.com/orgs/markdown-it/repositories?type=all">all repositories of <code>markdown-it</code></a>.</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 本站 </category>
          
          <category> 更新 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> log </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/09/27/hello-world/"/>
      <url>/2025/09/27/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 本站 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
