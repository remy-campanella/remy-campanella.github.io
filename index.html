<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>remy-campanella.github.io - A Remy Campanella blog website on Github.</title><meta name="author" content="Remy Campanella"><meta name="copyright" content="Remy Campanella"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="A Remy Campanella blog website on Github.">
<meta property="og:type" content="website">
<meta property="og:title" content="remy-campanella.github.io">
<meta property="og:url" content="https://remy-campanella.github.io/index.html">
<meta property="og:site_name" content="remy-campanella.github.io">
<meta property="og:description" content="A Remy Campanella blog website on Github.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://remy-campanella.github.io/image/icon/Cover.jpg">
<meta property="article:author" content="Remy Campanella">
<meta property="article:tag" content="Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://remy-campanella.github.io/image/icon/Cover.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "WebSite",
  "name": "remy-campanella.github.io",
  "alternateName": [
    "A Remy Campanella blog website on Github.",
    "remy-campanella.github.io"
  ],
  "url": "https://remy-campanella.github.io/"
}</script><link rel="shortcut icon" href="/image/icon/icon.png"><link rel="canonical" href="https://remy-campanella.github.io/index.html"><link rel="preconnect" href="https://unpkg.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@7.0.1/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://unpkg.com/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'remy-campanella.github.io',
  isHighlightShrink: false,
  isToc: false,
  pageType: 'home'
}</script><link rel="stylesheet" href="/scripts/css/font.css"><!-- hexo injector head_end start -->
    <link rel="stylesheet" href="/css/gallery.css" media="print" onload="this.media='all'">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/image/icon/loading.gif" data-original="/image/icon/Cover.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about"><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/album"><span> 图库</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background-image: url(/image/background/ping_an_station.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/image/icon/loading.gif" data-original="/image/icon/icon.png" alt="Logo"><span class="site-name">remy-campanella.github.io</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about"><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/album"><span> 图库</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="site-info"><h1 id="site-title">remy-campanella.github.io</h1></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts nc" id="recent-posts"><div class="recent-post-items"><div class="recent-post-item"><div class="post_cover left"><a href="/2025/11/05/25-11-5-14-OpSys-sema-tube/" title="【操作系统原理】 Lecture 18 信号量与管程"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【操作系统原理】 Lecture 18 信号量与管程"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/11/05/25-11-5-14-OpSys-sema-tube/" title="【操作系统原理】 Lecture 18 信号量与管程">【操作系统原理】 Lecture 18 信号量与管程</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-05T01:36:42.000Z" title="发表于 2025-11-05 09:36:42">2025-11-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">操作系统原理</a></span></div><div class="content">一、信号量 信号量是由Dijkstra提出的更强大、更通用的同步原语。 1. 基本概念  定义：一个整型变量，只能通过两个标准的原子操作来访问：P操作（Proberen，测试/等待）和V操作（Verhogen，增加/信号）。 组成：  一个整型值 sem。 一个等待队列 q，用于存放阻塞的进程。    2. P/V操作实现 1234567891011121314Semaphore::P() &#123; // 等待/申请资源    sem--;    if (sem &lt; 0) &#123; // 资源不足        Add this thread t to q; // 将当前线程加入等待队列        block(p); // 阻塞当前线程    &#125;&#125;Semaphore::V() &#123; // 释放/提供资源    sem++;    if (sem &lt;= 0) &#123; // 有线程在等待        Remove a thread t from q; // 从等待队列中取出一个线程        wakeup(t); // ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2025/11/05/25-11-5-13-OpSys-sync-excl/" title="【操作系统原理】 Lecture 17 同步互斥"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【操作系统原理】 Lecture 17 同步互斥"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/11/05/25-11-5-13-OpSys-sync-excl/" title="【操作系统原理】 Lecture 17 同步互斥">【操作系统原理】 Lecture 17 同步互斥</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-05T01:36:28.000Z" title="发表于 2025-11-05 09:36:28">2025-11-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">操作系统原理</a></span></div><div class="content">一、背景与并发问题 1. 并发的好处与挑战  好处：并发执行可以充分利用多核CPU资源，提高系统吞吐量和响应速度。 挑战：并发进程共享资源时，如果协调不当，会导致竞态条件，即程序的最终结果依赖于进程执行的相对时序，从而产生不可预测的错误。  2. 竞态条件示例：PID分配 幻灯片中给出了一个经典的例子：两个进程A和B同时尝试获取下一个进程ID（next_pid）。  错误场景：  进程A加载next_pid（值为100）到寄存器。 发生上下文切换，进程B运行。 进程B加载next_pid（仍为100），将其分配给new_pid，然后递增next_pid为101并写回。 上下文切换回进程A。 进程A继续执行，将寄存器中的100分配给它的new_pid，然后递增next_pid为101并写回。   结果：两个进程获得了相同的PID（100），系统状态出错。 根本原因：load -&gt; store -&gt; inc -&gt; store这个序列不是一个原子操作，它在执行过程中被中断，导致了不一致的状态。   二、现实生活中的同步问题与临界区 1. 家庭采购协调问题 这个生动的例...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2025/11/05/25-11-5-12-OpSys-exp6-sche/" title="【操作系统原理】 Lecture 16 实验六 调度器"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【操作系统原理】 Lecture 16 实验六 调度器"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/11/05/25-11-5-12-OpSys-exp6-sche/" title="【操作系统原理】 Lecture 16 实验六 调度器">【操作系统原理】 Lecture 16 实验六 调度器</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-05T01:36:17.000Z" title="发表于 2025-11-05 09:36:17">2025-11-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">操作系统原理</a></span></div><div class="content">一、总体介绍与目标 1. 实验背景 在Lab5中，ucore已经能够创建和管理用户进程，但其调度机制非常原始：idle进程通过遍历进程池来寻找下一个可运行的进程，效率低下且缺乏公平性。Lab6的目标是重新设计并实现一个通用、高效的调度框架。 2. 实验目标  理解调度管理机制：掌握调度的完整流程，包括触发、选择、切换。 熟悉ucore调度框架：理解其模块化设计，特别是sched_class接口。 实现经典调度算法：  分析并理解Round Robin (RR) 算法的实现。 亲手实现Stride调度算法，这是一种公平的比例份额调度算法。     二、调度过程 调度过程是调度器工作的核心流程，可以分解为一系列标准化的步骤：  触发：某个事件发生，表明需要进行调度决策。例如：  时钟中断，当前进程时间片用完。 当前进程因I/O阻塞。 一个新进程被创建，变为就绪态。   入队：如果当前进程仍然是PROC_RUNNABLE状态，则需要将其重新放回就绪队列，等待下一次调度。 选取：调度算法的核心。从就绪队列中，根据特定策略（如RR、Stride）选择下一个要运行的进程。 出队：将选中的进程...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2025/11/05/25-11-5-10-OpSys-proc-sche/" title="【操作系统原理】 Lecture 15 处理机调度"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【操作系统原理】 Lecture 15 处理机调度"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/11/05/25-11-5-10-OpSys-proc-sche/" title="【操作系统原理】 Lecture 15 处理机调度">【操作系统原理】 Lecture 15 处理机调度</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-05T01:36:06.000Z" title="发表于 2025-11-05 09:36:06">2025-11-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">操作系统原理</a></span></div><div class="content">一、处理机调度概念 1. 调度的本质  CPU资源的时分复用：通过在多个进程之间快速切换CPU，使得宏观上看起来多个进程在同时运行，从而提高系统资源利用率。 调度时机：调度决策发生的时刻，主要包括：  时钟中断：当前进程的时间片用完。 I/O中断：一个进程因等待I/O而阻塞，另一个进程变为就绪。 系统调用：进程主动放弃CPU（如sleep）或创建新进程。 进程退出：当前进程执行完毕。    2. 调度策略  非抢占式调度：一旦CPU分配给一个进程，该进程会一直使用CPU，直到它自己主动释放（如阻塞或结束）。早期系统常用。 抢占式调度：操作系统可以强制剥夺当前进程的CPU使用权，并将其分配给另一个更重要或更紧急的进程。现代通用操作系统普遍采用。   二、调度准则 评价一个调度算法好坏的标准，通常从以下几个维度衡量：  CPU利用率：保持CPU尽可能忙碌。 吞吐量：单位时间内完成的进程数量。 周转时间：从进程提交到完成的总时间（包括等待和执行）。 等待时间：进程在就绪队列中等待的总时间。 响应时间：从提交请求到首次产生响应的时间，对交互式系统尤为重要。 公平性：确保每个进程都能获得合...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2025/11/05/25-11-5-8-OpSys-core-thr-man/" title="【操作系统原理】 Lecture 13 线程控制"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【操作系统原理】 Lecture 13 线程控制"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/11/05/25-11-5-8-OpSys-core-thr-man/" title="【操作系统原理】 Lecture 13 线程控制">【操作系统原理】 Lecture 13 线程控制</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-05T01:35:53.000Z" title="发表于 2025-11-05 09:35:53">2025-11-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">操作系统原理</a></span></div><div class="content">一、实验目标与概述 1. 核心目标 本实验的核心目标是让学生深入理解内核线程的整个生命周期管理，具体包括：  线程创建与执行：了解一个内核线程如何从无到有，并被调度执行。 线程状态管理：理解线程在Ready（就绪）、Running（运行）、Waiting（等待）等状态间的转换。 线程切换与调度：掌握CPU控制权如何从一个线程转移到另一个线程，这是多任务操作系统的基石。  2. 练习任务 实验通过三个循序渐进的练习来达成目标：  练习1：分配并初始化一个进程控制块（PCB），这是线程存在的基石。 练习2：为新创建的内核线程分配资源，主要是内核栈和执行上下文。 练习3：理解并完成进程切换，这是实现并发执行的关键。   二、关键数据结构 内核线程的管理依赖于两个核心数据结构：线程控制块和线程控制块链表。 1. 线程控制块 在ucore中，线程和进程使用统一的数据结构proc_struct来表示，可以称之为TCB（Thread Control Block）。它包含了管理一个线程所需的所有信息：  进程标识：pid（进程ID）、state（进程状态）、parent（父进程指针）、name（...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2025/11/05/25-11-5-9-OpSys-user-proc-man/" title="【操作系统原理】 Lecture 14 实验五 用户进程管理"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【操作系统原理】 Lecture 14 实验五 用户进程管理"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/11/05/25-11-5-9-OpSys-user-proc-man/" title="【操作系统原理】 Lecture 14 实验五 用户进程管理">【操作系统原理】 Lecture 14 实验五 用户进程管理</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-05T01:35:37.000Z" title="发表于 2025-11-05 09:35:37">2025-11-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">操作系统原理</a></span></div><div class="content">一、总体介绍 1. 实验目标 本实验的目标是构建一个完整的用户进程环境，让学生掌握从内核态到用户态的跨越，以及用户进程的生命周期管理。  创建第一个用户进程：理解如何“硬构造”出第一个用户进程，为其建立用户态的代码/数据段。 实现系统调用框架：理解用户态如何通过int 0x80中断陷入内核，执行系统调用，并返回用户态。 掌握进程管理机制：包括进程的创建（fork）、加载（exec）、复制和销毁。  2. 核心练习  加载并执行应用程序：将一个简单的hello程序（ELF格式）加载到内存并运行。 实现进程复制：完成fork系统调用，让父进程复制自己的内存空间给子进程。 分析系统调用与进程管理：深入理解do_execve和do_fork的实现细节。   二、进程的内存布局 理解用户进程的虚拟内存空间是本实验的基础。 1. 内核与进程虚拟内存布局对比 ucore为内核和用户进程设计了不同的虚拟内存布局：  内核空间（高地址）：  KERNBASE到KERNTOP：内核代码和数据，直接映射物理内存。 VPT：存放当前页目录和页表的虚拟地址，便于内核访问。   用户空间（低地址）：  US...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2025/11/05/25-11-5-7-OpSys-proc-ctrl/" title="【操作系统原理】 Lecture 12 进程控制"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【操作系统原理】 Lecture 12 进程控制"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/11/05/25-11-5-7-OpSys-proc-ctrl/" title="【操作系统原理】 Lecture 12 进程控制">【操作系统原理】 Lecture 12 进程控制</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-05T01:35:20.000Z" title="发表于 2025-11-05 09:35:20">2025-11-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">操作系统原理</a></span></div><div class="content">一、进程切换 进程切换是操作系统多任务处理的核心，指CPU从一个进程的运行切换到另一个进程运行的过程。 1. 核心概念：上下文切换  上下文：指一个进程运行时所需的全部信息，包括：  用户级上下文：代码、数据、用户栈、共享内存。 寄存器上下文：通用寄存器、程序计数器、栈指针等。 系统级上下文：进程控制块、内存管理信息（如页表基址）。   上下文切换：保存当前进程的上下文，加载新进程的上下文，并转移控制权的过程。  2. ucore中的实现  进程控制块：proc_struct（kern/process/proc.h）是ucore的PCB，包含了进程状态、内核栈、进程ID、内存管理结构指针（mm_struct）等所有信息。 内存地址空间：mm_struct管理进程的虚拟地址空间，包含指向页目录的指针和VMA链表。 进程队列：ucore使用链表组织不同状态的进程（如就绪队列、等待队列）。 切换流程：  触发切换：时钟中断、I/O中断或系统调用可能导致调度。 保存上下文：当前进程在内核态下，将其寄存器上下文保存到自己的内核栈中。 选择新进程：调度器从就绪队列中选择下一个要运行的进程。 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2025/11/05/25-11-5-6-OpSys-proc-thrd/" title="【操作系统原理】 Lecture 11 进程与线程"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【操作系统原理】 Lecture 11 进程与线程"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/11/05/25-11-5-6-OpSys-proc-thrd/" title="【操作系统原理】 Lecture 11 进程与线程">【操作系统原理】 Lecture 11 进程与线程</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-05T01:35:09.000Z" title="发表于 2025-11-05 09:35:09">2025-11-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">操作系统原理</a></span></div><div class="content">一、进程 1. 进程的定义与组成  定义：进程是一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。它是操作系统进行资源分配和调度的基本单位。 与程序的区别：    维度 程序 进程     性质 静态的代码和数据集合 动态的执行过程   生命周期 长期存在于磁盘 临时存在，有创建、执行、消亡的生命周期   并发性 自身无法并发 可以与其他进程并发执行   资源分配 不直接占用系统资源 是资源分配的基本单位（内存、文件等）     组成：进程包含了正在运行的一个程序的所有状态信息，包括：  代码段：程序的指令。 数据段：全局变量和静态变量。 堆栈段：函数调用栈、局部变量和动态分配的内存。 进程控制块：管理进程的核心数据结构。    2. 进程控制块  作用：PCB是操作系统管理控制进程运行所用的信息集合，是进程存在的唯一标志。 包含信息：  进程标识信息：如进程ID（PID）、父进程ID。 进程控制信息：进程状态、程序计数器、CPU寄存器值、内存管理信息（页表基址）、I/O状态信息等。   组织方式：  链表：将同一状态的PCB链接成一个队列（如就绪队列、等待队列）。 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2025/11/05/25-11-5-5-OpSys-exp3-virt-mem/" title="【操作系统原理】 Lecture 10 实验三 虚拟内存管理"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【操作系统原理】 Lecture 10 实验三 虚拟内存管理"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/11/05/25-11-5-5-OpSys-exp3-virt-mem/" title="【操作系统原理】 Lecture 10 实验三 虚拟内存管理">【操作系统原理】 Lecture 10 实验三 虚拟内存管理</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-05T01:34:47.000Z" title="发表于 2025-11-05 09:34:47">2025-11-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">操作系统原理</a></span></div><div class="content">一、实验目标：虚存管理 本实验的核心目标是构建一个完整的虚拟内存管理系统，具体包括：  基础：在Lab1（保护模式、中断）和Lab2（物理内存管理、页机制）之上。 核心机制：利用页表和中断异常处理机制。 关键实现：  Page Fault异常处理：当访问的虚拟页不在物理内存中时，能够捕获并处理该异常。 页替换算法：实现FIFO（先进先出）算法，在物理内存已满时选择一个页面换出到磁盘。 磁盘交互：实现对硬盘swap分区的读写，为换出的页面提供存储空间。   最终效果：为用户提供一个比实际物理内存“更大”的虚拟内存空间，使得程序可以运行在超过物理内存大小的地址空间中。   二、回顾历史：Lab1和Lab2 Lab3的实现高度依赖于前两个实验的成果：  Lab1：  建立了保护模式和段机制，为内存访问提供了硬件层面的保护。 建立了中断机制，这是处理Page Fault异常的基础。 实现了基本的屏幕输出功能，便于调试。   Lab2：  探测了可用的物理内存空间。 建立了基于连续物理内存的动态分配与释放机制（如伙伴系统）。 完成了页机制的建立，包括初始化页目录和页表，并开启了CR0寄存器...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2025/11/05/25-11-5-4-OpSys-page-swap/" title="【操作系统原理】 Lecture 9 页面置换算法"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【操作系统原理】 Lecture 9 页面置换算法"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/11/05/25-11-5-4-OpSys-page-swap/" title="【操作系统原理】 Lecture 9 页面置换算法">【操作系统原理】 Lecture 9 页面置换算法</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-05T01:34:18.000Z" title="发表于 2025-11-05 09:34:18">2025-11-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">操作系统原理</a></span></div><div class="content">一、页面置换算法的概念 1. 功能与目标  功能：当发生缺页异常且内存已满时，选择一个页面换出到外存，为新页面腾出空间。 目标：  减少缺页次数：尽可能置换未来最长时间不会被访问的页面。 降低系统开销：避免频繁的磁盘I/O操作。    2. 评价方法  缺页率：缺页次数占总访问次数的比例。 Belady现象：某些算法（如FIFO）在增加物理页帧时，缺页次数反而增多。  3. 算法分类    类型 特点 代表算法     局部置换算法 仅在当前进程的物理页帧中选择置换页面 OPT, FIFO, LRU, Clock, LFU   全局置换算法 从所有进程的物理页帧中选择置换页面，需考虑进程间的内存分配 工作集算法、缺页率算法     二、局部页面置换算法 1. 最优页面置换算法  原理：置换未来最长时间不会被访问的页面（理论最优，实际不可实现）。 示例：  访问序列：a, b, c, d, a, b, e, b, d, a, c。 置换时选择下次访问时间最晚的页面（如d下次访问时间为10）。    2. 先进先出算法  原理：置换最早进入内存的页面（队列实现）。 问题：存在Bela...</div></div></div></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/#content-inner">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/#content-inner">4</a><a class="extend next" rel="next" href="/page/2/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/image/icon/loading.gif" data-original="/image/icon/Cover.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Remy Campanella</div><div class="author-info-description">A Remy Campanella blog website on Github.</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/remy-campanella"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站介绍帖、自我介绍帖内容已移至“关于”页面，目录帖内容已移至“分类”页面。</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/11/05/25-11-5-14-OpSys-sema-tube/" title="【操作系统原理】 Lecture 18 信号量与管程"><img src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【操作系统原理】 Lecture 18 信号量与管程"/></a><div class="content"><a class="title" href="/2025/11/05/25-11-5-14-OpSys-sema-tube/" title="【操作系统原理】 Lecture 18 信号量与管程">【操作系统原理】 Lecture 18 信号量与管程</a><time datetime="2025-11-05T01:36:42.000Z" title="发表于 2025-11-05 09:36:42">2025-11-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/11/05/25-11-5-13-OpSys-sync-excl/" title="【操作系统原理】 Lecture 17 同步互斥"><img src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【操作系统原理】 Lecture 17 同步互斥"/></a><div class="content"><a class="title" href="/2025/11/05/25-11-5-13-OpSys-sync-excl/" title="【操作系统原理】 Lecture 17 同步互斥">【操作系统原理】 Lecture 17 同步互斥</a><time datetime="2025-11-05T01:36:28.000Z" title="发表于 2025-11-05 09:36:28">2025-11-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/11/05/25-11-5-12-OpSys-exp6-sche/" title="【操作系统原理】 Lecture 16 实验六 调度器"><img src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【操作系统原理】 Lecture 16 实验六 调度器"/></a><div class="content"><a class="title" href="/2025/11/05/25-11-5-12-OpSys-exp6-sche/" title="【操作系统原理】 Lecture 16 实验六 调度器">【操作系统原理】 Lecture 16 实验六 调度器</a><time datetime="2025-11-05T01:36:17.000Z" title="发表于 2025-11-05 09:36:17">2025-11-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/11/05/25-11-5-10-OpSys-proc-sche/" title="【操作系统原理】 Lecture 15 处理机调度"><img src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【操作系统原理】 Lecture 15 处理机调度"/></a><div class="content"><a class="title" href="/2025/11/05/25-11-5-10-OpSys-proc-sche/" title="【操作系统原理】 Lecture 15 处理机调度">【操作系统原理】 Lecture 15 处理机调度</a><time datetime="2025-11-05T01:36:06.000Z" title="发表于 2025-11-05 09:36:06">2025-11-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/11/05/25-11-5-8-OpSys-core-thr-man/" title="【操作系统原理】 Lecture 13 线程控制"><img src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【操作系统原理】 Lecture 13 线程控制"/></a><div class="content"><a class="title" href="/2025/11/05/25-11-5-8-OpSys-core-thr-man/" title="【操作系统原理】 Lecture 13 线程控制">【操作系统原理】 Lecture 13 线程控制</a><time datetime="2025-11-05T01:35:53.000Z" title="发表于 2025-11-05 09:35:53">2025-11-05</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            <a class="card-more-btn" href="/categories/" title="查看更多">
      <i class="fas fa-angle-right"></i></a>
          </div>
          <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/"><span class="card-category-list-name">技术</span><span class="card-category-list-count">28</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/"><span class="card-category-list-name">学习</span><span class="card-category-list-count">27</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/STATS-330-Application-and-Practice-of-Statistics/"><span class="card-category-list-name">STATS 330 Application and Practice of Statistics</span><span class="card-category-list-count">4</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"><span class="card-category-list-name">操作系统原理</span><span class="card-category-list-count">18</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"><span class="card-category-list-name">计算机组成原理</span><span class="card-category-list-count">3</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"><span class="card-category-list-name">软件工程</span><span class="card-category-list-count">2</span></a></li></ul></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/%E7%BD%91%E7%AB%99/"><span class="card-category-list-name">网站</span><span class="card-category-list-count">1</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/%E7%BD%91%E7%AB%99/Hexo/"><span class="card-category-list-name">Hexo</span><span class="card-category-list-count">1</span></a></li></ul></li></ul></li>
          </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/%E7%BD%91%E7%AB%99/" style="font-size: 1.18em; color: #999ca1">网站</a> <a href="/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6/" style="font-size: 1.34em; color: #99a3b0">统计学</a> <a href="/tags/Node-js/" style="font-size: 1.1em; color: #999">Node.js</a> <a href="/tags/Hexo/" style="font-size: 1.1em; color: #999">Hexo</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" style="font-size: 1.18em; color: #999ca1">软件工程</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="font-size: 1.5em; color: #99a9bf">学习笔记</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/" style="font-size: 1.1em; color: #999">前端工程</a> <a href="/tags/R-%E8%AF%AD%E8%A8%80/" style="font-size: 1.34em; color: #99a3b0">R 语言</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" style="font-size: 1.26em; color: #999fa8">计算机组成原理</a> <a href="/tags/%E5%A5%A5%E5%85%8B%E5%85%B0%E5%A4%A7%E5%AD%A6%E2%80%94%E8%A5%BF%E5%8D%97%E5%A4%A7%E5%AD%A6%E5%90%88%E4%BD%9C%E8%AF%BE%E7%A8%8B/" style="font-size: 1.34em; color: #99a3b0">奥克兰大学—西南大学合作课程</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 1.42em; color: #99a6b7">操作系统</a> <a href="/tags/log/" style="font-size: 1.18em; color: #999ca1">log</a> <a href="/tags/%E4%BB%8B%E7%BB%8D/" style="font-size: 1.26em; color: #999fa8">介绍</a> <a href="/tags/%E5%A4%96%E6%96%87/" style="font-size: 1.34em; color: #99a3b0">外文</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/" style="font-size: 1.34em; color: #99a3b0">数据科学</a></div></div><div class="card-widget card-archives">
    <div class="item-headline">
      <i class="fas fa-archive"></i>
      <span>归档</span>
      
    </div>
  
    <ul class="card-archive-list">
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/11/">
            <span class="card-archive-list-date">
              十一月 2025
            </span>
            <span class="card-archive-list-count">20</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/10/">
            <span class="card-archive-list-date">
              十月 2025
            </span>
            <span class="card-archive-list-count">9</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/09/">
            <span class="card-archive-list-date">
              九月 2025
            </span>
            <span class="card-archive-list-count">3</span>
          </a>
        </li>
      
    </ul>
  </div><script>function checkPv(){ 
    var init_pv = parseInt()
    var pv = document.getElementById("busuanzi_value_site_pv")
    if (pv.innerText === ''){
    setTimeout(checkPv, 100)
    } else {
        pv.innerText = parseInt(pv.innerText) + init_pv
    }
}</script><script>checkPv()</script><script>function checkUv(){ 
    var init_uv = parseInt()
    var uv = document.getElementById("busuanzi_value_site_uv")
    if (uv.innerText === ''){
    setTimeout(checkUv, 100)
    }else{
        uv.innerText = parseInt(uv.innerText) + init_uv
    }
}</script><script>checkUv()</script></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Remy Campanella</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.0</a></span></div><div class="footer_custom_text">源代码库版本 1.3.0</div></div><script type="text/javascript" id="maid-script" src="https://unpkg.com/mermaid@9.0.0/dist/mermaid.min.js"></script><script>if (window.mermaid) {
  var options = JSON.parse(document.getElementById('maid-script').getAttribute('mermaidoptioins'));
  mermaid.initialize(options);
}</script></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://unpkg.com/mermaid@11.11.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start -->
    <script src="/js/gallery.js" async></script>
<!-- hexo injector body_end end -->
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 2,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>