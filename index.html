<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>remy-campanella.github.io - A Remy Campanella blog website on Github.</title><meta name="author" content="Remy Campanella"><meta name="copyright" content="Remy Campanella"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="A Remy Campanella blog website on Github.">
<meta property="og:type" content="website">
<meta property="og:title" content="remy-campanella.github.io">
<meta property="og:url" content="https://remy-campanella.github.io/index.html">
<meta property="og:site_name" content="remy-campanella.github.io">
<meta property="og:description" content="A Remy Campanella blog website on Github.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://remy-campanella.github.io/image/icon/Cover.jpg">
<meta property="article:author" content="Remy Campanella">
<meta property="article:tag" content="Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://remy-campanella.github.io/image/icon/Cover.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "WebSite",
  "name": "remy-campanella.github.io",
  "alternateName": [
    "A Remy Campanella blog website on Github.",
    "remy-campanella.github.io"
  ],
  "url": "https://remy-campanella.github.io/"
}</script><link rel="shortcut icon" href="/image/icon/icon.png"><link rel="canonical" href="https://remy-campanella.github.io/index.html"><link rel="preconnect" href="https://unpkg.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@7.0.1/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://unpkg.com/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'remy-campanella.github.io',
  isHighlightShrink: false,
  isToc: false,
  pageType: 'home'
}</script><link rel="stylesheet" href="/scripts/css/font.css"><!-- hexo injector head_end start -->
    <link rel="stylesheet" href="/css/gallery.css" media="print" onload="this.media='all'">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/image/icon/loading.gif" data-original="/image/icon/Cover.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about"><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/album"><span> 图库</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background-image: url(/image/background/our_dream.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/image/icon/loading.gif" data-original="/image/icon/icon.png" alt="Logo"><span class="site-name">remy-campanella.github.io</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about"><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/album"><span> 图库</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="site-info"><h1 id="site-title">remy-campanella.github.io</h1></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts nc" id="recent-posts"><div class="recent-post-items"><div class="recent-post-item"><div class="post_cover left"><a href="/2025/12/22/25-11-5-15-COMPSCI220-11-graph-intro/" title="【COMPSCI 220】 Lecture 11 Graphs: A Brief Recap"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【COMPSCI 220】 Lecture 11 Graphs: A Brief Recap"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/12/22/25-11-5-15-COMPSCI220-11-graph-intro/" title="【COMPSCI 220】 Lecture 11 Graphs: A Brief Recap">【COMPSCI 220】 Lecture 11 Graphs: A Brief Recap</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-12-22T08:24:15.000Z" title="发表于 2025-12-22 16:24:15">2025-12-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/COMPSCI-220-Algorithms-and-Data-Structures/">COMPSCI 220 Algorithms and Data Structures</a></span></div><div class="content">Graphs  A graph is … A directed graph (or simply called a digraph) is …  Variants of Graphs  Multigraph. Weighted (di)graph.  Terminology  For undirected graph | Terminology | Definition | | — | — | | order of a graph | The number of nodes in \(G\), \(\|V\|\). | | adjacent, neighbours | If \(\\{u, v\\} \in E\), then \(u\) and \(v\) are adjacent or neighbours. | | endpoints of an edge | If \(\\{u, v\\} \in E\), then \(u\) and \(v\) are endpoints of edge \(\\{u, v\\}\). | | ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2025/12/22/25-11-3-3-COMPSCI220-10-quicksort/" title="【COMPSCI 220】 Lecture 10 Quick Sort"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【COMPSCI 220】 Lecture 10 Quick Sort"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/12/22/25-11-3-3-COMPSCI220-10-quicksort/" title="【COMPSCI 220】 Lecture 10 Quick Sort">【COMPSCI 220】 Lecture 10 Quick Sort</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-12-22T07:30:37.000Z" title="发表于 2025-12-22 15:30:37">2025-12-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/COMPSCI-220-Algorithms-and-Data-Structures/">COMPSCI 220 Algorithms and Data Structures</a></span></div><div class="content">Divide and Conquer Sorting Algorithms  Split the list into sublist Recursively sort each sublists. Combine the sorted lists.  Merge Sort does comparisons during combining, quick sort does comparisons during splitting. Quick Sort  Choose a pivot, then split(partition):  All elements in left sublist \(\leq\) pivot. All elements in right sublist \(&gt;\) pivot.  Recursively sort the left and right sublists. Combine.  Choose a pivot: Use the first entry as pivot element for...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2025/12/22/25-11-3-2-COMPSCI220-9-sort/" title="【COMPSCI 220】 Lecture 9 Analysis of Sorting Algorithms"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【COMPSCI 220】 Lecture 9 Analysis of Sorting Algorithms"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/12/22/25-11-3-2-COMPSCI220-9-sort/" title="【COMPSCI 220】 Lecture 9 Analysis of Sorting Algorithms">【COMPSCI 220】 Lecture 9 Analysis of Sorting Algorithms</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-12-22T06:32:24.000Z" title="发表于 2025-12-22 14:32:24">2025-12-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/COMPSCI-220-Algorithms-and-Data-Structures/">COMPSCI 220 Algorithms and Data Structures</a></span></div><div class="content">The Sorting Problem The sorting problem seeks to arrange a list (i.e., array or linked list) of keys (e.g., integers, strings) so that every adjacent pair of keys is in the designated order.  INPUT: An unsorted list of keys \(a = [0, \cdots, n - 1]\). OUTPUT: A sorted list containing the same list of elements \({a[0], \cdots, a[n - 1]}\).  Selection Sort  Split the input list into sorted and unsorted sublists. Sorted sublist is initially empty, and the unsorted sublist is the w...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2025/12/22/25-11-3-1-COMPSCI220-8-matrix/" title="【COMPSCI 220】 Lecture 8 Matrix Multiplication and Strassen’s Algorithm"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【COMPSCI 220】 Lecture 8 Matrix Multiplication and Strassen’s Algorithm"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/12/22/25-11-3-1-COMPSCI220-8-matrix/" title="【COMPSCI 220】 Lecture 8 Matrix Multiplication and Strassen’s Algorithm">【COMPSCI 220】 Lecture 8 Matrix Multiplication and Strassen’s Algorithm</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-12-22T05:16:46.000Z" title="发表于 2025-12-22 13:16:46">2025-12-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/COMPSCI-220-Algorithms-and-Data-Structures/">COMPSCI 220 Algorithms and Data Structures</a></span></div><div class="content">Standard Matrix Multiplication Algorithm Let  A=[a11a12a13a21a22a23a31a32a33],B=[b11b12b13b21b22b23b31b32b33] then \[ \mathbf{C} = \mathbf{A} \mathbf{B}, c_{ij} = \sum_{k = 1}^3 a_{ik}b_{kj} \] Complexity  Inner-most loop: Compute value for an entry. Middle loop: Compute values in a row. Outer-most loop: Compute values in all rows.  For \(n \times n\) matrix multiplication, time complexity \(\Theta(n^3)\). Divide and Conquer To multiply two \(n \times n\) matricies, we can fi...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2025/12/22/25-12-11-2-COMPSCI220-7-div-coq/" title="【COMPSCI 220】 Lecture 7 Divide and Conquer"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【COMPSCI 220】 Lecture 7 Divide and Conquer"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/12/22/25-12-11-2-COMPSCI220-7-div-coq/" title="【COMPSCI 220】 Lecture 7 Divide and Conquer">【COMPSCI 220】 Lecture 7 Divide and Conquer</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-12-22T05:09:08.000Z" title="发表于 2025-12-22 13:09:08">2025-12-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/COMPSCI-220-Algorithms-and-Data-Structures/">COMPSCI 220 Algorithms and Data Structures</a></span></div><div class="content">Divide-and-Conquer The divide-and-conquer technique solves a computational problem by dividing it into one or more subprograms of smaller size, conquering each of them by solving them recursively, and then combining their solutions into a solution for the original problem. 1234567if n &lt;= n0 then    directly solve problem without dividingelse    divide problem into a subproblems of size n/b each    for i ← 0 to a − 1 do        recursively solve the ith subproblem    combine the a solut...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2025/12/18/25-12-11-1-COMPSCI220-6-karastuba/" title="【COMPSCI 220】 Lecture 6 Karastuba's Algorithms"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【COMPSCI 220】 Lecture 6 Karastuba's Algorithms"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/12/18/25-12-11-1-COMPSCI220-6-karastuba/" title="【COMPSCI 220】 Lecture 6 Karastuba's Algorithms">【COMPSCI 220】 Lecture 6 Karastuba's Algorithms</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-12-18T07:50:16.000Z" title="发表于 2025-12-18 15:50:16">2025-12-18</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/COMPSCI-220-Algorithms-and-Data-Structures/">COMPSCI 220 Algorithms and Data Structures</a></span></div><div class="content">Multiplication Problem  INPUT: Two binary arrays \(x[0 \cdots n - 1]\), \(y[0 \cdots n - 1]\). OUTPUT: A binary array \(z[0 \cdots 2n - 1]\) represents \(xy\).  Long Multiplication: The “Grade School” Algorithm  Outer for-loop: repeats \(n\) times. Inner for-loop: repeats \(n\) times in worst case. Each iteration in the inner loop: Constant number of (single-bit) addition, modulo, division, and assignment  Therefore the running time of long multiplication is \(\Theta(n^2)\). K...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2025/12/11/25-11-19-2-COMPSCI220-5-more-iss/" title="【COMPSCI 220】 Lecture 5 More Issues on Algorithm Analysis"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【COMPSCI 220】 Lecture 5 More Issues on Algorithm Analysis"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/12/11/25-11-19-2-COMPSCI220-5-more-iss/" title="【COMPSCI 220】 Lecture 5 More Issues on Algorithm Analysis">【COMPSCI 220】 Lecture 5 More Issues on Algorithm Analysis</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-12-11T07:00:03.000Z" title="发表于 2025-12-11 15:00:03">2025-12-11</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/COMPSCI-220-Algorithms-and-Data-Structures/">COMPSCI 220 Algorithms and Data Structures</a></span></div><div class="content">Elementary Operations  Comparison | Operation | Theoretically | Actually | | — | — | — | | Adding two numbers | \(O(1)\) | \(\Theta(n)\) | | Multiplying two numbers | \(O(1)\) | \(O(n^2)\) (by hand) | Default Nevertheless, in this course, we will assume \(+\), \(\times\) are elementary by default(\(O(1)\)), unless stated otherwise.  Input Size  Definition The input size of an algorithm is the number of bits taken to store the input of the algorithm. Comaprison Let \(x\) be th...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2025/11/30/25-11-30-2-STATS330-5-devi-as-gof/" title="【STATS 330】 Handout 5 Deviance as A Goodness-of-fit Statistic"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【STATS 330】 Handout 5 Deviance as A Goodness-of-fit Statistic"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/11/30/25-11-30-2-STATS330-5-devi-as-gof/" title="【STATS 330】 Handout 5 Deviance as A Goodness-of-fit Statistic">【STATS 330】 Handout 5 Deviance as A Goodness-of-fit Statistic</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-30T13:01:14.000Z" title="发表于 2025-11-30 21:01:14">2025-11-30</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/STATS-330-Application-and-Practice-of-Statistics/">STATS 330 Application and Practice of Statistics</a></span></div><div class="content">Goodness-of-fit What is it actually? Deviance as A Goodness-of-fit Statistic A large deviance could indicate lack-of-fit. How large is too large? - If the model is correct, then, under certain conditions, the deviance comes from a \(\chi_{n - k}^2\), where \(n\) is the number of observations and \(k\) is the number of coefficients. - If it is plausible that the deviance could have come from this distribution, we have no evidence against the hypothesis that our model is correct. - I...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2025/11/30/25-11-30-1-STATS330-4-deviance/" title="【STATS 330】 Handout 4 Deviance"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【STATS 330】 Handout 4 Deviance"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/11/30/25-11-30-1-STATS330-4-deviance/" title="【STATS 330】 Handout 4 Deviance">【STATS 330】 Handout 4 Deviance</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-30T12:24:10.000Z" title="发表于 2025-11-30 20:24:10">2025-11-30</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/STATS-330-Application-and-Practice-of-Statistics/">STATS 330 Application and Practice of Statistics</a></span></div><div class="content">Goodness-of-fit “Goodness-of-fit” is a property that describes how well the data appear to fit the model assumptions. For a GLM, they are: - The observations are independent. - \(g(\boldsymbol{\theta}) = \boldsymbol{X \beta}\); after applying the link function, the parameter of interest is a linear combination of the explanatory terms. - Each response comes from the assumed distribution. Model Complexity, Residual Sum of Squares, and Likelihood Increasing a model’s complexity will ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2025/11/19/25-11-19-1-COMPSCI220-4-asym-not/" title="【COMPSCI 220】Lecture 4 Asymptotic notations"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【COMPSCI 220】Lecture 4 Asymptotic notations"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/11/19/25-11-19-1-COMPSCI220-4-asym-not/" title="【COMPSCI 220】Lecture 4 Asymptotic notations">【COMPSCI 220】Lecture 4 Asymptotic notations</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-19T01:13:20.000Z" title="发表于 2025-11-19 09:13:20">2025-11-19</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/COMPSCI-220-Algorithms-and-Data-Structures/">COMPSCI 220 Algorithms and Data Structures</a></span></div><div class="content">Dominance Relation The dominance relation of the frequently used classes: \[ 1 \prec \log n \prec (\log n)^2 \prec n \prec n \log n \prec n^2 \prec n^2 \log n \prec n^3 \prec \cdots \prec 2^n \prec n! \] Asymptotic Notation Define \[ f(n) \prec g(n) \Leftrightarrow f(n) = O(g(n)) \\\\ g(n) \prec f(n) \Leftrightarrow f(n) = \Omega(g(n)) \\\\ f(n) = O(g(n)), f(n) = \Omega(g(n)) \Leftrightarrow f(n) = \Theta(g(n)) \]    Notation Read     \(O\) asymptotic upper bound   \(\...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2025/11/19/25-11-4-3-COMSCI220-3-esti-run-time/" title="【COMPSCI 220】 Lecture 3 How to Estimate Running Time?"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【COMPSCI 220】 Lecture 3 How to Estimate Running Time?"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/11/19/25-11-4-3-COMSCI220-3-esti-run-time/" title="【COMPSCI 220】 Lecture 3 How to Estimate Running Time?">【COMPSCI 220】 Lecture 3 How to Estimate Running Time?</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-19T00:38:52.000Z" title="发表于 2025-11-19 08:38:52">2025-11-19</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/COMPSCI-220-Algorithms-and-Data-Structures/">COMPSCI 220 Algorithms and Data Structures</a></span></div><div class="content">Time Complexity and Loops  No loop. \(f(n) = c\). Rule 1: A fixed umber of statements take constant time. A single loop. \(f(n) = c(n - 1) + d\). Rule 2: The running time of a loop multiplies by the number of iterations. Exponential change of variables in loop. 1234i ← 1while i &lt; n do    i ← 2i    print i In general, the number of iterations is \(\lceil \lg n \rceil\), the smallest \(k\) such that \(2^k &gt; n\). Disjoint blocks. 123456for i ← 1 to n do    print i    j ← 1whil...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2025/11/19/25-11-4-2-COMPSCI220-2-run-time/" title="【COMPSCI 220】 Lecture 2 How to Measure Running Time?"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【COMPSCI 220】 Lecture 2 How to Measure Running Time?"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/11/19/25-11-4-2-COMPSCI220-2-run-time/" title="【COMPSCI 220】 Lecture 2 How to Measure Running Time?">【COMPSCI 220】 Lecture 2 How to Measure Running Time?</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-19T00:12:57.000Z" title="发表于 2025-11-19 08:12:57">2025-11-19</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/COMPSCI-220-Algorithms-and-Data-Structures/">COMPSCI 220 Algorithms and Data Structures</a></span></div><div class="content">Some Big Numbers Characterising an Algorithm  Domain of definition. Correctness. Resource use: running time and memory space.  Resource Use  Time: Execution time of an algorithm. Space: Memory space taken by an algorithm. Machine model: A models of computation is a collection of assumptions/idealisation about the type of machines and system environment that the algorithm is running on. Elementary operation: An elementary operation is the basic measuring unit of running time, an...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2025/11/19/25-11-4-1-COMPSCI220-1-intro/" title="【COMPSCI 220】 Lecture 1 What is a Algorithm and Why Analyse It?"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【COMPSCI 220】 Lecture 1 What is a Algorithm and Why Analyse It?"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/11/19/25-11-4-1-COMPSCI220-1-intro/" title="【COMPSCI 220】 Lecture 1 What is a Algorithm and Why Analyse It?">【COMPSCI 220】 Lecture 1 What is a Algorithm and Why Analyse It?</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-19T00:05:38.000Z" title="发表于 2025-11-19 08:05:38">2025-11-19</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/COMPSCI-220-Algorithms-and-Data-Structures/">COMPSCI 220 Algorithms and Data Structures</a></span></div><div class="content">Algorithms and Data Structures  Algorithms are sequences of clearly-stated rules that specify a step-by-step method for solving a given problem. Data structure are particular ways of storing and organising data in a computer system so that it can be used efficiently.  History Calculating Fibonacci Sequence Approximately, \(F(n) \approx 1.618^n\). Two Central Questions  What is an algorithm?  A list of unambiguous and detailed rules that specify successive operations. An id...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2025/11/05/25-11-5-14-OpSys-18-sema-tube/" title="【操作系统原理】 Lecture 18 信号量与管程"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【操作系统原理】 Lecture 18 信号量与管程"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/11/05/25-11-5-14-OpSys-18-sema-tube/" title="【操作系统原理】 Lecture 18 信号量与管程">【操作系统原理】 Lecture 18 信号量与管程</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-05T01:36:42.000Z" title="发表于 2025-11-05 09:36:42">2025-11-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">操作系统原理</a></span></div><div class="content">一、信号量 信号量是由 Dijkstra 提出的更强大、更通用的同步原语。 #### 1. 基本概念 - 定义：一个整型变量，只能通过两个标准的原子操作来访问：P操作（Proberen，测试/等待）和V操作（Verhogen，增加/信号）。 - 组成： - 一个整型值 sem。 - 一个等待队列 q，用于存放阻塞的进程。 #### 2. P/V操作实现 1234567891011121314Semaphore::P() &#123; // 等待/申请资源    sem--;    if (sem &lt; 0) &#123; // 资源不足        Add this thread t to q; // 将当前线程加入等待队列        block(p); // 阻塞当前线程    &#125;&#125;Semaphore::V() &#123; // 释放/提供资源    sem++;    if (sem &lt;= 0) &#123; // 有线程在等待        Remove a thread t from q; // 从等待队列中取出一个线程 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2025/11/05/25-11-5-13-OpSys-17-sync-excl/" title="【操作系统原理】 Lecture 17 同步互斥"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【操作系统原理】 Lecture 17 同步互斥"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/11/05/25-11-5-13-OpSys-17-sync-excl/" title="【操作系统原理】 Lecture 17 同步互斥">【操作系统原理】 Lecture 17 同步互斥</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-05T01:36:28.000Z" title="发表于 2025-11-05 09:36:28">2025-11-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">操作系统原理</a></span></div><div class="content">一、背景与并发问题 1. 并发的好处与挑战  好处：并发执行可以充分利用多核CPU资源，提高系统吞吐量和响应速度。 挑战：并发进程共享资源时，如果协调不当，会导致竞态条件，即程序的最终结果依赖于进程执行的相对时序，从而产生不可预测的错误。 #### 2. 竞态条件示例：PID分配 幻灯片中给出了一个经典的例子：两个进程A和B同时尝试获取下一个进程ID（next_pid）。 错误场景：  进程A加载next_pid（值为100）到寄存器。 发生上下文切换，进程B运行。 进程B加载next_pid（仍为100），将其分配给new_pid，然后递增next_pid为101并写回。 上下文切换回进程A。 进程A继续执行，将寄存器中的100分配给它的new_pid，然后递增next_pid为101并写回。  结果：两个进程获得了相同的PID（100），系统状态出错。 根本原因：load -&gt; store -&gt; inc -&gt; store这个序列不是一个原子操作，它在执行过程中被中断，导致了不一致的状态。 二、现实生活中的同步问题与临界区 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2025/11/05/25-11-5-12-OpSys-16-exp6-sche/" title="【操作系统原理】 Lecture 16 实验六 调度器"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【操作系统原理】 Lecture 16 实验六 调度器"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/11/05/25-11-5-12-OpSys-16-exp6-sche/" title="【操作系统原理】 Lecture 16 实验六 调度器">【操作系统原理】 Lecture 16 实验六 调度器</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-05T01:36:17.000Z" title="发表于 2025-11-05 09:36:17">2025-11-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">操作系统原理</a></span></div><div class="content">一、总体介绍与目标 1. 实验背景 在Lab5中，ucore已经能够创建和管理用户进程，但其调度机制非常原始：idle进程通过遍历进程池来寻找下一个可运行的进程，效率低下且缺乏公平性。Lab6的目标是重新设计并实现一个通用、高效的调度框架。 #### 2. 实验目标 - 理解调度管理机制：掌握调度的完整流程，包括触发、选择、切换。 - 熟悉ucore调度框架：理解其模块化设计，特别是sched_class接口。 - 实现经典调度算法： - 分析并理解Round Robin (RR) 算法的实现。 - 亲手实现Stride调度算法，这是一种公平的比例份额调度算法。 — ### 二、调度过程 调度过程是调度器工作的核心流程，可以分解为一系列标准化的步骤： 1. 触发：某个事件发生，表明需要进行调度决策。例如： - 时钟中断，当前进程时间片用完。 - 当前进程因I/O阻塞。 - 一个新进程被创建，变为就绪态。 2. 入队：如果当前进程仍然是PROC_RUNNABLE状态，则需要将其重新放回就绪队列，等待下一次调度。 3. 选取：调度算法的核心。从就绪队...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2025/11/05/25-11-5-10-OpSys-15-proc-sche/" title="【操作系统原理】 Lecture 15 处理机调度"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【操作系统原理】 Lecture 15 处理机调度"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/11/05/25-11-5-10-OpSys-15-proc-sche/" title="【操作系统原理】 Lecture 15 处理机调度">【操作系统原理】 Lecture 15 处理机调度</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-05T01:36:06.000Z" title="发表于 2025-11-05 09:36:06">2025-11-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">操作系统原理</a></span></div><div class="content">一、处理机调度概念 1. 调度的本质  CPU资源的时分复用：通过在多个进程之间快速切换CPU，使得宏观上看起来多个进程在同时运行，从而提高系统资源利用率。 调度时机：调度决策发生的时刻，主要包括：  时钟中断：当前进程的时间片用完。 I/O中断：一个进程因等待I/O而阻塞，另一个进程变为就绪。 系统调用：进程主动放弃CPU（如sleep）或创建新进程。 进程退出：当前进程执行完毕。 #### 2. 调度策略  非抢占式调度：一旦CPU分配给一个进程，该进程会一直使用CPU，直到它自己主动释放（如阻塞或结束）。早期系统常用。 抢占式调度：操作系统可以强制剥夺当前进程的CPU使用权，并将其分配给另一个更重要或更紧急的进程。现代通用操作系统普遍采用。 二、调度准则 评价一个调度算法好坏的标准，通常从以下几个维度衡量：   CPU利用率：保持CPU尽可能忙碌。 吞吐量：单位时间内完成的进程数量。 周转时间：从进程提交到完成的总时间（包括等待和执行）。 等待时间：进程在就绪队列中等待的总时间。 响应时间：从提交请求到首次产生响应的时间，对交互式...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2025/11/05/25-11-5-8-OpSys-13-core-thr-man/" title="【操作系统原理】 Lecture 13 线程控制"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【操作系统原理】 Lecture 13 线程控制"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/11/05/25-11-5-8-OpSys-13-core-thr-man/" title="【操作系统原理】 Lecture 13 线程控制">【操作系统原理】 Lecture 13 线程控制</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-05T01:35:53.000Z" title="发表于 2025-11-05 09:35:53">2025-11-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">操作系统原理</a></span></div><div class="content">一、实验目标与概述 1. 核心目标 本实验的核心目标是让学生深入理解内核线程的整个生命周期管理，具体包括： - 线程创建与执行：了解一个内核线程如何从无到有，并被调度执行。 - 线程状态管理：理解线程在Ready（就绪）、Running（运行）、Waiting（等待）等状态间的转换。 - 线程切换与调度：掌握CPU控制权如何从一个线程转移到另一个线程，这是多任务操作系统的基石。 #### 2. 练习任务 实验通过三个循序渐进的练习来达成目标： - 练习1：分配并初始化一个进程控制块（PCB），这是线程存在的基石。 - 练习2：为新创建的内核线程分配资源，主要是内核栈和执行上下文。 - 练习3：理解并完成进程切换，这是实现并发执行的关键。 — ### 二、关键数据结构 内核线程的管理依赖于两个核心数据结构：线程控制块和线程控制块链表。 #### 1. 线程控制块 在ucore中，线程和进程使用统一的数据结构proc_struct来表示，可以称之为TCB（Thread Control Block）。它包含了管理一个线程所需的所有信息： - 进程...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2025/11/05/25-11-5-9-OpSys-14-user-proc-man/" title="【操作系统原理】 Lecture 14 实验五 用户进程管理"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【操作系统原理】 Lecture 14 实验五 用户进程管理"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/11/05/25-11-5-9-OpSys-14-user-proc-man/" title="【操作系统原理】 Lecture 14 实验五 用户进程管理">【操作系统原理】 Lecture 14 实验五 用户进程管理</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-05T01:35:37.000Z" title="发表于 2025-11-05 09:35:37">2025-11-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">操作系统原理</a></span></div><div class="content">一、总体介绍 1. 实验目标 本实验的目标是构建一个完整的用户进程环境，让学生掌握从内核态到用户态的跨越，以及用户进程的生命周期管理。 - 创建第一个用户进程：理解如何“硬构造”出第一个用户进程，为其建立用户态的代码/数据段。 - 实现系统调用框架：理解用户态如何通过int 0x80中断陷入内核，执行系统调用，并返回用户态。 - 掌握进程管理机制：包括进程的创建（fork）、加载（exec）、复制和销毁。 #### 2. 核心练习 - 加载并执行应用程序：将一个简单的hello程序（ELF格式）加载到内存并运行。 - 实现进程复制：完成fork系统调用，让父进程复制自己的内存空间给子进程。 - 分析系统调用与进程管理：深入理解do_execve和do_fork的实现细节。 — ### 二、进程的内存布局 理解用户进程的虚拟内存空间是本实验的基础。 #### 1. 内核与进程虚拟内存布局对比 ucore为内核和用户进程设计了不同的虚拟内存布局： - 内核空间（高地址）： - KERNBASE到KERNTOP：内核代码和数据，直接映射物理内存。...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2025/11/05/25-11-5-7-OpSys-12-proc-ctrl/" title="【操作系统原理】 Lecture 12 进程控制"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【操作系统原理】 Lecture 12 进程控制"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/11/05/25-11-5-7-OpSys-12-proc-ctrl/" title="【操作系统原理】 Lecture 12 进程控制">【操作系统原理】 Lecture 12 进程控制</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-05T01:35:20.000Z" title="发表于 2025-11-05 09:35:20">2025-11-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">操作系统原理</a></span></div><div class="content">一、进程切换 进程切换是操作系统多任务处理的核心，指CPU从一个进程的运行切换到另一个进程运行的过程。 #### 1. 核心概念：上下文切换 - 上下文：指一个进程运行时所需的全部信息，包括： - 用户级上下文：代码、数据、用户栈、共享内存。 - 寄存器上下文：通用寄存器、程序计数器、栈指针等。 - 系统级上下文：进程控制块、内存管理信息（如页表基址）。 - 上下文切换：保存当前进程的上下文，加载新进程的上下文，并转移控制权的过程。 #### 2. ucore中的实现 - 进程控制块：proc_struct（kern/process/proc.h）是ucore的PCB，包含了进程状态、内核栈、进程ID、内存管理结构指针（mm_struct）等所有信息。 - 内存地址空间：mm_struct管理进程的虚拟地址空间，包含指向页目录的指针和VMA链表。 - 进程队列：ucore使用链表组织不同状态的进程（如就绪队列、等待队列）。 - 切换流程： 1. 触发切换：时钟中断、I/O中断或系统调用可能导致调度。 2. 保存上下文：当前进程在内核态下，将其寄存...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2025/11/05/25-11-5-6-OpSys-11-proc-thrd/" title="【操作系统原理】 Lecture 11 进程与线程"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【操作系统原理】 Lecture 11 进程与线程"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/11/05/25-11-5-6-OpSys-11-proc-thrd/" title="【操作系统原理】 Lecture 11 进程与线程">【操作系统原理】 Lecture 11 进程与线程</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-05T01:35:09.000Z" title="发表于 2025-11-05 09:35:09">2025-11-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">操作系统原理</a></span></div><div class="content">一、进程 1. 进程的定义与组成  定义：进程是一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。它是操作系统进行资源分配和调度的基本单位。 与程序的区别： | 维度 | 程序 | 进程 | |————–|————————————|———————————————-| | 性质 | 静态的代码和数据集合 | 动态的执行过程 | | 生命周期 | 长期存在于磁盘 | 临时存在，有创建、执行、消亡的生命周期 | | 并发性 | 自身无法并发 | 可以与其他进程并发执行 | | 资源分配 | 不直接占用系统资源 | 是资源分配的基本单位（内存、文件等） | 组成：进程包含了正在运行的一个程序的所有状态信息，包括：  代码段：程序的指令。 数据段：全局变量和静态变量。 堆栈段：函数调用栈、局部变量和动态分配的内存。 进程控制块：管理进程的核心数据结构。 #### 2. 进程控制块  作用：PCB是操作系统管理控制进程运行所用的信息集合，是进程存在的唯一标志。 包含信息：  进程标识信息：如进程ID（PID）、父进程ID。 进程控制...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2025/11/05/25-11-5-5-OpSys-10-exp3-virt-mem/" title="【操作系统原理】 Lecture 10 实验三 虚拟内存管理"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【操作系统原理】 Lecture 10 实验三 虚拟内存管理"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/11/05/25-11-5-5-OpSys-10-exp3-virt-mem/" title="【操作系统原理】 Lecture 10 实验三 虚拟内存管理">【操作系统原理】 Lecture 10 实验三 虚拟内存管理</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-05T01:34:47.000Z" title="发表于 2025-11-05 09:34:47">2025-11-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">操作系统原理</a></span></div><div class="content">一、实验目标：虚存管理 本实验的核心目标是构建一个完整的虚拟内存管理系统，具体包括： 1. 基础：在Lab1（保护模式、中断）和Lab2（物理内存管理、页机制）之上。 2. 核心机制：利用页表和中断异常处理机制。 3. 关键实现： * Page Fault异常处理：当访问的虚拟页不在物理内存中时，能够捕获并处理该异常。 * 页替换算法：实现FIFO（先进先出）算法，在物理内存已满时选择一个页面换出到磁盘。 * 磁盘交互：实现对硬盘swap分区的读写，为换出的页面提供存储空间。 4. 最终效果：为用户提供一个比实际物理内存“更大”的虚拟内存空间，使得程序可以运行在超过物理内存大小的地址空间中。 — ### 二、回顾历史：Lab1和Lab2 Lab3的实现高度依赖于前两个实验的成果： * Lab1： * 建立了保护模式和段机制，为内存访问提供了硬件层面的保护。 * 建立了中断机制，这是处理Page Fault异常的基础。 * 实现了基本的屏幕输出功能，便于调试。 * Lab2： * 探测了可用的物理内存空间。 * 建立了基于连续物理内存的动态分配与...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2025/11/05/25-11-5-4-OpSys-9-page-swap/" title="【操作系统原理】 Lecture 9 页面置换算法"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【操作系统原理】 Lecture 9 页面置换算法"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/11/05/25-11-5-4-OpSys-9-page-swap/" title="【操作系统原理】 Lecture 9 页面置换算法">【操作系统原理】 Lecture 9 页面置换算法</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-05T01:34:18.000Z" title="发表于 2025-11-05 09:34:18">2025-11-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">操作系统原理</a></span></div><div class="content">一、页面置换算法的概念 1. 功能与目标  功能：当发生缺页异常且内存已满时，选择一个页面换出到外存，为新页面腾出空间。  目标：  减少缺页次数：尽可能置换未来最长时间不会被访问的页面。  降低系统开销：避免频繁的磁盘I/O操作。   2. 评价方法  缺页率：缺页次数占总访问次数的比例。  Belady现象：某些算法（如FIFO）在增加物理页帧时，缺页次数反而增多。  3. 算法分类         类型 特点 代表算法     局部置换算法 仅在当前进程的物理页帧中选择置换页面 OPT, FIFO, LRU, Clock, LFU   全局置换算法 从所有进程的物理页帧中选择置换页面，需考虑进程间的内存分配 工作集算法、缺页率算法    二、局部页面置换算法 1. 最优页面置换算法  原理：置换未来最长时间不会被访问的页面（理论最优，实际不可实现）。  示例：  访问序列：a, b, c, d, a, b, e, b, d, a, c。  置换时选择下次访问时间最晚的...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2025/11/05/25-11-5-3-OpSys-8-virt-stor/" title="【操作系统原理】 Lecture 8 虚拟存储概念"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【操作系统原理】 Lecture 8 虚拟存储概念"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/11/05/25-11-5-3-OpSys-8-virt-stor/" title="【操作系统原理】 Lecture 8 虚拟存储概念">【操作系统原理】 Lecture 8 虚拟存储概念</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-05T01:33:59.000Z" title="发表于 2025-11-05 09:33:59">2025-11-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">操作系统原理</a></span></div><div class="content">一、虚拟存储的需求背景 1. 存储需求增长  程序规模 vs 存储容量：  应用程序（如大型游戏）规模增长速度远超物理内存容量。  核心矛盾：需要运行比物理内存更大的程序。   2. 存储层次结构  金字塔模型：  顶层：CPU寄存器（最快，容量最小）。  中层：高速缓存、主存（RAM）。  底层：磁盘（最慢，容量最大）。   操作系统抽象：  通过虚拟存储技术，将外存（磁盘）扩展为内存的延伸。   二、核心技术：覆盖与交换 1. 覆盖技术  原理：  按程序逻辑划分模块，将不会同时执行的模块共享同一内存区域。   示例：  模块A（20K）独立占用。  模块B/E/F（50K）共享区域，模块C/D（30K）共享区域。  总内存需求：100K（原需150K）。   不足：  需程序员手动划分模块，增加编程复杂度。  无法自动适应动态内存需求。   2. 交换技术  原理：  将内存中暂时不运行的进程整体换出到外存，释放内存空间。   流程：  换出：选择等待进程（...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2025/11/05/25-11-5-2-OpSys-7-exp2-phy-mem-man/" title="【操作系统原理】 Lecture 7 实验二 物理内存管理"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【操作系统原理】 Lecture 7 实验二 物理内存管理"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/11/05/25-11-5-2-OpSys-7-exp2-phy-mem-man/" title="【操作系统原理】 Lecture 7 实验二 物理内存管理">【操作系统原理】 Lecture 7 实验二 物理内存管理</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-05T01:33:46.000Z" title="发表于 2025-11-05 09:33:46">2025-11-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">操作系统原理</a></span></div><div class="content">一、x86特权级机制 1. 特权级简介  保护环（Protection Rings）：  Ring 0：内核态，最高特权，可执行所有指令（如lgdt）。  Ring 3：用户态，最低特权，受限访问硬件资源。  Ring 1/2：设备驱动（Linux/ucore未使用）。   特权级检查时机：  访问数据段、页表、中断服务例程（ISR）时，CPU自动验证权限。  失败后果：触发通用保护异常（General Protection Fault）。 #### 2. 特权级相关寄存器与描述符  段选择子（Segment Selector）：  RPL（Requested Privilege Level）：请求者特权级（2位）。  TI（Table Indicator）：指示使用GDT（0）或LDT（1）。  索引：在描述符表中的位置。   段描述符（Segment Descriptor）：  DPL（Descriptor Privilege Level）：描述符特权级（2位）。  Base Address：段基址，...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2025/11/05/25-11-5-1-OpSys-6-phy-mem-man-discon/" title="【操作系统原理】 Lecture 6 物理内存管理：非连续内存分配"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【操作系统原理】 Lecture 6 物理内存管理：非连续内存分配"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/11/05/25-11-5-1-OpSys-6-phy-mem-man-discon/" title="【操作系统原理】 Lecture 6 物理内存管理：非连续内存分配">【操作系统原理】 Lecture 6 物理内存管理：非连续内存分配</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-05T01:33:33.000Z" title="发表于 2025-11-05 09:33:33">2025-11-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">操作系统原理</a></span></div><div class="content">一、非连续内存分配的需求背景 设计目标  解决连续分配的缺陷：  外部碎片：内存中存在大量不连续的小空闲块，难以利用。  内部碎片：分配的块大于实际需求（如伙伴系统）。   支持灵活的内存布局：  允许程序代码、数据、堆栈等分散在物理内存的不同位置。  便于实现内存共享和保护（如共享库）。   实现方式  段式管理：按逻辑模块划分内存（如代码段、数据段）。  页式管理：将内存划分为固定大小的页，按需分配。  段页式管理：结合段式逻辑划分与页式物理分配。  二、段式存储管理 段地址空间  逻辑结构：  进程地址空间由多个段组成，如：  主代码段、子模块代码段、堆栈段、堆数据段。   二维地址：(段号, 段内偏移)。   非连续性：  各段可独立加载到物理内存的任意位置，无需连续。 ### 段访问机制  硬件实现：  逻辑地址：(段选择子, 偏移量)。  段表（GDT/LDT）：存储段基址和段限长。  地址转换：  物理地址 = 段基址 + 偏移量。  检查偏移量是否超过段限长，...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2025/11/05/25-11-3-8-OpSys-5-phy-mem-con/" title="【操作系统原理】 Lecture 5 物理内存管理：连续内存分配"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【操作系统原理】 Lecture 5 物理内存管理：连续内存分配"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/11/05/25-11-3-8-OpSys-5-phy-mem-con/" title="【操作系统原理】 Lecture 5 物理内存管理：连续内存分配">【操作系统原理】 Lecture 5 物理内存管理：连续内存分配</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-05T01:32:56.000Z" title="发表于 2025-11-05 09:32:56">2025-11-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">操作系统原理</a></span></div><div class="content">计算机体系结构与内存层次 计算机体系结构  基础：基于Intel® 64和IA-32架构，参考官方手册（Intel® 64 and IA-32 Architectures Software Developer Manuals）。  核心组件：    CPU：执行指令，生成逻辑地址。  MMU（内存管理单元）：将逻辑地址转换为物理地址，支持分段和分页。  总线：连接CPU、内存和外设。 ### 内存层次   结构：    高速缓存（Cache）：速度快，容量小，减少CPU访问内存延迟。  主存（RAM）：存放运行中的程序和数据。  外存（磁盘）：持久化存储，用于交换分区（Swapping）。    性能问题：    高速缓存未命中：需从主存加载数据，延迟增加。  缺页（Page Fault）：虚拟内存机制中，访问未加载的页需从磁盘读取。  操作系统的内存管理方式  操作系统中的内存管理方式  重定位（relocation） 分段（segmentation） 分页（paging） 虚拟存储（...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2025/11/05/25-11-3-7-OpSys-4-exp1-bootloader/" title="【操作系统原理】 Lecture 4 实验一 Bootloader 启动 ucore OS"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【操作系统原理】 Lecture 4 实验一 Bootloader 启动 ucore OS"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/11/05/25-11-3-7-OpSys-4-exp1-bootloader/" title="【操作系统原理】 Lecture 4 实验一 Bootloader 启动 ucore OS">【操作系统原理】 Lecture 4 实验一 Bootloader 启动 ucore OS</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-05T01:32:22.000Z" title="发表于 2025-11-05 09:32:22">2025-11-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">操作系统原理</a></span></div><div class="content">一、x86启动顺序 启动流程  BIOS阶段    初始状态：CS=0xF000, EIP=0xFFF0，物理地址为0xFFFFFFF0（BIOS EPROM位置）。  第一条指令：长跳转（JMP）到BIOS代码区，更新CS:EIP。    加载Bootloader    BIOS将存储设备（硬盘/USB）的主引导扇区（MBR，512字节）加载到内存0x7C00，并跳转执行。    Bootloader任务    使能保护模式：设置CR0寄存器的PE位（Bit 0）。  加载内核：从硬盘读取ELF格式的ucore内核到内存固定位置。  跳转执行：跳转到ucore入口点，移交控制权。 ### 实模式与保护模式   实模式（历史背景）    寻址方式：段基址:偏移量（如CS:IP），物理地址 = 段基址*16 + 偏移量。  限制：20位地址总线，最大1MB空间（0x00000~0xFFFFF），无保护机制。  中断处理：中断向量表（IVT）位于内存低地址，INT n通过N*4获取ISR地址。...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2025/11/05/25-11-3-6-OpSys-3-interrupt/" title="【操作系统原理】 Lecture 3 系统启动、中断、异常和系统调用"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【操作系统原理】 Lecture 3 系统启动、中断、异常和系统调用"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/11/05/25-11-3-6-OpSys-3-interrupt/" title="【操作系统原理】 Lecture 3 系统启动、中断、异常和系统调用">【操作系统原理】 Lecture 3 系统启动、中断、异常和系统调用</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-05T01:30:59.000Z" title="发表于 2025-11-05 09:30:59">2025-11-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">操作系统原理</a></span></div><div class="content">一、计算机启动流程  启动前的硬件状态  CPU状态：PC 指向固定地址（如 x86 的 0xFFFF0），处于特权态（实模式），地址空间有限（x86 为 1 MB）。  内存布局：BIOS 固件位于高地址区域，低地址为加载程序预留空间。  初始化：硬件自检（POST）、内存控制器初始化、寄存器复位。   启动阶段  BIOS阶段：  执行自检程序，初始化硬件（如键盘、串口）。  加载磁盘引导扇区（512 字节）到内存 0x7C00，跳转执行。   Bootloader阶段：  加载操作系统内核到内存，跳转至 OS 入口。   OS初始化：  初始化数据结构、外设驱动，建立中断处理机制。    启动规范  传统BIOS：MBR（主引导记录）→ 分区引导扇区 → OS 加载。  UEFI：更现代的固件接口，支持安全启动和大容量磁盘。   二、中断、异常与系统调用  定义与分类 | 类型 | 触发方式 | 示例（x86） | | — | — | — | | 中断 | 外部设备信号（如键盘、时...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2025/11/05/25-11-3-5-OpSys-2-exp0-env/" title="【操作系统原理】 Lecture 2 实验零 操作实验系统实验环境准备"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【操作系统原理】 Lecture 2 实验零 操作实验系统实验环境准备"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/11/05/25-11-3-5-OpSys-2-exp0-env/" title="【操作系统原理】 Lecture 2 实验零 操作实验系统实验环境准备">【操作系统原理】 Lecture 2 实验零 操作实验系统实验环境准备</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-05T01:30:35.000Z" title="发表于 2025-11-05 09:30:35">2025-11-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">操作系统原理</a></span></div><div class="content">一、了解操作系统（OS）  核心概念  特权机制：CPU 通过特权级（如 CPL = 0 为最高特权）保护系统安全，特权指令（如LIDT、MOV CRn）只能在特权态执行，否则触发异常。  中断与异常管理：包括外设中断、陷阱中断（如系统调用）和故障中断（如缺页异常）。  内存管理：  分段（Segmentation）和分页（Paging）机制，实现虚拟内存（Virtual Memory）。  硬件支持：TLB（快表）、MMU（内存管理单元）。    OS设计目标  高效管理硬件资源（CPU、内存、外设）。  提供系统调用接口，实现用户态与内核态切换。   二、了解硬件  计算机体系结构  图灵机模型：有限状态机，通过读写符号和状态转换实现计算。  冯·诺依曼架构：  组成：CPU（寄存器、执行单元）、内存、磁盘、键盘、显示器等。  特点：存储程序，指令与数据共享内存。    x86硬件特性  特权指令：仅当CPL=0时可执行，否则触发通用保护异常（如LGDT、STI）。  关键组件：  BI...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2025/11/05/25-11-3-4-OpSys-1-intro/" title="【操作系统原理】 Lecture 1 课程概述"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【操作系统原理】 Lecture 1 课程概述"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/11/05/25-11-3-4-OpSys-1-intro/" title="【操作系统原理】 Lecture 1 课程概述">【操作系统原理】 Lecture 1 课程概述</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-05T01:30:12.000Z" title="发表于 2025-11-05 09:30:12">2025-11-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">操作系统原理</a></span></div><div class="content">一、课程目标与意义  学习目的  掌握操作系统（OS）的基本原理与实现技术。  通过开发小型OS实践核心阶段（如中断处理、内存管理）。  深化对计算机系统的整体理解，提升知识应用能力。   OS的重要性  计算机科学的基石，连接硬件、软件与应用的核心支撑。  贯穿程序语言、编译、体系结构等领域，影响专业素质。   二、课程结构与内容  核心教学内容  OS结构、中断与系统调用、内存管理、进程/线程、调度、同步互斥、文件系统、I/O子系统。   实验与实践  实验序列：环境准备→系统启动→物理/虚拟内存管理→内核线程→用户进程→调度→同步→文件系统。  课程设计：基于RISC-V的ucore OS内核开发。   参考教材  《Operating System Concepts》（恐龙书）  《Operating Systems: Three Easy Pieces》（OSTEP）   三、操作系统核心概念  定义与地位  OS是管理硬件资源、提供用户接口的系统软件，位于硬件与应用之间（承上启下）。...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2025/11/02/25-11-2-1-STATS330-3-param-esti/" title="【STATS 330】 Handout 3 Parameter Estimation for Generalised Linear Models"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【STATS 330】 Handout 3 Parameter Estimation for Generalised Linear Models"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/11/02/25-11-2-1-STATS330-3-param-esti/" title="【STATS 330】 Handout 3 Parameter Estimation for Generalised Linear Models">【STATS 330】 Handout 3 Parameter Estimation for Generalised Linear Models</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-02T12:23:36.000Z" title="发表于 2025-11-02 20:23:36">2025-11-02</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/STATS-330-Application-and-Practice-of-Statistics/">STATS 330 Application and Practice of Statistics</a></span></div><div class="content">Parameter Estimation Parameter estimation involves determining values for a model’s coefficients (or “parameters”) that “best” fit the data at hand.  For linear regression models, we can use the sum of the squared residuals(\(RSS\)). For generalised linear models, we can use the likelihood function(\(L(p;x)\)).  Least Squares Estimation The residual sum of squares is given by \[ RSS = \sum_{i = 1}^n (y_i - \hat{\mu_i})^2 \] The lower the \(RSS\) is, the “better” the candidate s...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2025/11/02/25-10-31-1-STATS330-2-explanatory/" title="【STATS 330】 Handout 2 Explanatory Terms and Interpretation"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【STATS 330】 Handout 2 Explanatory Terms and Interpretation"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/11/02/25-10-31-1-STATS330-2-explanatory/" title="【STATS 330】 Handout 2 Explanatory Terms and Interpretation">【STATS 330】 Handout 2 Explanatory Terms and Interpretation</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-11-02T08:32:07.000Z" title="发表于 2025-11-02 16:32:07">2025-11-02</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/STATS-330-Application-and-Practice-of-Statistics/">STATS 330 Application and Practice of Statistics</a></span></div><div class="content">Intepretation: Numeric Explanatory Variables Linear Regression \[ y_i = \beta_0 + \beta_1 x_i + \epsilon_i \\\\ \epsilon \sim {\rm iid \ Normal}(0, \sigma_i^2) \]  When \(x\) is zero, the expected value of the response is \(\beta_0\). For every one-unit increase in \(x\), the expected value of the response increases by \(\beta_1\).  Poisson Regression \[ \log(\mu_i) = \beta_0 + \beta_1 x_i \\\\ Y_i \sim {\rm Poisson}(\mu_i) \]  When \(x\) is zero, the expected value of the...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2025/10/31/25-10-16-1-STATS330-1-synthesis-glm/" title="【STATS 330】 Handout 1 A Synthesis of Generalised Linear Models"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【STATS 330】 Handout 1 A Synthesis of Generalised Linear Models"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/10/31/25-10-16-1-STATS330-1-synthesis-glm/" title="【STATS 330】 Handout 1 A Synthesis of Generalised Linear Models">【STATS 330】 Handout 1 A Synthesis of Generalised Linear Models</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-31T12:57:23.000Z" title="发表于 2025-10-31 20:57:23">2025-10-31</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/STATS-330-Application-and-Practice-of-Statistics/">STATS 330 Application and Practice of Statistics</a></span></div><div class="content">Linear Regression Simple linear regression model is: \[ y_i = \beta_0 + \beta_1 x_i + \epsilon_i \\\\ \epsilon_i \sim {\rm iid \ Normal(0, \sigma^2)} \] Poisson Linear Regression Macrorhabdus Ornithogaster Chicken Analysis Textbook Page 23:     Macrorhabdus Ornithogaster Chicken Data    Data Suitable for Using Poisson Distribution The Poisson distribution better reflects the nature of the response: - It is a discrete distribution - It is right skewed (but almost symmetric...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2025/10/29/25-10-29-1-HexoBui-intro/" title="【Hexo 折腾手册】 （零）准备"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【Hexo 折腾手册】 （零）准备"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/10/29/25-10-29-1-HexoBui-intro/" title="【Hexo 折腾手册】 （零）准备">【Hexo 折腾手册】 （零）准备</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-29T14:55:34.000Z" title="发表于 2025-10-29 22:55:34">2025-10-29</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E7%BD%91%E7%AB%99/">网站</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E7%BD%91%E7%AB%99/Hexo/">Hexo</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E7%BD%91%E7%AB%99/Hexo/Hexo-%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%85%8D%E7%BD%AE/">Hexo 网站搭建与配置</a></span></div><div class="content">一、什么是博客网站？ 博客是一种通常由个人维护、按时间顺序发布文章的在线平台，它既是作者表达观点、分享知识与记录生活的数字空间，也是与读者进行互动交流的社区。其内容包罗万象，从技术、旅行到美食、时事无所不包，凭借其个性化、即时性和互动性的特点，博客不仅塑造了无数网络意见领袖，也极大地丰富了互联网的内容生态，成为信息传播与思想碰撞的重要载体。一般来讲，仅用静态网站就可完成博客网站的本职工作。 二、什么是静态网站？ 静态网站是由预先构建好的 HTML、CSS 和 JavaScript 等固定文件组成的网页，其内容对所有访问者都完全相同，不会根据用户交互或时间而改变。由于服务器只需直接发送这些现成文件，无需执行复杂的数据库查询或服务器端脚本，静态网站因此具有加载速度快、安全性高、托管成本低且易于维护的优点，非常适合用于作品集、文档站点、企业宣传页等内容更新不频繁的场景。由于服务器端只管发送文件，不做计算，因此使用纯前端技术即可实现。 三、什么是前端技术？ 前端技术是指用于构建用户在浏览器中直接交互的网页界面的一系列技术和工具，核心包括HTML（结构）、CSS（样式）和Jav...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2025/10/21/25-10-21-1-HexoDev-test-post/" title="网站渲染测试"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="网站渲染测试"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/10/21/25-10-21-1-HexoDev-test-post/" title="网站渲染测试">网站渲染测试</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-21T02:18:08.000Z" title="发表于 2025-10-21 10:18:08">2025-10-21</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%9C%AC%E7%AB%99/">本站</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%9C%AC%E7%AB%99/%E6%9B%B4%E6%96%B0/">更新</a></span></div><div class="content">这是一个用于测试网站渲染功能的帖子，如果发现异常请及时报告作者哦（如果是可选语法或标明我不常用就不用了哈）！ 一、Markdown 标题语法 1. 标准语法 一级标题  使用 HTML 标签的一级标题  二级标题  使用 HTML 标签的二级标题  三级标题  使用 HTML 标签的三级标题  四级标题  使用 HTML 标签的四级标题  五级标题  使用 HTML 标签的五级标题  六级标题  使用 HTML 标签的六级标题  2. 可选语法 一级标题 二级标题 二、Markdown 段落语法 （正文）逸一时，误一世。逸久逸久罢已龄。  （HTML 正文）逸一时，误一世。逸久逸久罢已龄。  三、Markdown 换行语法 第一段 第二段 使用行尾两空格换行 使用行尾两空格换行 使用 HTML 标签换行使用 HTML 标签换行 四、Markdown 强调语法 不好，我被星号加粗了！ 不好，我被 下划线加粗 了！（我不常用） 不好，我被HTML 加粗了！（我不常用） 不好，我被星号加斜体了！ ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2025/10/20/25-10-16-1-STATS330-intro/" title="【STATS 330】 Introduction"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【STATS 330】 Introduction"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/10/20/25-10-16-1-STATS330-intro/" title="【STATS 330】 Introduction">【STATS 330】 Introduction</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-20T07:54:53.000Z" title="发表于 2025-10-20 15:54:53">2025-10-20</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/STATS-330-Application-and-Practice-of-Statistics/">STATS 330 Application and Practice of Statistics</a></span></div><div class="content">This course is about statistical modelling. We will expand on the generalised linear model (GLM) encountered in STATS 201/8. It comprises four parts:  Generalised linear models Simulation and bootstrapping Regression models for prediction Regression models for explanation  This course provides a versatile statistical toolbox that is useful in a range of fields, including almost all subjects in business and economics, along with experimental or social science. Course Link Prof. J...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2025/10/15/25-10-15-2-SoftEng-2-feasibility/" title="【软件工程学习】 第二章 可行性研究"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【软件工程学习】 第二章 可行性研究"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/10/15/25-10-15-2-SoftEng-2-feasibility/" title="【软件工程学习】 第二章 可行性研究">【软件工程学习】 第二章 可行性研究</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-15T13:42:12.000Z" title="发表于 2025-10-15 21:42:12">2025-10-15</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/">软件工程</a></span></div><div class="content">2.1 可行性研究的任务  任务 并非任何问题都有简单明显的解决办法。如果问题没有可行的解，那么花费在这项工程上的任何时间、人力、软硬件资源和经费，都是无谓的浪费。可行性研究的目的，就是用最小的代价在尽可能短的时间内确定问题是否能够解决。 分析过程  分析和澄清问题定义。 导出系统逻辑模型。 探索若干种可选的主要解法。   2.2 可行性研究过程        步骤      复查系统规模和目标 实质上是为了确保分析员正在解决的问题确实是要求他解决的问题。   研究目前正在使用的系统 新系统必须要完成旧系统的基本功能；新系统必须要解决旧系统的问题。   导出新系统的高层逻辑模型 参考现有系统的逻辑模型，设想目标系统的逻辑模型，最后根据目标系统的逻辑模型建造新的物理系统。   进一步定义问题 在之前的基础上再次定义问题，构成循环，直到提出的逻辑模型完全符合系统目标。   导出和评价供选择的解法 为每个解法考虑操作、经济方面的可行性，制定实现进度表。   推荐行动方针    草拟开发计划...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2025/10/15/25-10-15-1-SoftEng-1-intro/" title="【软件工程学习】 第一章 软件工程概述"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【软件工程学习】 第一章 软件工程概述"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/10/15/25-10-15-1-SoftEng-1-intro/" title="【软件工程学习】 第一章 软件工程概述">【软件工程学习】 第一章 软件工程概述</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-15T13:41:48.000Z" title="发表于 2025-10-15 21:41:48">2025-10-15</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/">软件工程</a></span></div><div class="content">一、软件工程的价值与应用场景  实际用途：  国家考试（如软考）、工作面试（如亚麻面试）、毕业设计、读研。 参与需求分析、撰写需求/设计报告、招标书/投标书、项目申请书。 开发原型（需掌握原型工具）、开发软件（需学习开发框架）。 绘制模型图/流程图、AI开发APP等。  工作场景：  文档撰写、模型设计、原型开发、前后端分离开发、系统设计等。   二、软件工程学科与教材分析  经典教材：  《Software Engineering: A Practitioner’s Approach》（2020年）：涵盖软件过程、建模、质量、项目管理等。 《软件工程导论》（2013年）：传统生命周期与面向对象方法。 《面向对象软件工程：敏捷统一方法》（2014/2023年）：强调领域建模、架构设计、交互建模等。 《软件工程：谷歌的实践》（2022年）：聚焦文化、流程、工具（如代码评审、CI/CD）。  学科演变：  从传统软件工程→面向对象→敏捷开发→系统工程。 新趋势：低代码、AI开发、产品化（从Project到Product）。  ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2025/10/15/25-10-14-4-CompOrg-4-machine-calculation/" title="【计算机组成原理学习】 第四章 数值的机器运算"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【计算机组成原理学习】 第四章 数值的机器运算"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/10/15/25-10-14-4-CompOrg-4-machine-calculation/" title="【计算机组成原理学习】 第四章 数值的机器运算">【计算机组成原理学习】 第四章 数值的机器运算</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-15T13:41:33.000Z" title="发表于 2025-10-15 21:41:33">2025-10-15</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></span></div><div class="content">4.1 基本算数运算的实现 4.1.1 加法器  全加器逻辑与真值表 （略） 逻辑表达式 \[ S_i = A_i \oplus B_i \oplus C_{i - 1} \\\\ C_i = A_iB_i + (A_i \oplus B_i)C_{i - 1} \] 串行与并行 | 种类 | 方法 | 优点 | 缺点 | | — | — | — | — | | 串行加法器 | 数据逐位送入一个加法器进行计算 | 器件少、成本低 | 速度慢 | | 并行加法器 | 由多个全加器组成，位数多少取决于字长 | 速度高 | 加法运算最长时间问题 |  4.2.2 进位的产生与传递 设进位传递函数 \[ P_i = A_i \oplus B_i  \ \text{（进位传递函数）} \\\\ G_i = A_iB_i \] 则 \[ C_n = G_n + P_nC_{n - 1} \] 串行进位加法器的总延迟时间与字长成正比。设一级与门、或门的延迟时间为\(ty\)，每一级全加器延迟为\(2ty\)，从\(C_0\)到\(C_N\)的最长...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2025/10/15/25-10-14-3-CompOrg-3-command-system/" title="【计算机组成原理学习】 第三章 指令系统"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【计算机组成原理学习】 第三章 指令系统"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/10/15/25-10-14-3-CompOrg-3-command-system/" title="【计算机组成原理学习】 第三章 指令系统">【计算机组成原理学习】 第三章 指令系统</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-15T13:41:16.000Z" title="发表于 2025-10-15 21:41:16">2025-10-15</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></span></div><div class="content">3.1 指令格式  基本格式 | | | | — | — | | 操作码字段 | 地址码字段 | 地址码结构 对于一般的双操作数运算指令，除去操作码（Operation Code），还包含  第一操作数地址 \(A_1\)， 第二操作数地址 \(A_2\)， 操作结果存放地址 \(A_3\)， 下一条指令地址 \(A_4\)。  指令结构  四地址指令  含义：\((A_1) OP (A_2) \rightarrow A_3\) 直观，但太长，不实际。  三地址指令  含义：\((A_1) OP (A_2) \rightarrow A_3\)，\((PC) + 1 \rightarrow PC\) 每执行一条指令，程序计数器（PC） 自增。 仍然较长，在大、中型计算机使用。 适用于向量、矩阵运算。  二地址指令  含义：\((A_1) OP (A_2) \rightarrow A_1\)，\(\rm (PC) + 1 \rightarrow PC\) \(A_1\) 为目的操作数地址，\(A_2\)为源操作数...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2025/10/15/25-10-14-2-CompOrg-2-data-represent/" title="【计算机组成原理学习】 第二章 数据的机器层次表示"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【计算机组成原理学习】 第二章 数据的机器层次表示"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/10/15/25-10-14-2-CompOrg-2-data-represent/" title="【计算机组成原理学习】 第二章 数据的机器层次表示">【计算机组成原理学习】 第二章 数据的机器层次表示</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-15T13:40:58.000Z" title="发表于 2025-10-15 21:40:58">2025-10-15</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></span></div><div class="content">2.1 数值数据的表示  无符号数 整个机器字长全部二进制位位数值位。 范围\([0, 2^n - 1]\)。 原码 将最高位设为符号位，其余位数值位，与真值相同。 其中，\([+0]_原 = 00000\)，\([-0]_原 = 10000\)。 原码实现乘除简单，实现加减复杂。 范围\([-(2^{n - 1} - 1), 2^{n - 1} - 1]\)。 补码 正数补码与原码相同，负数补码为真值数值按位取反，在最低位加 1。 其中，\([+0]_补 = [-0]_补 = 00000\)。 范围\([-2^{n - 1}, 2^{n - 1} - 1]\)。 反码 正数反码与原码相同，负数补码为真值数值按位取反。 其中，\([+0]_原 = 00000\)，\([-0]_原 = 11111\)。 范围\([-(2^{n - 1} - 1), 2^{n - 1} - 1]\)。  2.2 机器数的定点表示与浮点表示  定点小数 即纯小数（\(-1 &lt; x &lt; 1\)），小数点位置固定，整数位被取代为符号位。设机器...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2025/10/15/25-10-14-1-CompOrg-1-intro/" title="【计算机组成原理学习】 第一章 概论"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【计算机组成原理学习】 第一章 概论"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/10/15/25-10-14-1-CompOrg-1-intro/" title="【计算机组成原理学习】 第一章 概论">【计算机组成原理学习】 第一章 概论</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-10-15T13:40:25.000Z" title="发表于 2025-10-15 21:40:25">2025-10-15</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></span></div><div class="content">教材 计算机组成原理（第四版） 蒋本珊 清华大学出版社 第一章 概论 1.1 电子计算机与存储程序控制  存储程序的计算机 世界上第一台数字计算机：美国 ENIAC（1946）。 早期存储程序控制的计算机：美国 EDVAC（Von Neumann, 1951），英国 EDSAC（1949）。 存储程序概念（Von Neumann, 1945）  计算机硬件应由五大基本部件组成。 计算机内部采用二进制表示指令和数据。 将程序与原始数据存入存储器中，在启动计算机工作。   1.2 计算机的硬件组成  计算机的主要部件 | | | | — | — | | 输入设备 | 将人们编好的程序和原始数据输送到计算机中，并将其转化为计算机内部所能识别和接受的信息方式的部件 | | 输出设备 | 将计算机的处理结果以人或其他设备所能接收的形式送出计算机的设备 | | 存储器 | 用于存放程序和数据的部件 | | 运算器 | 对信息进行处理和运算的部件，又称算数逻辑运算部件（Arithmetic and Logical Unit, ALU） | |...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2025/09/30/25-9-30-1_HexoDev_ver-desc-1_1_0/" title="【新功能特辑】不蒜子访问量统计"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【新功能特辑】不蒜子访问量统计"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/09/30/25-9-30-1_HexoDev_ver-desc-1_1_0/" title="【新功能特辑】不蒜子访问量统计">【新功能特辑】不蒜子访问量统计</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-09-30T02:20:09.000Z" title="发表于 2025-09-30 10:20:09">2025-09-30</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%9C%AC%E7%AB%99/">本站</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%9C%AC%E7%AB%99/%E6%9B%B4%E6%96%B0/">更新</a></span></div><div class="content">自源代码库版本 1.1.0 起，本站引入不蒜子网页访问量统计服务，以提供更准确的访问量统计。 用户隐私说明 不蒜子网页访问量统计服务提供两种统计：页面访问量统计和用户访问量统计。页面访问量统计仅记录页面被访问的动作，用户访问量统计仅收集用户 IP 地址进行去重。这里的 IP 地址只能大致判断用户所在的国家和地区，难以得知用户更私密的信息。且不蒜子是轻量级的统计服务，没有收集用户隐私的服务。 顺带一提 为什么要引入这个服务？ 要回答这个问题，就要了解 Hexo + Butterfly 自带的页面访问量统计为什么不行。 简单来讲，原版页面访问量统计是可覆盖的，一次新部署之后访问量统计可能会改变，甚至丢失。回顾网站部署前的命令行操作（我的操作）： 123456hexo clean # 清除缓存，为新功能做准备。hexo generate # 执行 Markdown 转 HTML、生成搜索索引文件等操作。hexo server # 在本机上进行**调试**。即便是在服务器上执行此命令也不等同于正式启动服务。hexo server --drafts # 调试，且展示草稿...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2025/09/28/25-9-28-1_HexoDev-log/" title="网站源库开发日志"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="网站源库开发日志"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/09/28/25-9-28-1_HexoDev-log/" title="网站源库开发日志">网站源库开发日志</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-09-28T10:04:16.000Z" title="发表于 2025-09-28 18:04:16">2025-09-28</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%9C%AC%E7%AB%99/">本站</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%9C%AC%E7%AB%99/%E6%9B%B4%E6%96%B0/">更新</a></span></div><div class="content"> 注意： 1. 这是网站源代码库的日志，不是网站部署库的日志。 2. 本日志关注网站功能的添加、删除、更改与问题修复，与文章内容的增减无关。  Source 1.0.0        Date Sept. 28, 2025   Description The first formal version of remy-campanella.github.io. Basic functions are ready and hexo cleaned.    Source 1.0.1        Date Sept. 28, 2025   Description Fixed “the wrong user directed by”Follow me” button” problem.    Source 1.1.0        Date Sept. 30, 2025   Description Added Busuanzi page view statistics.   Ar...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2025/09/27/hello-world/" title="Hello World"><img class="post-bg" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"></a></div><div class="recent-post-info"><a class="article-title" href="/2025/09/27/hello-world/" title="Hello World">Hello World</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2025-09-27T10:09:08.000Z" title="发表于 2025-09-27 18:09:08">2025-09-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%9C%AC%E7%AB%99/">本站</a></span></div><div class="content">Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment </div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/image/icon/loading.gif" data-original="/image/icon/Cover.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Remy Campanella</div><div class="author-info-description">A Remy Campanella blog website on Github.</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/remy-campanella"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站介绍帖、自我介绍帖内容已移至“关于”页面，目录帖内容已移至“分类”页面。</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/12/22/25-11-5-15-COMPSCI220-11-graph-intro/" title="【COMPSCI 220】 Lecture 11 Graphs: A Brief Recap"><img src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【COMPSCI 220】 Lecture 11 Graphs: A Brief Recap"/></a><div class="content"><a class="title" href="/2025/12/22/25-11-5-15-COMPSCI220-11-graph-intro/" title="【COMPSCI 220】 Lecture 11 Graphs: A Brief Recap">【COMPSCI 220】 Lecture 11 Graphs: A Brief Recap</a><time datetime="2025-12-22T08:24:15.000Z" title="发表于 2025-12-22 16:24:15">2025-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/22/25-11-3-3-COMPSCI220-10-quicksort/" title="【COMPSCI 220】 Lecture 10 Quick Sort"><img src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【COMPSCI 220】 Lecture 10 Quick Sort"/></a><div class="content"><a class="title" href="/2025/12/22/25-11-3-3-COMPSCI220-10-quicksort/" title="【COMPSCI 220】 Lecture 10 Quick Sort">【COMPSCI 220】 Lecture 10 Quick Sort</a><time datetime="2025-12-22T07:30:37.000Z" title="发表于 2025-12-22 15:30:37">2025-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/22/25-11-3-2-COMPSCI220-9-sort/" title="【COMPSCI 220】 Lecture 9 Analysis of Sorting Algorithms"><img src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【COMPSCI 220】 Lecture 9 Analysis of Sorting Algorithms"/></a><div class="content"><a class="title" href="/2025/12/22/25-11-3-2-COMPSCI220-9-sort/" title="【COMPSCI 220】 Lecture 9 Analysis of Sorting Algorithms">【COMPSCI 220】 Lecture 9 Analysis of Sorting Algorithms</a><time datetime="2025-12-22T06:32:24.000Z" title="发表于 2025-12-22 14:32:24">2025-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/22/25-11-3-1-COMPSCI220-8-matrix/" title="【COMPSCI 220】 Lecture 8 Matrix Multiplication and Strassen’s Algorithm"><img src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【COMPSCI 220】 Lecture 8 Matrix Multiplication and Strassen’s Algorithm"/></a><div class="content"><a class="title" href="/2025/12/22/25-11-3-1-COMPSCI220-8-matrix/" title="【COMPSCI 220】 Lecture 8 Matrix Multiplication and Strassen’s Algorithm">【COMPSCI 220】 Lecture 8 Matrix Multiplication and Strassen’s Algorithm</a><time datetime="2025-12-22T05:16:46.000Z" title="发表于 2025-12-22 13:16:46">2025-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/22/25-12-11-2-COMPSCI220-7-div-coq/" title="【COMPSCI 220】 Lecture 7 Divide and Conquer"><img src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【COMPSCI 220】 Lecture 7 Divide and Conquer"/></a><div class="content"><a class="title" href="/2025/12/22/25-12-11-2-COMPSCI220-7-div-coq/" title="【COMPSCI 220】 Lecture 7 Divide and Conquer">【COMPSCI 220】 Lecture 7 Divide and Conquer</a><time datetime="2025-12-22T05:09:08.000Z" title="发表于 2025-12-22 13:09:08">2025-12-22</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            <a class="card-more-btn" href="/categories/" title="查看更多">
      <i class="fas fa-angle-right"></i></a>
          </div>
          <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/"><span class="card-category-list-name">技术</span><span class="card-category-list-count">42</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/"><span class="card-category-list-name">学习</span><span class="card-category-list-count">41</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/COMPSCI-220-Algorithms-and-Data-Structures/"><span class="card-category-list-name">COMPSCI 220 Algorithms and Data Structures</span><span class="card-category-list-count">11</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/STATS-330-Application-and-Practice-of-Statistics/"><span class="card-category-list-name">STATS 330 Application and Practice of Statistics</span><span class="card-category-list-count">6</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"><span class="card-category-list-name">操作系统原理</span><span class="card-category-list-count">18</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"><span class="card-category-list-name">计算机组成原理</span><span class="card-category-list-count">4</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"><span class="card-category-list-name">软件工程</span><span class="card-category-list-count">2</span></a></li></ul></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/%E7%BD%91%E7%AB%99/"><span class="card-category-list-name">网站</span><span class="card-category-list-count">1</span></a></li></ul></li>
          </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/R-%E8%AF%AD%E8%A8%80/" style="font-size: 1.3em; color: #99a1ac">R 语言</a> <a href="/tags/Hexo/" style="font-size: 1.1em; color: #999">Hexo</a> <a href="/tags/Hexo-%E6%8A%98%E8%85%BE%E6%89%8B%E5%86%8C/" style="font-size: 1.1em; color: #999">Hexo 折腾手册</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" style="font-size: 1.15em; color: #999b9e">软件工程</a> <a href="/tags/%E5%A5%A5%E5%85%8B%E5%85%B0%E5%A4%A7%E5%AD%A6%E2%80%94%E8%A5%BF%E5%8D%97%E5%A4%A7%E5%AD%A6%E5%90%88%E4%BD%9C%E8%AF%BE%E7%A8%8B/" style="font-size: 1.4em; color: #99a5b6">奥克兰大学—西南大学合作课程</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/" style="font-size: 1.1em; color: #999">前端工程</a> <a href="/tags/%E7%BD%91%E7%AB%99/" style="font-size: 1.15em; color: #999b9e">网站</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="font-size: 1.5em; color: #99a9bf">学习笔记</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 1.45em; color: #99a7ba">操作系统</a> <a href="/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6/" style="font-size: 1.3em; color: #99a1ac">统计学</a> <a href="/tags/%E4%BB%8B%E7%BB%8D/" style="font-size: 1.2em; color: #999da3">介绍</a> <a href="/tags/%E5%A4%96%E6%96%87/" style="font-size: 1.4em; color: #99a5b6">外文</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" style="font-size: 1.25em; color: #999fa7">计算机组成原理</a> <a href="/tags/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/" style="font-size: 1.35em; color: #99a3b1">算法分析与设计</a> <a href="/tags/Node-js/" style="font-size: 1.1em; color: #999">Node.js</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" style="font-size: 1.1em; color: #999">基础知识</a> <a href="/tags/log/" style="font-size: 1.15em; color: #999b9e">log</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/" style="font-size: 1.3em; color: #99a1ac">数据科学</a></div></div><div class="card-widget card-archives">
    <div class="item-headline">
      <i class="fas fa-archive"></i>
      <span>归档</span>
      
    </div>
  
    <ul class="card-archive-list">
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/12/">
            <span class="card-archive-list-date">
              十二月 2025
            </span>
            <span class="card-archive-list-count">7</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/11/">
            <span class="card-archive-list-date">
              十一月 2025
            </span>
            <span class="card-archive-list-count">26</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/10/">
            <span class="card-archive-list-date">
              十月 2025
            </span>
            <span class="card-archive-list-count">10</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/09/">
            <span class="card-archive-list-date">
              九月 2025
            </span>
            <span class="card-archive-list-count">3</span>
          </a>
        </li>
      
    </ul>
  </div><script>function checkPv(){ 
    var init_pv = parseInt()
    var pv = document.getElementById("busuanzi_value_site_pv")
    if (pv.innerText === ''){
    setTimeout(checkPv, 100)
    } else {
        pv.innerText = parseInt(pv.innerText) + init_pv
    }
}</script><script>checkPv()</script><script>function checkUv(){ 
    var init_uv = parseInt()
    var uv = document.getElementById("busuanzi_value_site_uv")
    if (uv.innerText === ''){
    setTimeout(checkUv, 100)
    }else{
        uv.innerText = parseInt(uv.innerText) + init_uv
    }
}</script><script>checkUv()</script></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Remy Campanella</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.0</a></span></div><div class="footer_custom_text">源代码库版本 1.4.0</div></div><script type="text/javascript" id="maid-script" src="https://unpkg.com/mermaid@9.0.0/dist/mermaid.min.js"></script><script>if (window.mermaid) {
  var options = JSON.parse(document.getElementById('maid-script').getAttribute('mermaidoptioins'));
  mermaid.initialize(options);
}</script></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://unpkg.com/mermaid@11.11.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start -->
    <script src="/js/gallery.js" async></script>
<!-- hexo injector body_end end -->
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 2,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>