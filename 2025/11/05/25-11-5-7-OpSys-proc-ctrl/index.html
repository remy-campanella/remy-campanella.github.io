<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>【操作系统原理】 Lecture 12 进程控制 | remy-campanella.github.io</title><meta name="author" content="Remy Campanella"><meta name="copyright" content="Remy Campanella"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、进程切换 进程切换是操作系统多任务处理的核心，指CPU从一个进程的运行切换到另一个进程运行的过程。 1. 核心概念：上下文切换  上下文：指一个进程运行时所需的全部信息，包括：  用户级上下文：代码、数据、用户栈、共享内存。 寄存器上下文：通用寄存器、程序计数器、栈指针等。 系统级上下文：进程控制块、内存管理信息（如页表基址）。   上下文切换：保存当前进程的上下文，加载新进程的上下文，并转移">
<meta property="og:type" content="article">
<meta property="og:title" content="【操作系统原理】 Lecture 12 进程控制">
<meta property="og:url" content="https://remy-campanella.github.io/2025/11/05/25-11-5-7-OpSys-proc-ctrl/index.html">
<meta property="og:site_name" content="remy-campanella.github.io">
<meta property="og:description" content="一、进程切换 进程切换是操作系统多任务处理的核心，指CPU从一个进程的运行切换到另一个进程运行的过程。 1. 核心概念：上下文切换  上下文：指一个进程运行时所需的全部信息，包括：  用户级上下文：代码、数据、用户栈、共享内存。 寄存器上下文：通用寄存器、程序计数器、栈指针等。 系统级上下文：进程控制块、内存管理信息（如页表基址）。   上下文切换：保存当前进程的上下文，加载新进程的上下文，并转移">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://remy-campanella.github.io/image/background/remy.jpg">
<meta property="article:published_time" content="2025-11-05T01:35:20.000Z">
<meta property="article:modified_time" content="2025-11-05T01:35:20.517Z">
<meta property="article:author" content="Remy Campanella">
<meta property="article:tag" content="学习笔记">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://remy-campanella.github.io/image/background/remy.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "【操作系统原理】 Lecture 12 进程控制",
  "url": "https://remy-campanella.github.io/2025/11/05/25-11-5-7-OpSys-proc-ctrl/",
  "image": "https://remy-campanella.github.io/image/background/remy.jpg",
  "datePublished": "2025-11-05T01:35:20.000Z",
  "dateModified": "2025-11-05T01:35:20.517Z",
  "author": [
    {
      "@type": "Person",
      "name": "Remy Campanella",
      "url": "https://remy-campanella.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/image/icon/icon.png"><link rel="canonical" href="https://remy-campanella.github.io/2025/11/05/25-11-5-7-OpSys-proc-ctrl/index.html"><link rel="preconnect" href="https://unpkg.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@7.0.1/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://unpkg.com/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【操作系统原理】 Lecture 12 进程控制',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/scripts/css/font.css"><!-- hexo injector head_end start -->
    <link rel="stylesheet" href="/css/gallery.css" media="print" onload="this.media='all'">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/image/icon/loading.gif" data-original="/image/icon/Cover.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about"><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/album"><span> 图库</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/image/background/remy.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/image/icon/loading.gif" data-original="/image/icon/icon.png" alt="Logo"><span class="site-name">remy-campanella.github.io</span></a><a class="nav-page-title" href="/"><span class="site-name">【操作系统原理】 Lecture 12 进程控制</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about"><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/album"><span> 图库</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">【操作系统原理】 Lecture 12 进程控制</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-11-05T01:35:20.000Z" title="发表于 2025-11-05 09:35:20">2025-11-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-11-05T01:35:20.517Z" title="更新于 2025-11-05 09:35:20">2025-11-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">操作系统原理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="一、进程切换"><strong>一、进程切换</strong></h3>
<p>进程切换是操作系统多任务处理的核心，指CPU从一个进程的运行切换到另一个进程运行的过程。</p>
<h4 id="1-核心概念：上下文切换"><strong>1. 核心概念：上下文切换</strong></h4>
<ul class="lvl-0">
<li class="lvl-2"><strong>上下文</strong>：指一个进程运行时所需的全部信息，包括：
<ul class="lvl-2">
<li class="lvl-4"><strong>用户级上下文</strong>：代码、数据、用户栈、共享内存。</li>
<li class="lvl-4"><strong>寄存器上下文</strong>：通用寄存器、程序计数器、栈指针等。</li>
<li class="lvl-4"><strong>系统级上下文</strong>：进程控制块、内存管理信息（如页表基址）。</li>
</ul>
</li>
<li class="lvl-2"><strong>上下文切换</strong>：保存当前进程的上下文，加载新进程的上下文，并转移控制权的过程。</li>
</ul>
<h4 id="2-ucore中的实现"><strong>2. ucore中的实现</strong></h4>
<ul class="lvl-0">
<li class="lvl-2"><strong>进程控制块</strong>：<code>proc_struct</code>（<code>kern/process/proc.h</code>）是ucore的PCB，包含了进程状态、内核栈、进程ID、内存管理结构指针（<code>mm_struct</code>）等所有信息。</li>
<li class="lvl-2"><strong>内存地址空间</strong>：<code>mm_struct</code>管理进程的虚拟地址空间，包含指向页目录的指针和VMA链表。</li>
<li class="lvl-2"><strong>进程队列</strong>：ucore使用链表组织不同状态的进程（如就绪队列、等待队列）。</li>
<li class="lvl-2"><strong>切换流程</strong>：
<ol>
<li class="lvl-6"><strong>触发切换</strong>：时钟中断、I/O中断或系统调用可能导致调度。</li>
<li class="lvl-6"><strong>保存上下文</strong>：当前进程在内核态下，将其寄存器上下文保存到自己的内核栈中。</li>
<li class="lvl-6"><strong>选择新进程</strong>：调度器从就绪队列中选择下一个要运行的进程。</li>
<li class="lvl-6"><strong>切换栈</strong>：将CPU的栈指针（ESP）指向新进程的内核栈顶。</li>
<li class="lvl-6"><strong>恢复上下文</strong>：从新进程的内核栈中恢复寄存器上下文。</li>
<li class="lvl-6"><strong>执行新进程</strong>：通过<code>iret</code>指令返回用户态，开始执行新进程。</li>
</ol>
</li>
<li class="lvl-2"><strong>关键函数</strong>：<code>switch_to</code>（<code>kern/arch/i386/process/switch.S</code>）是一个汇编函数，负责完成最核心的栈指针切换和寄存器恢复。</li>
</ul>
<hr>
<h3 id="二、进程创建"><strong>二、进程创建</strong></h3>
<p>进程创建是操作系统生成新进程的过程，最经典的系统调用是<code>fork()</code>。</p>
<h4 id="1-fork-系统调用"><strong>1. <code>fork()</code>系统调用</strong></h4>
<ul class="lvl-0">
<li class="lvl-2"><strong>功能</strong>：创建一个与当前进程（父进程）几乎完全相同的子进程。</li>
<li class="lvl-2"><strong>地址空间复制</strong>：
<ul class="lvl-2">
<li class="lvl-4"><strong>传统方式</strong>：复制父进程的整个地址空间（代码、数据、堆栈），开销大。</li>
<li class="lvl-4"><strong>现代方式（写时复制, Copy-on-Write, COW）</strong>：
<ul class="lvl-4">
<li class="lvl-6">父子进程共享相同的物理页，但页表项标记为只读。</li>
<li class="lvl-6">当任一进程尝试写入时，触发缺页异常，内核才复制该页，赋予写权限。</li>
<li class="lvl-6"><strong>优点</strong>：极大降低了<code>fork()</code>的开销，提高了创建进程的效率。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-ucore中的实现-2"><strong>2. ucore中的实现</strong></h4>
<ul class="lvl-0">
<li class="lvl-2"><strong><code>do_fork()</code>函数</strong>：<code>fork()</code>系统调用的内核实现。
<ol>
<li class="lvl-6"><strong>分配PCB</strong>：调用<code>alloc_proc()</code>为新进程分配一个<code>proc_struct</code>并初始化。</li>
<li class="lvl-6"><strong>设置内核栈</strong>：调用<code>setup_stack()</code>和<code>copy_stack()</code>为子进程设置内核栈，并复制父进程的部分上下文。</li>
<li class="lvl-6"><strong>复制内存空间</strong>：调用<code>copy_mm()</code>复制父进程的<code>mm_struct</code>和页表，实现写时复制。</li>
<li class="lvl-6"><strong>设置进程状态</strong>：将子进程设置为<code>PROC_RUNNABLE</code>（就绪）状态，并加入就绪队列。</li>
<li class="lvl-6"><strong>返回</strong>：父进程返回子进程PID，子进程返回0。</li>
</ol>
</li>
<li class="lvl-2"><strong>特殊进程创建</strong>：
<ul class="lvl-2">
<li class="lvl-4"><strong>空闲进程</strong>：在<code>proc_init()</code>中创建，是所有进程的祖先，当没有就绪进程时运行它。</li>
<li class="lvl-4"><strong>第一个内核线程</strong>：同样在<code>proc_init()</code>中创建，用于执行初始化任务，并最终加载第一个用户进程。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="三、进程加载"><strong>三、进程加载</strong></h3>
<p>进程加载是指用一个全新的程序替换当前进程的地址空间，主要通过<code>exec()</code>系统调用实现。</p>
<h4 id="1-exec-系统调用"><strong>1. <code>exec()</code>系统调用</strong></h4>
<ul class="lvl-0">
<li class="lvl-2"><strong>功能</strong>：在当前进程的上下文中，读取磁盘上的可执行文件，清除旧的地址空间，建立新的地址空间，并开始执行新程序。</li>
<li class="lvl-2"><strong>特点</strong>：
<ul class="lvl-2">
<li class="lvl-4"><strong>不创建新进程</strong>：<code>exec()</code>调用后，原进程被新程序“覆盖”，但PID不变。</li>
<li class="lvl-4"><strong>保留部分信息</strong>：通常保留打开的文件描述符（除非显式关闭）。</li>
</ul>
</li>
</ul>
<h4 id="2-ucore中的实现-3"><strong>2. ucore中的实现</strong></h4>
<ul class="lvl-0">
<li class="lvl-2"><strong><code>do_execve()</code>函数</strong>：<code>exec()</code>系统调用的内核实现。
<ol>
<li class="lvl-6"><strong>加载ELF文件</strong>：解析可执行文件的ELF头，获取程序头信息。</li>
<li class="lvl-6"><strong>创建新内存空间</strong>：调用<code>mm_create()</code>创建一个新的<code>mm_struct</code>。</li>
<li class="lvl-6"><strong>建立内存映射</strong>：根据程序头，为代码段、数据段等建立VMA，并分配物理页或设置延迟分配。</li>
<li class="lvl-6"><strong>设置入口点</strong>：将新程序的入口地址（通常是<code>_start</code>）设置到子进程的 trapframe 中，这样从内核返回用户态时会跳转到新程序执行。</li>
<li class="lvl-6"><strong>替换当前进程</strong>：释放旧的内存空间，用新的<code>mm_struct</code>替换当前进程的<code>mm</code>指针。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="四、进程等待与退出"><strong>四、进程等待与退出</strong></h3>
<p>进程等待与退出是进程生命周期结束和资源回收的机制。</p>
<h4 id="1-exit-系统调用"><strong>1. <code>exit()</code>系统调用</strong></h4>
<ul class="lvl-0">
<li class="lvl-2"><strong>功能</strong>：终止当前进程，释放其占有的大部分资源（如内存、文件），并通知父进程。</li>
<li class="lvl-2"><strong>状态转换</strong>：进程从运行态变为<strong>僵尸状态</strong>。
<ul class="lvl-2">
<li class="lvl-4"><strong>僵尸状态</strong>：进程已终止，但其PCB仍保留在内核中，等待父进程获取其退出状态信息。</li>
</ul>
</li>
</ul>
<h4 id="2-wait-系统调用"><strong>2. <code>wait()</code>系统调用</strong></h4>
<ul class="lvl-0">
<li class="lvl-2"><strong>功能</strong>：父进程调用<code>wait()</code>或<code>waitpid()</code>来等待子进程结束。</li>
<li class="lvl-2"><strong>行为</strong>：
<ul class="lvl-2">
<li class="lvl-4">如果子进程仍在运行，父进程阻塞。</li>
<li class="lvl-4">如果子进程已结束（处于僵尸状态），父进程回收子进程的PCB，获取其退出码，子进程彻底消失。</li>
</ul>
</li>
</ul>
<h4 id="3-ucore中的实现"><strong>3. ucore中的实现</strong></h4>
<ul class="lvl-0">
<li class="lvl-2"><strong><code>do_exit()</code>函数</strong>：
<ol>
<li class="lvl-6">释放进程的内存空间和资源。</li>
<li class="lvl-6">设置进程状态为<code>PROC_ZOMBIE</code>（僵尸）。</li>
<li class="lvl-6">如果父进程正在等待（<code>PROC_WAITING</code>），则唤醒父进程。</li>
<li class="lvl-6">调用调度器，选择新进程运行。</li>
</ol>
</li>
<li class="lvl-2"><strong><code>do_wait()</code>函数</strong>：
<ol>
<li class="lvl-6">查找子进程，如果子进程未结束，则将当前进程设置为<code>PROC_WAITING</code>状态并阻塞。</li>
<li class="lvl-6">如果找到僵尸子进程，回收其PCB，并返回子进程的PID和退出状态。</li>
</ol>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://remy-campanella.github.io">Remy Campanella</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://remy-campanella.github.io/2025/11/05/25-11-5-7-OpSys-proc-ctrl/">https://remy-campanella.github.io/2025/11/05/25-11-5-7-OpSys-proc-ctrl/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://remy-campanella.github.io" target="_blank">remy-campanella.github.io</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post-share"><div class="social-share" data-image="/image/background/remy.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://unpkg.com/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://unpkg.com/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/11/05/25-11-5-9-OpSys-user-proc-man/" title="【操作系统原理】 Lecture 14 实验五 用户进程管理"><img class="cover" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">【操作系统原理】 Lecture 14 实验五 用户进程管理</div></div><div class="info-2"><div class="info-item-1">一、总体介绍 1. 实验目标 本实验的目标是构建一个完整的用户进程环境，让学生掌握从内核态到用户态的跨越，以及用户进程的生命周期管理。  创建第一个用户进程：理解如何“硬构造”出第一个用户进程，为其建立用户态的代码/数据段。 实现系统调用框架：理解用户态如何通过int 0x80中断陷入内核，执行系统调用，并返回用户态。 掌握进程管理机制：包括进程的创建（fork）、加载（exec）、复制和销毁。  2. 核心练习  加载并执行应用程序：将一个简单的hello程序（ELF格式）加载到内存并运行。 实现进程复制：完成fork系统调用，让父进程复制自己的内存空间给子进程。 分析系统调用与进程管理：深入理解do_execve和do_fork的实现细节。   二、进程的内存布局 理解用户进程的虚拟内存空间是本实验的基础。 1. 内核与进程虚拟内存布局对比 ucore为内核和用户进程设计了不同的虚拟内存布局：  内核空间（高地址）：  KERNBASE到KERNTOP：内核代码和数据，直接映射物理内存。 VPT：存放当前页目录和页表的虚拟地址，便于内核访问。   用户空间（低地址）：  US...</div></div></div></a><a class="pagination-related" href="/2025/11/05/25-11-5-6-OpSys-proc-thrd/" title="【操作系统原理】 Lecture 11 进程与线程"><img class="cover" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">【操作系统原理】 Lecture 11 进程与线程</div></div><div class="info-2"><div class="info-item-1">一、进程 1. 进程的定义与组成  定义：进程是一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。它是操作系统进行资源分配和调度的基本单位。 与程序的区别：    维度 程序 进程     性质 静态的代码和数据集合 动态的执行过程   生命周期 长期存在于磁盘 临时存在，有创建、执行、消亡的生命周期   并发性 自身无法并发 可以与其他进程并发执行   资源分配 不直接占用系统资源 是资源分配的基本单位（内存、文件等）     组成：进程包含了正在运行的一个程序的所有状态信息，包括：  代码段：程序的指令。 数据段：全局变量和静态变量。 堆栈段：函数调用栈、局部变量和动态分配的内存。 进程控制块：管理进程的核心数据结构。    2. 进程控制块  作用：PCB是操作系统管理控制进程运行所用的信息集合，是进程存在的唯一标志。 包含信息：  进程标识信息：如进程ID（PID）、父进程ID。 进程控制信息：进程状态、程序计数器、CPU寄存器值、内存管理信息（页表基址）、I/O状态信息等。   组织方式：  链表：将同一状态的PCB链接成一个队列（如就绪队列、等待队列）。 ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/11/05/25-11-3-4-OpSys-intro/" title="【操作系统原理】 Lecture 1 课程概述"><img class="cover" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-05</div><div class="info-item-2">【操作系统原理】 Lecture 1 课程概述</div></div><div class="info-2"><div class="info-item-1">一、课程目标与意义  学习目的  掌握操作系统（OS）的基本原理与实现技术。 通过开发小型OS实践核心阶段（如中断处理、内存管理）。 深化对计算机系统的整体理解，提升知识应用能力。   OS的重要性  计算机科学的基石，连接硬件、软件与应用的核心支撑。 贯穿程序语言、编译、体系结构等领域，影响专业素质。    二、课程结构与内容   核心教学内容  OS结构、中断与系统调用、内存管理、进程/线程、调度、同步互斥、文件系统、I/O子系统。    实验与实践  实验序列：环境准备→系统启动→物理/虚拟内存管理→内核线程→用户进程→调度→同步→文件系统。 课程设计：基于RISC-V的ucore OS内核开发。    参考教材  《Operating System Concepts》（恐龙书） 《Operating Systems: Three Easy Pieces》（OSTEP）    三、操作系统核心概念   定义与地位  OS是管理硬件资源、提供用户接口的系统软件，位于硬件与应用之间（承上启下）。    内核特征  并发：多程序同时运行，需调度管理。 共享：资源互斥或同时访问。 ...</div></div></div></a><a class="pagination-related" href="/2025/11/05/25-11-3-8-OpSys-phy-mem-con/" title="【操作系统原理】 Lecture 5 物理内存管理：连续内存分配"><img class="cover" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-05</div><div class="info-item-2">【操作系统原理】 Lecture 5 物理内存管理：连续内存分配</div></div><div class="info-2"><div class="info-item-1">一、计算机体系结构与内存层次 计算机体系结构  基础：基于Intel® 64和IA-32架构，参考官方手册（Intel® 64 and IA-32 Architectures Software Developer Manuals）。 核心组件：   CPU：执行指令，生成逻辑地址。 MMU（内存管理单元）：将逻辑地址转换为物理地址，支持分段和分页。 总线：连接CPU、内存和外设。  内存层次  结构：   高速缓存（Cache）：速度快，容量小，减少CPU访问内存延迟。 主存（RAM）：存放运行中的程序和数据。 外存（磁盘）：持久化存储，用于交换分区（Swapping）。   性能问题：   高速缓存未命中：需从主存加载数据，延迟增加。 缺页（Page Fault）：虚拟内存机制中，访问未加载的页需从磁盘读取。  二、操作系统的内存管理方式 管理方式分类    方式 特点 应用场景     重定位 程序加载时调整地址，适应内存位置 早期单任务系统   分段 按逻辑模块划分段（如代码段、数据段），支持地址隔离 Intel x86保护模式   分页 将内存划分为固定大小的页，减少外部...</div></div></div></a><a class="pagination-related" href="/2025/11/05/25-11-3-6-OpSys-interrupt/" title="【操作系统原理】 Lecture 3 启动中断异常系统调用"><img class="cover" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-05</div><div class="info-item-2">【操作系统原理】 Lecture 3 启动中断异常系统调用</div></div><div class="info-2"><div class="info-item-1">一、计算机启动流程  启动前的硬件状态  CPU状态：PC指向固定地址（如x86的0xFFFF0），处于特权态（实模式），地址空间有限（x86为1MB）。 内存布局：BIOS固件位于高地址区域，低地址为加载程序预留空间。 初始化：硬件自检（POST）、内存控制器初始化、寄存器复位。   启动阶段  BIOS阶段：  执行自检程序，初始化硬件（如键盘、串口）。 加载磁盘引导扇区（512字节）到内存0x7C00，跳转执行。   Bootloader阶段：  加载操作系统内核到内存，跳转至OS入口。   OS初始化：  初始化数据结构、外设驱动，建立中断处理机制。     启动规范  传统BIOS：MBR（主引导记录）→ 分区引导扇区 → OS加载。 UEFI：更现代的固件接口，支持安全启动和大容量磁盘。    二、中断、异常与系统调用   定义与分类    类型 触发方式 示例（x86）     中断 外部设备信号（如键盘、时钟） INTR（可屏蔽）、NMI（不可屏蔽）   异常 CPU执行指令时的错误或特殊事件 页故障（#PF）、除零错误（#DE）   系统调用 用户程序主动请求内...</div></div></div></a><a class="pagination-related" href="/2025/11/05/25-11-3-5-OpSys-exp0-env/" title="【操作系统原理】 Lecture 2 实验零 操作实验系统实验环境准备"><img class="cover" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-05</div><div class="info-item-2">【操作系统原理】 Lecture 2 实验零 操作实验系统实验环境准备</div></div><div class="info-2"><div class="info-item-1">一、了解操作系统（OS）  核心概念  特权机制：CPU通过特权级（如CPL=0为最高特权）保护系统安全，特权指令（如LIDT、MOV CRn）只能在特权态执行，否则触发异常。 中断与异常管理：包括外设中断、陷阱中断（如系统调用）和故障中断（如缺页异常）。 内存管理：  分段（Segmentation）和分页（Paging）机制，实现虚拟内存（Virtual Memory）。 硬件支持：TLB（快表）、MMU（内存管理单元）。     OS设计目标  高效管理硬件资源（CPU、内存、外设）。 提供系统调用接口，实现用户态与内核态切换。    二、了解硬件   计算机体系结构  图灵机模型：有限状态机，通过读写符号和状态转换实现计算。 冯·诺依曼架构：  组成：CPU（寄存器、执行单元）、内存、磁盘、键盘、显示器等。 特点：存储程序，指令与数据共享内存。      x86硬件特性  特权指令：仅当CPL=0时可执行，否则触发通用保护异常（如LGDT、STI）。 关键组件：  BIOS ROM（启动固件）、时钟（中断源）、地址/数据信号线。   实验环境：ucore OS基于x86架...</div></div></div></a><a class="pagination-related" href="/2025/11/05/25-11-3-7-OpSys-exp1-bootloader/" title="【操作系统原理】 Lecture 4 实验一 Bootloader 启动 ucore OS"><img class="cover" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-05</div><div class="info-item-2">【操作系统原理】 Lecture 4 实验一 Bootloader 启动 ucore OS</div></div><div class="info-2"><div class="info-item-1">一、x86启动顺序 启动流程  BIOS阶段   初始状态：CS=0xF000, EIP=0xFFF0，物理地址为0xFFFFFFF0（BIOS EPROM位置）。 第一条指令：长跳转（JMP）到BIOS代码区，更新CS:EIP。   加载Bootloader   BIOS将存储设备（硬盘/USB）的**主引导扇区（MBR，512字节）**加载到内存0x7C00，并跳转执行。   Bootloader任务   使能保护模式：设置CR0寄存器的PE位（Bit 0）。 加载内核：从硬盘读取ELF格式的ucore内核到内存固定位置。 跳转执行：跳转到ucore入口点，移交控制权。  实模式与保护模式  实模式（历史背景）   寻址方式：段基址:偏移量（如CS:IP），物理地址 = 段基址*16 + 偏移量。 限制：20位地址总线，最大1MB空间（0x00000~0xFFFFF），无保护机制。 中断处理：中断向量表（IVT）位于内存低地址，INT n通过N*4获取ISR地址。   保护模式   段机制：通过**全局描述符表（GDT）**管理段基址和权限，lgdt指令加载GDT。 特权级：...</div></div></div></a><a class="pagination-related" href="/2025/11/05/25-11-5-13-OpSys-sync-excl/" title="【操作系统原理】 Lecture 17 同步互斥"><img class="cover" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-05</div><div class="info-item-2">【操作系统原理】 Lecture 17 同步互斥</div></div><div class="info-2"><div class="info-item-1">一、背景与并发问题 1. 并发的好处与挑战  好处：并发执行可以充分利用多核CPU资源，提高系统吞吐量和响应速度。 挑战：并发进程共享资源时，如果协调不当，会导致竞态条件，即程序的最终结果依赖于进程执行的相对时序，从而产生不可预测的错误。  2. 竞态条件示例：PID分配 幻灯片中给出了一个经典的例子：两个进程A和B同时尝试获取下一个进程ID（next_pid）。  错误场景：  进程A加载next_pid（值为100）到寄存器。 发生上下文切换，进程B运行。 进程B加载next_pid（仍为100），将其分配给new_pid，然后递增next_pid为101并写回。 上下文切换回进程A。 进程A继续执行，将寄存器中的100分配给它的new_pid，然后递增next_pid为101并写回。   结果：两个进程获得了相同的PID（100），系统状态出错。 根本原因：load -&gt; store -&gt; inc -&gt; store这个序列不是一个原子操作，它在执行过程中被中断，导致了不一致的状态。   二、现实生活中的同步问题与临界区 1. 家庭采购协调问题 这个生动的例...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/image/icon/loading.gif" data-original="/image/icon/Cover.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Remy Campanella</div><div class="author-info-description">A Remy Campanella blog website on Github.</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/remy-campanella"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站介绍帖、自我介绍帖内容已移至“关于”页面，目录帖内容已移至“分类”页面。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="toc-number">1.</span> <span class="toc-text">一、进程切换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%EF%BC%9A%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">1.1.</span> <span class="toc-text">1. 核心概念：上下文切换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-ucore%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.</span> <span class="toc-text">2. ucore中的实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="toc-number">2.</span> <span class="toc-text">二、进程创建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-fork-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">2.1.</span> <span class="toc-text">1. fork()系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-ucore%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">2.2.</span> <span class="toc-text">2. ucore中的实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%BF%9B%E7%A8%8B%E5%8A%A0%E8%BD%BD"><span class="toc-number">3.</span> <span class="toc-text">三、进程加载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-exec-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">3.1.</span> <span class="toc-text">1. exec()系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-ucore%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">3.2.</span> <span class="toc-text">2. ucore中的实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AD%89%E5%BE%85%E4%B8%8E%E9%80%80%E5%87%BA"><span class="toc-number">4.</span> <span class="toc-text">四、进程等待与退出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-exit-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">4.1.</span> <span class="toc-text">1. exit()系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-wait-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">4.2.</span> <span class="toc-text">2. wait()系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-ucore%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.3.</span> <span class="toc-text">3. ucore中的实现</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/11/19/25-11-19-1-COMPSCI220-asym-not/" title="【COMPSCI 220】Lecture 4 Asymptotic notations"><img src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【COMPSCI 220】Lecture 4 Asymptotic notations"/></a><div class="content"><a class="title" href="/2025/11/19/25-11-19-1-COMPSCI220-asym-not/" title="【COMPSCI 220】Lecture 4 Asymptotic notations">【COMPSCI 220】Lecture 4 Asymptotic notations</a><time datetime="2025-11-19T01:13:20.000Z" title="发表于 2025-11-19 09:13:20">2025-11-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/11/19/25-11-4-3-COMSCI220-esti-run-time/" title="【COMPSCI 220】 Lecture 3 How to Estimate Running Time?"><img src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【COMPSCI 220】 Lecture 3 How to Estimate Running Time?"/></a><div class="content"><a class="title" href="/2025/11/19/25-11-4-3-COMSCI220-esti-run-time/" title="【COMPSCI 220】 Lecture 3 How to Estimate Running Time?">【COMPSCI 220】 Lecture 3 How to Estimate Running Time?</a><time datetime="2025-11-19T00:38:52.000Z" title="发表于 2025-11-19 08:38:52">2025-11-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/11/19/25-11-4-2-COMPSCI220-run-time/" title="【COMPSCI 220】 Lecture 2 How to Measure Running Time?"><img src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【COMPSCI 220】 Lecture 2 How to Measure Running Time?"/></a><div class="content"><a class="title" href="/2025/11/19/25-11-4-2-COMPSCI220-run-time/" title="【COMPSCI 220】 Lecture 2 How to Measure Running Time?">【COMPSCI 220】 Lecture 2 How to Measure Running Time?</a><time datetime="2025-11-19T00:12:57.000Z" title="发表于 2025-11-19 08:12:57">2025-11-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/11/19/25-11-4-1-COMPSCI220-intro/" title="【COMPSCI 220】 Lecture 1 What is a Algorithm and Why Analyse It?"><img src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【COMPSCI 220】 Lecture 1 What is a Algorithm and Why Analyse It?"/></a><div class="content"><a class="title" href="/2025/11/19/25-11-4-1-COMPSCI220-intro/" title="【COMPSCI 220】 Lecture 1 What is a Algorithm and Why Analyse It?">【COMPSCI 220】 Lecture 1 What is a Algorithm and Why Analyse It?</a><time datetime="2025-11-19T00:05:38.000Z" title="发表于 2025-11-19 08:05:38">2025-11-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/11/05/25-11-5-14-OpSys-sema-tube/" title="【操作系统原理】 Lecture 18 信号量与管程"><img src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【操作系统原理】 Lecture 18 信号量与管程"/></a><div class="content"><a class="title" href="/2025/11/05/25-11-5-14-OpSys-sema-tube/" title="【操作系统原理】 Lecture 18 信号量与管程">【操作系统原理】 Lecture 18 信号量与管程</a><time datetime="2025-11-05T01:36:42.000Z" title="发表于 2025-11-05 09:36:42">2025-11-05</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Remy Campanella</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.0</a></span></div><div class="footer_custom_text">源代码库版本 1.4.0</div></div><script type="text/javascript" id="maid-script" src="https://unpkg.com/mermaid@9.0.0/dist/mermaid.min.js"></script><script>if (window.mermaid) {
  var options = JSON.parse(document.getElementById('maid-script').getAttribute('mermaidoptioins'));
  mermaid.initialize(options);
}</script></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        loader: {
          load: [
            // Four font extension packages (optional)
            //- '[tex]/bbm',
            //- '[tex]/bboldx',
            //- '[tex]/dsfont',
            '[tex]/mhchem'
          ],
          paths: {
            'mathjax-newcm': '[mathjax]/../@mathjax/mathjax-newcm-font',

            //- // Four font extension packages (optional)
            //- 'mathjax-bbm-extension': '[mathjax]/../@mathjax/mathjax-bbm-font-extension',
            //- 'mathjax-bboldx-extension': '[mathjax]/../@mathjax/mathjax-bboldx-font-extension',
            //- 'mathjax-dsfont-extension': '[mathjax]/../@mathjax/mathjax-dsfont-font-extension',
            'mathjax-mhchem-extension': '[mathjax]/../@mathjax/mathjax-mhchem-font-extension'
          }
        },
        output: {
          font: 'mathjax-newcm',
        },
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
          packages: {
            '[+]': [
              'mhchem'
            ]
          }
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          menuOptions: {
            settings: {
              enrich: false  // Turn off Braille and voice narration text automatic generation
            }
          },
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://unpkg.com/mathjax@4.0.0/tex-mml-chtml.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://unpkg.com/mermaid@11.11.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start -->
    <script src="/js/gallery.js" async></script>
<!-- hexo injector body_end end -->
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 2,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>