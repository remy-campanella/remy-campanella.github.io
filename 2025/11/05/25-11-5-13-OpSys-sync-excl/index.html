<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>【操作系统原理】 Lecture 17 同步互斥 | remy-campanella.github.io</title><meta name="author" content="Remy Campanella"><meta name="copyright" content="Remy Campanella"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、背景与并发问题 1. 并发的好处与挑战  好处：并发执行可以充分利用多核CPU资源，提高系统吞吐量和响应速度。 挑战：并发进程共享资源时，如果协调不当，会导致竞态条件，即程序的最终结果依赖于进程执行的相对时序，从而产生不可预测的错误。  2. 竞态条件示例：PID分配 幻灯片中给出了一个经典的例子：两个进程A和B同时尝试获取下一个进程ID（next_pid）。  错误场景：  进程A加载nex">
<meta property="og:type" content="article">
<meta property="og:title" content="【操作系统原理】 Lecture 17 同步互斥">
<meta property="og:url" content="https://remy-campanella.github.io/2025/11/05/25-11-5-13-OpSys-sync-excl/index.html">
<meta property="og:site_name" content="remy-campanella.github.io">
<meta property="og:description" content="一、背景与并发问题 1. 并发的好处与挑战  好处：并发执行可以充分利用多核CPU资源，提高系统吞吐量和响应速度。 挑战：并发进程共享资源时，如果协调不当，会导致竞态条件，即程序的最终结果依赖于进程执行的相对时序，从而产生不可预测的错误。  2. 竞态条件示例：PID分配 幻灯片中给出了一个经典的例子：两个进程A和B同时尝试获取下一个进程ID（next_pid）。  错误场景：  进程A加载nex">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://remy-campanella.github.io/image/background/remy.jpg">
<meta property="article:published_time" content="2025-11-05T01:36:28.000Z">
<meta property="article:modified_time" content="2025-11-05T01:36:28.479Z">
<meta property="article:author" content="Remy Campanella">
<meta property="article:tag" content="学习笔记">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://remy-campanella.github.io/image/background/remy.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "【操作系统原理】 Lecture 17 同步互斥",
  "url": "https://remy-campanella.github.io/2025/11/05/25-11-5-13-OpSys-sync-excl/",
  "image": "https://remy-campanella.github.io/image/background/remy.jpg",
  "datePublished": "2025-11-05T01:36:28.000Z",
  "dateModified": "2025-11-05T01:36:28.479Z",
  "author": [
    {
      "@type": "Person",
      "name": "Remy Campanella",
      "url": "https://remy-campanella.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/image/icon/icon.png"><link rel="canonical" href="https://remy-campanella.github.io/2025/11/05/25-11-5-13-OpSys-sync-excl/index.html"><link rel="preconnect" href="https://unpkg.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@7.0.1/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://unpkg.com/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【操作系统原理】 Lecture 17 同步互斥',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/scripts/css/font.css"><!-- hexo injector head_end start -->
    <link rel="stylesheet" href="/css/gallery.css" media="print" onload="this.media='all'">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/image/icon/loading.gif" data-original="/image/icon/Cover.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about"><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/album"><span> 图库</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/image/background/remy.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/image/icon/loading.gif" data-original="/image/icon/icon.png" alt="Logo"><span class="site-name">remy-campanella.github.io</span></a><a class="nav-page-title" href="/"><span class="site-name">【操作系统原理】 Lecture 17 同步互斥</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about"><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/album"><span> 图库</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">【操作系统原理】 Lecture 17 同步互斥</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-11-05T01:36:28.000Z" title="发表于 2025-11-05 09:36:28">2025-11-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-11-05T01:36:28.479Z" title="更新于 2025-11-05 09:36:28">2025-11-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">操作系统原理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="一、背景与并发问题"><strong>一、背景与并发问题</strong></h3>
<h4 id="1-并发的好处与挑战"><strong>1. 并发的好处与挑战</strong></h4>
<ul class="lvl-0">
<li class="lvl-2"><strong>好处</strong>：并发执行可以充分利用多核CPU资源，提高系统吞吐量和响应速度。</li>
<li class="lvl-2"><strong>挑战</strong>：并发进程共享资源时，如果协调不当，会导致<strong>竞态条件</strong>，即程序的最终结果依赖于进程执行的相对时序，从而产生不可预测的错误。</li>
</ul>
<h4 id="2-竞态条件示例：PID分配"><strong>2. 竞态条件示例：PID分配</strong></h4>
<p>幻灯片中给出了一个经典的例子：两个进程A和B同时尝试获取下一个进程ID（<code>next_pid</code>）。</p>
<ul class="lvl-0">
<li class="lvl-2"><strong>错误场景</strong>：
<ol>
<li class="lvl-6">进程A加载<code>next_pid</code>（值为100）到寄存器。</li>
<li class="lvl-6"><strong>发生上下文切换</strong>，进程B运行。</li>
<li class="lvl-6">进程B加载<code>next_pid</code>（仍为100），将其分配给<code>new_pid</code>，然后递增<code>next_pid</code>为101并写回。</li>
<li class="lvl-6"><strong>上下文切换回进程A</strong>。</li>
<li class="lvl-6">进程A继续执行，将寄存器中的100分配给它的<code>new_pid</code>，然后递增<code>next_pid</code>为101并写回。</li>
</ol>
</li>
<li class="lvl-2"><strong>结果</strong>：两个进程获得了相同的PID（100），系统状态出错。</li>
<li class="lvl-2"><strong>根本原因</strong>：<code>load -&gt; store -&gt; inc -&gt; store</code>这个序列不是一个<strong>原子操作</strong>，它在执行过程中被中断，导致了不一致的状态。</li>
</ul>
<hr>
<h3 id="二、现实生活中的同步问题与临界区"><strong>二、现实生活中的同步问题与临界区</strong></h3>
<h4 id="1-家庭采购协调问题"><strong>1. 家庭采购协调问题</strong></h4>
<p>这个生动的例子模拟了两个线程（丈夫和妻子）协调购买面包的场景，揭示了同步问题的复杂性。</p>
<ul class="lvl-0">
<li class="lvl-2"><strong>问题</strong>：两人约定，如果家里没面包，就去买。但可能两人都发现没面包，然后都去买，导致买了两个面包。</li>
<li class="lvl-2"><strong>方案演进</strong>：
<ul class="lvl-2">
<li class="lvl-4"><strong>方案一（检查再标记）</strong>：<code>if (nobread) &#123; if (noNote) &#123; leave Note; buy bread; remove Note; &#125; &#125;</code>。失败，因为“检查”和“标记”之间可能被中断。</li>
<li class="lvl-4"><strong>方案二（先标记再检查）</strong>：<code>leave Note; if (nobread) &#123; ... &#125;</code>。失败，可能导致两人都留下便条，然后都去买。</li>
<li class="lvl-4"><strong>方案三（双标记）</strong>：使用两个便条。仍然复杂且容易出错。</li>
</ul>
</li>
<li class="lvl-2"><strong>最终解决方案（方案五）</strong>：引入一个<strong>锁</strong>（<code>breadlock</code>）。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">breadlock.Acquire(); <span class="comment">// 获取锁</span></span><br><span class="line"><span class="keyword">if</span> (nobread) &#123;</span><br><span class="line">    buy bread; <span class="comment">// 临界区</span></span><br><span class="line">&#125;</span><br><span class="line">breadlock.Release(); <span class="comment">// 释放锁</span></span><br></pre></td></tr></table></figure>
这个方案将“检查并购买”这个不可分割的操作保护起来，确保任何时候只有一个人能执行。</li>
</ul>
<h4 id="2-临界区"><strong>2. 临界区</strong></h4>
<ul class="lvl-0">
<li class="lvl-2"><strong>定义</strong>：进程中访问<strong>共享资源</strong>的一段代码。</li>
<li class="lvl-2"><strong>相关区域</strong>：
<ul class="lvl-2">
<li class="lvl-4"><strong>进入区</strong>：在进入临界区前，检查是否可以安全进入，如果不能则等待。</li>
<li class="lvl-4"><strong>退出区</strong>：在离开临界区后，清理状态，允许其他进程进入。</li>
<li class="lvl-4"><strong>剩余区</strong>：进程的其他代码。</li>
</ul>
</li>
</ul>
<h4 id="3-临界区的访问规则"><strong>3. 临界区的访问规则</strong></h4>
<p>一个正确的临界区解决方案必须满足以下四个条件：</p>
<ol>
<li class="lvl-4"><strong>空闲则入</strong>：如果临界区空闲，必须允许一个请求进入的进程立即进入。</li>
<li class="lvl-4"><strong>忙则等待</strong>：如果临界区正在被使用，其他请求进入的进程必须等待。</li>
<li class="lvl-4"><strong>有限等待</strong>：一个进程不能无限期地被禁止进入临界区（避免饥饿）。</li>
<li class="lvl-4"><strong>让权等待</strong>（可选，但推荐）：等待进入临界区的进程应该放弃CPU（进入阻塞），而不是忙等待，以浪费CPU时间。</li>
</ol>
<hr>
<h3 id="三、临界区的实现方法"><strong>三、临界区的实现方法</strong></h3>
<p>幻灯片介绍了三种不同层次的实现方法，从简单粗暴到高效抽象。</p>
<h4 id="方法1：禁用硬件中断"><strong>方法1：禁用硬件中断</strong></h4>
<ul class="lvl-0">
<li class="lvl-2"><strong>原理</strong>：在单核CPU上，进程切换是由时钟中断触发的。通过在进入临界区前禁用所有中断，在退出后重新开启，可以保证临界区代码不会被中断，从而原子执行。</li>
<li class="lvl-2"><strong>实现</strong>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">local_irq_save(flags); <span class="comment">// 保存状态并禁用中断</span></span><br><span class="line"><span class="comment">// critical section</span></span><br><span class="line">local_irq_restore(flags); <span class="comment">// 恢复状态并开启中断</span></span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2"><strong>缺点</strong>：
<ul class="lvl-2">
<li class="lvl-4"><strong>滥用特权</strong>：这是一个非常粗暴的方法，应该只由内核在极少数情况下使用。</li>
<li class="lvl-4"><strong>不适用于多处理器</strong>：禁用一个CPU的中断，其他CPU上的进程仍然可以访问临界区。</li>
<li class="lvl-4"><strong>影响系统响应</strong>：长时间禁用中断会导致系统对其他事件（如I/O）失去响应。</li>
</ul>
</li>
</ul>
<h4 id="方法2：基于软件的解决方法"><strong>方法2：基于软件的解决方法</strong></h4>
<p>这种方法不依赖特殊硬件指令，仅通过共享变量和算法来实现同步。</p>
<ul class="lvl-0">
<li class="lvl-2"><strong>Peterson算法</strong>（适用于两个进程）：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 共享变量</span></span><br><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>] = &#123;<span class="literal">false</span>, <span class="literal">false</span>&#125;;</span><br><span class="line"><span class="type">int</span> turn;</span><br><span class="line"><span class="comment">// 进程i的代码</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    flag[i] = <span class="literal">true</span>;   <span class="comment">// 我想进入</span></span><br><span class="line">    turn = j;         <span class="comment">// 礼让，让对方先</span></span><br><span class="line">    <span class="keyword">while</span> (flag[j] &amp;&amp; turn == j); <span class="comment">// 如果对方也想进且轮到对方，则等待</span></span><br><span class="line">    <span class="comment">// critical section</span></span><br><span class="line">    flag[i] = <span class="literal">false</span>;  <span class="comment">// 我出来了</span></span><br><span class="line">    <span class="comment">// remainder section</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
</li>
<li class="lvl-2"><strong>优点</strong>：证明了纯软件解决方案的可行性。</li>
<li class="lvl-2"><strong>缺点</strong>：
<ul class="lvl-2">
<li class="lvl-4"><strong>复杂</strong>：算法逻辑复杂，难以理解和验证正确性。</li>
<li class="lvl-4"><strong>扩展性差</strong>：难以扩展到N个进程。</li>
<li class="lvl-4"><strong>忙等待</strong>：<code>while</code>循环会持续消耗CPU时间。</li>
</ul>
</li>
</ul>
<h4 id="方法3：更高级的抽象方法（硬件支持）"><strong>方法3：更高级的抽象方法（硬件支持）</strong></h4>
<p>这是现代操作系统采用的主流方法，它结合了特殊的硬件原子指令和操作系统提供的数据结构。</p>
<ul class="lvl-0">
<li class="lvl-2"><strong>硬件原子指令</strong>：
<ul class="lvl-2">
<li class="lvl-4"><strong>Test-and-Set (TS)</strong>：原子地读取内存位置并设置为<code>true</code>。</li>
<li class="lvl-4"><strong>Exchange</strong>：原子地交换两个内存位置的值。</li>
</ul>
</li>
<li class="lvl-2"><strong>自旋锁</strong>：
<ul class="lvl-2">
<li class="lvl-4">使用TS指令实现。<code>Acquire</code>操作在一个循环中不断执行TS，直到锁被释放。</li>
<li class="lvl-4"><strong>缺点</strong>：仍然是忙等待，适用于临界区非常短（持有锁时间小于一次上下文切换时间）的场景。</li>
</ul>
</li>
<li class="lvl-2"><strong>无忙等待锁</strong>：
<ul class="lvl-2">
<li class="lvl-4">在自旋锁的基础上改进。当获取锁失败时，不忙等待，而是将当前进程加入等待队列并<strong>阻塞</strong>（调用<code>schedule()</code>），让出CPU。</li>
<li class="lvl-4">当锁被释放时，<code>Release</code>操作会从等待队列中唤醒一个进程。</li>
</ul>
</li>
<li class="lvl-2"><strong>优点</strong>：
<ul class="lvl-2">
<li class="lvl-4"><strong>高效</strong>：避免了忙等待，提高了CPU利用率。</li>
<li class="lvl-4"><strong>简单易用</strong>：为程序员提供了简单、高级的同步原语（如锁、信号量）。</li>
<li class="lvl-4"><strong>通用性强</strong>：适用于多处理器环境。</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://remy-campanella.github.io">Remy Campanella</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://remy-campanella.github.io/2025/11/05/25-11-5-13-OpSys-sync-excl/">https://remy-campanella.github.io/2025/11/05/25-11-5-13-OpSys-sync-excl/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://remy-campanella.github.io" target="_blank">remy-campanella.github.io</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post-share"><div class="social-share" data-image="/image/background/remy.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://unpkg.com/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://unpkg.com/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/11/05/25-11-5-14-OpSys-sema-tube/" title="【操作系统原理】 Lecture 18 信号量与管程"><img class="cover" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">【操作系统原理】 Lecture 18 信号量与管程</div></div><div class="info-2"><div class="info-item-1">一、信号量 信号量是由 Dijkstra 提出的更强大、更通用的同步原语。 1. 基本概念  定义：一个整型变量，只能通过两个标准的原子操作来访问：P操作（Proberen，测试/等待）和V操作（Verhogen，增加/信号）。 组成：  一个整型值 sem。 一个等待队列 q，用于存放阻塞的进程。    2. P/V操作实现 1234567891011121314Semaphore::P() &#123; // 等待/申请资源    sem--;    if (sem &lt; 0) &#123; // 资源不足        Add this thread t to q; // 将当前线程加入等待队列        block(p); // 阻塞当前线程    &#125;&#125;Semaphore::V() &#123; // 释放/提供资源    sem++;    if (sem &lt;= 0) &#123; // 有线程在等待        Remove a thread t from q; // 从等待队列中取出一个线程        wakeup(t); /...</div></div></div></a><a class="pagination-related" href="/2025/11/05/25-11-5-12-OpSys-exp6-sche/" title="【操作系统原理】 Lecture 16 实验六 调度器"><img class="cover" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">【操作系统原理】 Lecture 16 实验六 调度器</div></div><div class="info-2"><div class="info-item-1">一、总体介绍与目标 1. 实验背景 在Lab5中，ucore已经能够创建和管理用户进程，但其调度机制非常原始：idle进程通过遍历进程池来寻找下一个可运行的进程，效率低下且缺乏公平性。Lab6的目标是重新设计并实现一个通用、高效的调度框架。 2. 实验目标  理解调度管理机制：掌握调度的完整流程，包括触发、选择、切换。 熟悉ucore调度框架：理解其模块化设计，特别是sched_class接口。 实现经典调度算法：  分析并理解Round Robin (RR) 算法的实现。 亲手实现Stride调度算法，这是一种公平的比例份额调度算法。     二、调度过程 调度过程是调度器工作的核心流程，可以分解为一系列标准化的步骤：  触发：某个事件发生，表明需要进行调度决策。例如：  时钟中断，当前进程时间片用完。 当前进程因I/O阻塞。 一个新进程被创建，变为就绪态。   入队：如果当前进程仍然是PROC_RUNNABLE状态，则需要将其重新放回就绪队列，等待下一次调度。 选取：调度算法的核心。从就绪队列中，根据特定策略（如RR、Stride）选择下一个要运行的进程。 出队：将选中的进程...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/11/05/25-11-3-4-OpSys-intro/" title="【操作系统原理】 Lecture 1 课程概述"><img class="cover" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-05</div><div class="info-item-2">【操作系统原理】 Lecture 1 课程概述</div></div><div class="info-2"><div class="info-item-1">一、课程目标与意义  学习目的  掌握操作系统（OS）的基本原理与实现技术。 通过开发小型OS实践核心阶段（如中断处理、内存管理）。 深化对计算机系统的整体理解，提升知识应用能力。   OS的重要性  计算机科学的基石，连接硬件、软件与应用的核心支撑。 贯穿程序语言、编译、体系结构等领域，影响专业素质。    二、课程结构与内容   核心教学内容  OS结构、中断与系统调用、内存管理、进程/线程、调度、同步互斥、文件系统、I/O子系统。    实验与实践  实验序列：环境准备→系统启动→物理/虚拟内存管理→内核线程→用户进程→调度→同步→文件系统。 课程设计：基于RISC-V的ucore OS内核开发。    参考教材  《Operating System Concepts》（恐龙书） 《Operating Systems: Three Easy Pieces》（OSTEP）    三、操作系统核心概念   定义与地位  OS是管理硬件资源、提供用户接口的系统软件，位于硬件与应用之间（承上启下）。    内核特征  并发：多程序同时运行，需调度管理。 共享：资源互斥或同时访问。 ...</div></div></div></a><a class="pagination-related" href="/2025/11/05/25-11-3-8-OpSys-phy-mem-con/" title="【操作系统原理】 Lecture 5 物理内存管理：连续内存分配"><img class="cover" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-05</div><div class="info-item-2">【操作系统原理】 Lecture 5 物理内存管理：连续内存分配</div></div><div class="info-2"><div class="info-item-1">一、计算机体系结构与内存层次 计算机体系结构  基础：基于Intel® 64和IA-32架构，参考官方手册（Intel® 64 and IA-32 Architectures Software Developer Manuals）。 核心组件：   CPU：执行指令，生成逻辑地址。 MMU（内存管理单元）：将逻辑地址转换为物理地址，支持分段和分页。 总线：连接CPU、内存和外设。  内存层次  结构：   高速缓存（Cache）：速度快，容量小，减少CPU访问内存延迟。 主存（RAM）：存放运行中的程序和数据。 外存（磁盘）：持久化存储，用于交换分区（Swapping）。   性能问题：   高速缓存未命中：需从主存加载数据，延迟增加。 缺页（Page Fault）：虚拟内存机制中，访问未加载的页需从磁盘读取。  二、操作系统的内存管理方式 管理方式分类    方式 特点 应用场景     重定位 程序加载时调整地址，适应内存位置 早期单任务系统   分段 按逻辑模块划分段（如代码段、数据段），支持地址隔离 Intel x86保护模式   分页 将内存划分为固定大小的页，减少外部...</div></div></div></a><a class="pagination-related" href="/2025/11/05/25-11-3-6-OpSys-interrupt/" title="【操作系统原理】 Lecture 3 启动中断异常系统调用"><img class="cover" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-05</div><div class="info-item-2">【操作系统原理】 Lecture 3 启动中断异常系统调用</div></div><div class="info-2"><div class="info-item-1">一、计算机启动流程  启动前的硬件状态  CPU状态：PC指向固定地址（如x86的0xFFFF0），处于特权态（实模式），地址空间有限（x86为1MB）。 内存布局：BIOS固件位于高地址区域，低地址为加载程序预留空间。 初始化：硬件自检（POST）、内存控制器初始化、寄存器复位。   启动阶段  BIOS阶段：  执行自检程序，初始化硬件（如键盘、串口）。 加载磁盘引导扇区（512字节）到内存0x7C00，跳转执行。   Bootloader阶段：  加载操作系统内核到内存，跳转至OS入口。   OS初始化：  初始化数据结构、外设驱动，建立中断处理机制。     启动规范  传统BIOS：MBR（主引导记录）→ 分区引导扇区 → OS加载。 UEFI：更现代的固件接口，支持安全启动和大容量磁盘。    二、中断、异常与系统调用   定义与分类    类型 触发方式 示例（x86）     中断 外部设备信号（如键盘、时钟） INTR（可屏蔽）、NMI（不可屏蔽）   异常 CPU执行指令时的错误或特殊事件 页故障（#PF）、除零错误（#DE）   系统调用 用户程序主动请求内...</div></div></div></a><a class="pagination-related" href="/2025/11/05/25-11-3-5-OpSys-exp0-env/" title="【操作系统原理】 Lecture 2 实验零 操作实验系统实验环境准备"><img class="cover" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-05</div><div class="info-item-2">【操作系统原理】 Lecture 2 实验零 操作实验系统实验环境准备</div></div><div class="info-2"><div class="info-item-1">一、了解操作系统（OS）  核心概念  特权机制：CPU通过特权级（如CPL=0为最高特权）保护系统安全，特权指令（如LIDT、MOV CRn）只能在特权态执行，否则触发异常。 中断与异常管理：包括外设中断、陷阱中断（如系统调用）和故障中断（如缺页异常）。 内存管理：  分段（Segmentation）和分页（Paging）机制，实现虚拟内存（Virtual Memory）。 硬件支持：TLB（快表）、MMU（内存管理单元）。     OS设计目标  高效管理硬件资源（CPU、内存、外设）。 提供系统调用接口，实现用户态与内核态切换。    二、了解硬件   计算机体系结构  图灵机模型：有限状态机，通过读写符号和状态转换实现计算。 冯·诺依曼架构：  组成：CPU（寄存器、执行单元）、内存、磁盘、键盘、显示器等。 特点：存储程序，指令与数据共享内存。      x86硬件特性  特权指令：仅当CPL=0时可执行，否则触发通用保护异常（如LGDT、STI）。 关键组件：  BIOS ROM（启动固件）、时钟（中断源）、地址/数据信号线。   实验环境：ucore OS基于x86架...</div></div></div></a><a class="pagination-related" href="/2025/11/05/25-11-3-7-OpSys-exp1-bootloader/" title="【操作系统原理】 Lecture 4 实验一 Bootloader 启动 ucore OS"><img class="cover" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-05</div><div class="info-item-2">【操作系统原理】 Lecture 4 实验一 Bootloader 启动 ucore OS</div></div><div class="info-2"><div class="info-item-1">一、x86启动顺序 启动流程  BIOS阶段   初始状态：CS=0xF000, EIP=0xFFF0，物理地址为0xFFFFFFF0（BIOS EPROM位置）。 第一条指令：长跳转（JMP）到BIOS代码区，更新CS:EIP。   加载Bootloader   BIOS将存储设备（硬盘/USB）的**主引导扇区（MBR，512字节）**加载到内存0x7C00，并跳转执行。   Bootloader任务   使能保护模式：设置CR0寄存器的PE位（Bit 0）。 加载内核：从硬盘读取ELF格式的ucore内核到内存固定位置。 跳转执行：跳转到ucore入口点，移交控制权。  实模式与保护模式  实模式（历史背景）   寻址方式：段基址:偏移量（如CS:IP），物理地址 = 段基址*16 + 偏移量。 限制：20位地址总线，最大1MB空间（0x00000~0xFFFFF），无保护机制。 中断处理：中断向量表（IVT）位于内存低地址，INT n通过N*4获取ISR地址。   保护模式   段机制：通过**全局描述符表（GDT）**管理段基址和权限，lgdt指令加载GDT。 特权级：...</div></div></div></a><a class="pagination-related" href="/2025/11/05/25-11-5-1-OpSys-phy-mem-man-discon/" title="【操作系统原理】 Lecture 6 物理内存管理：非连续内存分配"><img class="cover" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-05</div><div class="info-item-2">【操作系统原理】 Lecture 6 物理内存管理：非连续内存分配</div></div><div class="info-2"><div class="info-item-1">一、非连续内存分配的需求背景 设计目标  解决连续分配的缺陷：  外部碎片：内存中存在大量不连续的小空闲块，难以利用。 内部碎片：分配的块大于实际需求（如伙伴系统）。   支持灵活的内存布局：  允许程序代码、数据、堆栈等分散在物理内存的不同位置。 便于实现内存共享和保护（如共享库）。    实现方式  段式管理：按逻辑模块划分内存（如代码段、数据段）。 页式管理：将内存划分为固定大小的页，按需分配。 段页式管理：结合段式逻辑划分与页式物理分配。  二、段式存储管理 段地址空间   逻辑结构：  进程地址空间由多个段组成，如：  主代码段、子模块代码段、堆栈段、堆数据段。   二维地址：(段号, 段内偏移)。    非连续性：  各段可独立加载到物理内存的任意位置，无需连续。    段访问机制   硬件实现：  逻辑地址：(段选择子, 偏移量)。 段表（GDT/LDT）：存储段基址和段限长。 地址转换：  物理地址 = 段基址 + 偏移量。 检查偏移量是否超过段限长，否则触发异常。      优点：  支持内存共享（如多个进程共享代码段）。 便于模块化编程和保护。    缺点： ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/image/icon/loading.gif" data-original="/image/icon/Cover.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Remy Campanella</div><div class="author-info-description">A Remy Campanella blog website on Github.</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/remy-campanella"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站介绍帖、自我介绍帖内容已移至“关于”页面，目录帖内容已移至“分类”页面。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%83%8C%E6%99%AF%E4%B8%8E%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">一、背景与并发问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%B9%B6%E5%8F%91%E7%9A%84%E5%A5%BD%E5%A4%84%E4%B8%8E%E6%8C%91%E6%88%98"><span class="toc-number">1.1.</span> <span class="toc-text">1. 并发的好处与挑战</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6%E7%A4%BA%E4%BE%8B%EF%BC%9APID%E5%88%86%E9%85%8D"><span class="toc-number">1.2.</span> <span class="toc-text">2. 竞态条件示例：PID分配</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%8E%B0%E5%AE%9E%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98%E4%B8%8E%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="toc-number">2.</span> <span class="toc-text">二、现实生活中的同步问题与临界区</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%B6%E5%BA%AD%E9%87%87%E8%B4%AD%E5%8D%8F%E8%B0%83%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.</span> <span class="toc-text">1. 家庭采购协调问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="toc-number">2.2.</span> <span class="toc-text">2. 临界区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%B8%B4%E7%95%8C%E5%8C%BA%E7%9A%84%E8%AE%BF%E9%97%AE%E8%A7%84%E5%88%99"><span class="toc-number">2.3.</span> <span class="toc-text">3. 临界区的访问规则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%B8%B4%E7%95%8C%E5%8C%BA%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">三、临界区的实现方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%951%EF%BC%9A%E7%A6%81%E7%94%A8%E7%A1%AC%E4%BB%B6%E4%B8%AD%E6%96%AD"><span class="toc-number">3.1.</span> <span class="toc-text">方法1：禁用硬件中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%952%EF%BC%9A%E5%9F%BA%E4%BA%8E%E8%BD%AF%E4%BB%B6%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">方法2：基于软件的解决方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%953%EF%BC%9A%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%EF%BC%88%E7%A1%AC%E4%BB%B6%E6%94%AF%E6%8C%81%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">方法3：更高级的抽象方法（硬件支持）</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/11/19/25-11-19-1-COMPSCI220-asym-not/" title="【COMPSCI 220】Lecture 4 Asymptotic notations"><img src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【COMPSCI 220】Lecture 4 Asymptotic notations"/></a><div class="content"><a class="title" href="/2025/11/19/25-11-19-1-COMPSCI220-asym-not/" title="【COMPSCI 220】Lecture 4 Asymptotic notations">【COMPSCI 220】Lecture 4 Asymptotic notations</a><time datetime="2025-11-19T01:13:20.000Z" title="发表于 2025-11-19 09:13:20">2025-11-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/11/19/25-11-4-3-COMSCI220-esti-run-time/" title="【COMPSCI 220】 Lecture 3 How to Estimate Running Time?"><img src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【COMPSCI 220】 Lecture 3 How to Estimate Running Time?"/></a><div class="content"><a class="title" href="/2025/11/19/25-11-4-3-COMSCI220-esti-run-time/" title="【COMPSCI 220】 Lecture 3 How to Estimate Running Time?">【COMPSCI 220】 Lecture 3 How to Estimate Running Time?</a><time datetime="2025-11-19T00:38:52.000Z" title="发表于 2025-11-19 08:38:52">2025-11-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/11/19/25-11-4-2-COMPSCI220-run-time/" title="【COMPSCI 220】 Lecture 2 How to Measure Running Time?"><img src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【COMPSCI 220】 Lecture 2 How to Measure Running Time?"/></a><div class="content"><a class="title" href="/2025/11/19/25-11-4-2-COMPSCI220-run-time/" title="【COMPSCI 220】 Lecture 2 How to Measure Running Time?">【COMPSCI 220】 Lecture 2 How to Measure Running Time?</a><time datetime="2025-11-19T00:12:57.000Z" title="发表于 2025-11-19 08:12:57">2025-11-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/11/19/25-11-4-1-COMPSCI220-intro/" title="【COMPSCI 220】 Lecture 1 What is a Algorithm and Why Analyse It?"><img src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【COMPSCI 220】 Lecture 1 What is a Algorithm and Why Analyse It?"/></a><div class="content"><a class="title" href="/2025/11/19/25-11-4-1-COMPSCI220-intro/" title="【COMPSCI 220】 Lecture 1 What is a Algorithm and Why Analyse It?">【COMPSCI 220】 Lecture 1 What is a Algorithm and Why Analyse It?</a><time datetime="2025-11-19T00:05:38.000Z" title="发表于 2025-11-19 08:05:38">2025-11-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/11/05/25-11-5-14-OpSys-sema-tube/" title="【操作系统原理】 Lecture 18 信号量与管程"><img src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【操作系统原理】 Lecture 18 信号量与管程"/></a><div class="content"><a class="title" href="/2025/11/05/25-11-5-14-OpSys-sema-tube/" title="【操作系统原理】 Lecture 18 信号量与管程">【操作系统原理】 Lecture 18 信号量与管程</a><time datetime="2025-11-05T01:36:42.000Z" title="发表于 2025-11-05 09:36:42">2025-11-05</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Remy Campanella</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.0</a></span></div><div class="footer_custom_text">源代码库版本 1.4.0</div></div><script type="text/javascript" id="maid-script" src="https://unpkg.com/mermaid@9.0.0/dist/mermaid.min.js"></script><script>if (window.mermaid) {
  var options = JSON.parse(document.getElementById('maid-script').getAttribute('mermaidoptioins'));
  mermaid.initialize(options);
}</script></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        loader: {
          load: [
            // Four font extension packages (optional)
            //- '[tex]/bbm',
            //- '[tex]/bboldx',
            //- '[tex]/dsfont',
            '[tex]/mhchem'
          ],
          paths: {
            'mathjax-newcm': '[mathjax]/../@mathjax/mathjax-newcm-font',

            //- // Four font extension packages (optional)
            //- 'mathjax-bbm-extension': '[mathjax]/../@mathjax/mathjax-bbm-font-extension',
            //- 'mathjax-bboldx-extension': '[mathjax]/../@mathjax/mathjax-bboldx-font-extension',
            //- 'mathjax-dsfont-extension': '[mathjax]/../@mathjax/mathjax-dsfont-font-extension',
            'mathjax-mhchem-extension': '[mathjax]/../@mathjax/mathjax-mhchem-font-extension'
          }
        },
        output: {
          font: 'mathjax-newcm',
        },
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
          packages: {
            '[+]': [
              'mhchem'
            ]
          }
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          menuOptions: {
            settings: {
              enrich: false  // Turn off Braille and voice narration text automatic generation
            }
          },
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://unpkg.com/mathjax@4.0.0/tex-mml-chtml.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://unpkg.com/mermaid@11.11.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start -->
    <script src="/js/gallery.js" async></script>
<!-- hexo injector body_end end -->
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 2,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>