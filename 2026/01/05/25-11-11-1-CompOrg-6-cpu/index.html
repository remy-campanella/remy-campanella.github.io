<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>【计算机组成原理】 第六章 中央处理器 | remy-campanella.github.io</title><meta name="author" content="Remy Campanella"><meta name="copyright" content="Remy Campanella"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="6.1 中央处理器的功能和组成 6.1.1 CPU 的功能 程序运行过程中，在计算机的各部分之间流动的指令和数据形成指令流和数据流。  指令流：CPU 的指令序列。 数据流：根据指令操作要求依次存取的数据的序列。  6.1.2 CPU 中的主要寄存器  通用寄存器  累加寄存器（Acc） Acc 用于暂时存放 ALU 运算的结果信息。  专用寄存器  程序计数器（P">
<meta property="og:type" content="article">
<meta property="og:title" content="【计算机组成原理】 第六章 中央处理器">
<meta property="og:url" content="https://remy-campanella.github.io/2026/01/05/25-11-11-1-CompOrg-6-cpu/index.html">
<meta property="og:site_name" content="remy-campanella.github.io">
<meta property="og:description" content="6.1 中央处理器的功能和组成 6.1.1 CPU 的功能 程序运行过程中，在计算机的各部分之间流动的指令和数据形成指令流和数据流。  指令流：CPU 的指令序列。 数据流：根据指令操作要求依次存取的数据的序列。  6.1.2 CPU 中的主要寄存器  通用寄存器  累加寄存器（Acc） Acc 用于暂时存放 ALU 运算的结果信息。  专用寄存器  程序计数器（P">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://remy-campanella.github.io/image/background/remy.jpg">
<meta property="article:published_time" content="2026-01-05T02:46:54.000Z">
<meta property="article:modified_time" content="2026-01-05T09:20:13.095Z">
<meta property="article:author" content="Remy Campanella">
<meta property="article:tag" content="计算机组成原理">
<meta property="article:tag" content="学习笔记">
<meta property="article:tag" content="基础知识">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://remy-campanella.github.io/image/background/remy.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "【计算机组成原理】 第六章 中央处理器",
  "url": "https://remy-campanella.github.io/2026/01/05/25-11-11-1-CompOrg-6-cpu/",
  "image": "https://remy-campanella.github.io/image/background/remy.jpg",
  "datePublished": "2026-01-05T02:46:54.000Z",
  "dateModified": "2026-01-05T09:20:13.095Z",
  "author": [
    {
      "@type": "Person",
      "name": "Remy Campanella",
      "url": "https://remy-campanella.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/image/icon/icon.png"><link rel="canonical" href="https://remy-campanella.github.io/2026/01/05/25-11-11-1-CompOrg-6-cpu/index.html"><link rel="preconnect" href="https://unpkg.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@7.0.1/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://unpkg.com/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【计算机组成原理】 第六章 中央处理器',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/scripts/css/font.css"><!-- hexo injector head_end start -->
    <link rel="stylesheet" href="/css/gallery.css" media="print" onload="this.media='all'">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/image/icon/loading.gif" data-original="/image/icon/Cover.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">70</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about"><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/album"><span> 图库</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/image/background/remy.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/image/icon/loading.gif" data-original="/image/icon/icon.png" alt="Logo"><span class="site-name">remy-campanella.github.io</span></a><a class="nav-page-title" href="/"><span class="site-name">【计算机组成原理】 第六章 中央处理器</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about"><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/album"><span> 图库</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">【计算机组成原理】 第六章 中央处理器</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2026-01-05T02:46:54.000Z" title="发表于 2026-01-05 10:46:54">2026-01-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-01-05T09:20:13.095Z" title="更新于 2026-01-05 17:20:13">2026-01-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="中央处理器的功能和组成">6.1 中央处理器的功能和组成</h2>
<h3 id="cpu-的功能">6.1.1 CPU 的功能</h3>
<p>程序运行过程中，在计算机的各部分之间流动的指令和数据形成<strong>指令流</strong>和<strong>数据流</strong>。</p>
<ul>
<li><strong>指令流</strong>：CPU 的指令序列。</li>
<li><strong>数据流</strong>：根据指令操作要求依次存取的数据的序列。</li>
</ul>
<h3 id="cpu-中的主要寄存器">6.1.2 CPU 中的主要寄存器</h3>
<ol type="1">
<li><strong>通用寄存器</strong>
<ul>
<li><strong>累加寄存器（Acc）</strong><br />
Acc 用于暂时存放 ALU 运算的结果信息。</li>
</ul></li>
<li><strong>专用寄存器</strong>
<ul>
<li><strong>程序计数器（PC）</strong>
<ul>
<li>顺序执行时，PC 内容每次<strong>自增（自动或运算器实现）</strong>。</li>
<li>改变执行顺序时，将转移的<strong>目标地址</strong>送往寄存器。有时还要<strong>保留改变前的内容</strong>，以便返回时使用。</li>
</ul></li>
<li><strong>指令寄存器（IR）</strong><br />
存放从存储器中取出的指令。<br />
执行指令时，IR 内容<strong>不可变</strong>。</li>
<li><strong>存储器数据寄存器（MDR）</strong><br />
暂存由主存储器读出（或将写入主存）的一条指令或数据字。</li>
<li><strong>存储器地址寄存器（MAR）</strong><br />
当前 CPU 访问的主存单元地址。CPU 与主存有速度差别，MAR 可用于调和速度差异。</li>
<li><strong>程序状态字寄存器（状态标志寄存器，PSWR）</strong><br />
存放<strong>程序状态字（PSR）</strong>。PSR 的位数往往等于机器字长。</li>
</ul></li>
</ol>
<h3 id="cpu-的组成">6.1.3 CPU 的组成</h3>
<p><img src="/image/icon/loading.gif" data-original="/image/25-11-11-1-CompOrg-6-cpu/1762861580587.webp" /></p>
<ul>
<li><strong>控制器</strong>
<ul>
<li>从主存中取一条指令，指出下一条指令位置。</li>
<li>译码或测试指令，产生操作控制信号。</li>
<li>控制 CPU、主存和 IO 设备的数据流方向。</li>
</ul></li>
<li><strong>运算器</strong>
<ul>
<li>算数运算。</li>
<li>逻辑运算与测试。</li>
</ul></li>
</ul>
<h3 id="cpu-的主要技术参数">6.1.4 CPU 的主要技术参数</h3>
<ol type="1">
<li><p><strong>字长</strong><br />
单位时间内同时处理的二进制数据的位数。</p></li>
<li><p><strong>内部工作频率（内频、主频）</strong><br />
CPU 内<strong>数字脉冲信号</strong>震荡的速度，一般为 MHz、GHz 级。与 CPU 性能存在一定关系，但不绝对。</p></li>
<li><p><strong>外部工作频率</strong><br />
<strong>主板</strong>为 CPU 提供的<strong>基准时钟</strong>频率，百 MHz 级。随着工艺发展，CPU 与其他设备速度差距越来越明显，出现<strong>内部倍频技术</strong>。<br />
<span class="math display">\[
\text{内频} = \text{外频} \times \text{倍频}
\]</span></p></li>
<li><p><strong>前端总线（FSB）频率</strong><br />
前端总线是 CPU 与外界芯片（北桥）交换数据的通道，连接吞吐率高的部件。随着计算机发展，前端总线频率需要高于外屏，采用 QDR 等技术。<br />
<span class="math display">\[
数据带宽 = 总线频率 \times 数据位宽 \div 8
\]</span></p>
<p>FSB 速度一般为百至千 MHz 级。</p></li>
<li><p><strong>QPI 数据传输速率</strong><br />
QPI 是基于包传输的高速点到点连接技术，MT/s 至 GT/s 级（T/s 为 transfer per sec），用于取代 FSB。<br />
基本 QPI 数据包为 80 位，分四次传输，有效数据 16 位，循环冗余校验 4 位。</p></li>
<li><p><strong>DMI 数据传输速率</strong><br />
DMI 是直接媒体接口，基于 PCI-E，用于取代 FSB。<br />
DMI 总线带宽<br />
<span class="math display">\[
理论最大带宽 = 传输速率 \times 编码率 \times 通道数 \div 8
\]</span></p></li>
<li><p><strong>片内 Cache 数量</strong><br />
CPU Cache 分为三级。</p>
<ul>
<li><p><strong>L1 Cache</strong><br />
位于 CPU 内核旁边，与 CPU结合最紧密。分为一级数据缓存（D-Cache）和一级指令缓存（I-Cache）。一般两个缓存容量相同。</p></li>
<li><p><strong>L2 Cache</strong><br />
影响 CPU 性能关键因素之一。CPU 核心不变，增加 L2 可大幅提高性能。容量约为 1 MB。</p></li>
<li><p><strong>L3 Cache</strong><br />
为读取 L2 未命中的数据设计。容量约几兆至几十兆字节。</p></li>
</ul></li>
<li><p><strong>工作电压</strong><br />
CPU 正常工作所需电压，一般越低越好。</p></li>
<li><p><strong>地址总线宽度</strong><br />
决定 CPU 可访问最大的物理地址空间。</p></li>
<li><p><strong>数据总线宽度</strong><br />
决定 CPU 项外界镜像依次数据传输的最大信息量。</p></li>
<li><p><strong>TDP 功耗</strong><br />
热设计功耗，一般为几瓦，当处理器达到最大负荷时所释放的热量功率。</p></li>
<li><p><strong>制造工艺</strong><br />
线宽指芯片内电路间的距离。现款越小，芯片上的晶体管的数量越多，性能越高。一般为纳米级。</p></li>
</ol>
<h2 id="控制器的组成和实验方法">6.2 控制器的组成和实验方法</h2>
<h3 id="控制器的基本组成">6.2.1 控制器的基本组成</h3>
<figure>
<img src="/image/icon/loading.gif" data-original="/image/25-11-11-1-CompOrg-6-cpu/1762864206517.webp" alt="1762864206517" />
<figcaption aria-hidden="true">1762864206517</figcaption>
</figure>
<ol type="1">
<li><p><strong>指令部件</strong><br />
完成取指令并分析指令。</p>
<ul>
<li><strong>程序计数器</strong></li>
<li><strong>指令寄存器</strong></li>
<li><strong>指令译码器（操作码译码器，指令功能分析器）</strong><br />
对指令的操作码部分进行译码，公告产生控制信号给微操作信号发生器。</li>
<li><strong>地址形成部件</strong></li>
</ul></li>
<li><p><strong>时序部件</strong><br />
产生时序信号，以保证各部件有节奏地进行信息传送。</p>
<ul>
<li><p><strong>脉冲源</strong><br />
使用石英晶振为整个机器提供基准信号。</p></li>
<li><p><strong>启停控制逻辑</strong><br />
</p></li>
<li><p><strong>节拍信号发生器</strong><br />
将基准信号转换为各机器周期的节拍信号。</p></li>
</ul></li>
<li><p><strong>微操作信号发生器（控制单元，CU）</strong><br />
将一条指令的取出和执行分为很多基本且不可再分割的微操作。</p></li>
<li><p><strong>中断控制逻辑</strong><br />
控制中断处理的硬件逻辑。</p></li>
</ol>
<h3 id="控制器的硬件的实现方法">6.2.2 控制器的硬件的实现方法</h3>
<figure>
<img src="/image/icon/loading.gif" data-original="/image/25-11-11-1-CompOrg-6-cpu/1762865141743.webp" alt="1762865141743" />
<figcaption aria-hidden="true">1762865141743</figcaption>
</figure>
<ol type="1">
<li><strong>组合逻辑型控制器</strong><br />
称为常规控制器或硬连线控制器，采用组合逻辑技术，由门电路实现。一般巨型机和 RISC 机使用。
<ul>
<li>优点：速度快。</li>
<li>缺点：设计、调试、维修、更新困难。</li>
</ul></li>
<li><strong>存储逻辑型控制器</strong><br />
称为微程序控制器，采用存储逻辑，将微操作信号代码化，将指令转化为微程序存入控制存储器，微操作信号由微指令产生。
<ul>
<li>优点：设计、调试、维修、更新方便。</li>
<li>缺点：比组合逻辑型控制器慢。</li>
</ul></li>
<li><strong>组合逻辑与存储逻辑结合型控制器</strong><br />
称为可编程逻辑阵列（PLA）控制器。PLA 实际上是组合逻辑控制器，但是可编程。</li>
</ol>
<h2 id="时序系统与控制方式">6.3 时序系统与控制方式</h2>
<h3 id="时序系统">6.3.1 时序系统</h3>
<ol type="1">
<li><strong>指令周期和机器周期</strong>
<ul>
<li><p>指令周期：从取指令、分析取数到执行完成所需全部时间。</p></li>
<li><p>机器周期：亦作 CPU 周期。将一个指令周期划分为若干机器周期每个机器周期完成一个基本操作。</p>
<p><span class="math display">\[
指令周期 = i \times 机器周期
\]</span></p>
<p>不同指令周期的 <span class="math inline">\(i\)</span> 值差距很大。一条指令最短需要取指、执行两个周期。</p></li>
</ul></li>
</ol>
<p />
<ul>
<li><strong>节拍</strong><br />
将一个机器周期分为若干等时的节拍，每个节拍对应一个节拍点位信号。
<ul>
<li><p><strong>统一节拍法</strong><br />
以<strong>最复杂的机器周期</strong>为准定出节拍数，所有机器周期长度相等，称为<strong>定长 CPU 周期</strong>。</p></li>
<li><p><strong>分散节拍法</strong><br />
机器周期需要多少节拍就发出多少节拍，称为<strong>不定长 CPU 周期</strong>。</p></li>
<li><p><strong>延长节拍法</strong><br />
照顾多数机器周期要求的情况下，对某些较长机器周期延长一两个节拍。</p></li>
<li><p><strong>时钟周期插入法</strong><br />
时序信号不设置节拍，直接使用时钟周期信号。一个机器周期基本时钟周期数确定后，还可不断插入等待时钟周期。</p></li>
</ul></li>
</ul>
<ol start="3" type="1">
<li><p><strong>工作脉冲</strong><br />
节拍内设置数个工作脉冲，处于<strong>节拍末尾</strong>，用于保证<strong>所有触发器都可靠、稳定翻转</strong>。</p></li>
<li><p><strong>多级时序系统</strong><br />
<img src="/image/icon/loading.gif" data-original="/image/25-11-11-1-CompOrg-6-cpu/1762867517678.webp" alt="1762867517678" /><br />
机器周期间、节拍间、工作脉冲间<strong>不允许重叠和空隙</strong>。</p></li>
<li><p><strong>节拍电位与工作脉冲的时间配合关系</strong></p></li>
</ol>
<h3 id="控制方式">6.3.2 控制方式</h3>
<ol type="1">
<li><strong>同步控制方式</strong><br />
各项操作由统一的时序信号控制。
<ul>
<li>优点：设计简单，容易实现。</li>
<li>缺点：速度慢。</li>
</ul></li>
<li><strong>异步控制方式</strong><br />
各项操作时序根据指令或部件的具体请况决定。这是一种“<strong>应答</strong>”的方式，和操作衔接由“结束—起始”信号实现。
<ul>
<li>优点：提高效率。</li>
<li>缺点：控制复杂。</li>
</ul></li>
<li><strong>联合控制方式</strong><br />
同步与异步相结合。在<strong>功能部件内部</strong>采用<strong>同步控制</strong>，在<strong>功能部件之间</strong>采用<strong>异步方式</strong>。</li>
</ol>
<h3 id="指令运行的基本过程">6.3.3 指令运行的基本过程</h3>
<ol type="1">
<li><p><strong>取指令阶段</strong><br />
<img src="/image/icon/loading.gif" data-original="/image/25-11-11-1-CompOrg-6-cpu/1762868462305.webp" alt="1762868462305" /><br />
将现行指令从主存中取出并送至指令寄存器。</p>
<ul>
<li>将 PC 内容送入 MAR，并送入地址总线（AB）。</li>
<li>由 CU 经控制总线（CB）向存储器发读命令。</li>
<li>从主存中取出的指令通过数据总线（DB）送到存储器数据存储器（MDR）。</li>
<li>将 MDR 内容送进 IR。</li>
<li>PC 递增。</li>
</ul>
<p>以上操作为公共操作，所有指令必须执行。完成取指阶段任务的时间为取指周期。</p>
<ul>
<li>地址流动：PC &gt;&gt; MAR &gt;&gt; AB &gt;&gt; DRAM。</li>
<li>数据流动：主存 &gt;&gt; DB &gt;&gt; MDR &gt;&gt; IR &gt;&gt; 译码器（ID） &gt;&gt; CU。</li>
</ul></li>
<li><p><strong>分析取数阶段</strong><br />
ID 可识别不同的指令类型（分析），此时计算机开始获取操作数（取数）。</p>
<ul>
<li><strong>无操作数指令</strong>：识别出指令后<strong>直接执行</strong>，无需此阶段。</li>
<li><strong>有操作数指令</strong>：先计算操作数的<strong>有效地址</strong>。
<ul>
<li>若操作数位于<strong>通用寄存器</strong>，无需访问主存。</li>
</ul></li>
</ul>
<p>此阶段又可细分为<strong>间址周期</strong>、<strong>取数周期</strong>等。</p></li>
<li><p><strong>执行阶段</strong><br />
完成指令规定的各种操作，形成稳定的运算结果并存储。</p>
<pre class="mermaid">   graph LR

A["取指令"]
B["取数"]

A --> B
B --> A</pre>
<p>这三个阶段将周而复始，直到遇见<strong>停机指令</strong>与<strong>外来干预</strong>。</p></li>
</ol>
<h3 id="指令的微操作序列">6.3.4 指令的微操作序列</h3>
<p>控制器在实现功能时需要将功能分解为一系裂<strong>时间上有先后顺序的</strong>、<strong>最基本</strong>、<strong>最简单</strong>的操作。不同的数据通路有不同的微操作序列。</p>
<figure>
<img src="/image/icon/loading.gif" data-original="/image/25-11-11-1-CompOrg-6-cpu/1762869350176.webp" alt="1762869350176" />
<figcaption aria-hidden="true">1762869350176</figcaption>
</figure>
<ol type="1">
<li><strong>加法指令 <code>ADD@R0, R1</code></strong><br />
<span class="math display">\[
((R_0)) + (R_1) \rightarrow (R_0)
\]</span><br />
把 <span class="math inline">\(R_0\)</span> 的内容作为地址送到主存作为操作数，再与 <span class="math inline">\(R_1\)</span> 内容相加，最后放回主存。
<ul>
<li><strong>取指周期</strong>
<ul>
<li><span class="math inline">\(\rm PC_{out}\)</span> 与 <span class="math inline">\(\rm MAR_{in}\)</span> 有效，<span class="math inline">\(\rm PC \rightarrow MAR\)</span>。</li>
<li>通过控制总线向主存发读命令，<code>Read</code>。</li>
<li>存储器通过数据总线将 <span class="math inline">\(\rm MAR\)</span> 内容送至 <span class="math inline">\(\rm MDR\)</span>，<span class="math inline">\(\rm M(MAR) \rightarrow MDR\)</span>。</li>
<li><span class="math inline">\(\rm MDR_{out}\)</span> 和 <span class="math inline">\(\rm IR_{in}\)</span> 有效，将 MDR 内容送进 IR，<span class="math inline">\(\rm MDR \rightarrow IR\)</span>。</li>
<li><span class="math inline">\(\rm PC\)</span> 自增。</li>
</ul></li>
<li><strong>取数周期</strong>
<ul>
<li><span class="math inline">\(R_{0out}\)</span> 与 <span class="math inline">\(MAR_{in}\)</span> 有效，<span class="math inline">\((R_0) \rightarrow MAR\)</span>。</li>
<li><code>Read</code>。</li>
<li>存储器通过数据总线将 MAR 所指单元内容送至 MDR，同时 MDR<sub>out</sub> 与 Y<sub>in</sub> 有效，<span class="math inline">\(M(MAR) \rightarrow MDR \rightarrow Y\)</span>。</li>
</ul></li>
<li><strong>执行周期</strong>
<ul>
<li>R<sub>1out</sub> 与 ALU<sub>in</sub> 有效，CU 向 ALU 发 <code>ADD</code> 控制信号，结果送至寄存器 Z，<span class="math inline">\((R_1) + Y \rightarrow Z\)</span>。</li>
<li>Z<sub>out</sub> 与 MDR<sub>in</sub> 有效，<span class="math inline">\((Z) \rightarrow MDR\)</span>。</li>
<li>向主存发写命令，<code>Write</code>。</li>
</ul></li>
</ul></li>
</ol>
<h2 id="微程序控制原理">6.4 微程序控制原理</h2>
<p>将微操作的控制信号按一定规律进行编码，形成控制字，将微指令按时间先后排列构成微程序。</p>
<h3 id="微程序控制的概念">6.4.1 微程序控制的概念</h3>
<ol type="1">
<li><p><strong>微程序设计的提出与发展</strong></p></li>
<li><p><strong>基本术语</strong></p>
<ul>
<li><strong>微命令与微操作</strong>
<ul>
<li>微操作</li>
<li>微命令：控制部件向执行部件发出的各种控制命令。
<ul>
<li>兼容性：一些微命令可以同时产生，共同完成某些微操作。</li>
<li>互斥性：一些微命令不能同时出现。</li>
</ul></li>
</ul></li>
<li><strong>微指令与微地址</strong>
<ul>
<li>微指令：控制存储器一个单元的内容，是若干微命令的集合，包括<strong>操作控制（微操作码）字段</strong>、<strong>顺序控制（微地址码）字段</strong>。</li>
<li>微地址：微指令单元的地址。</li>
<li>垂直型微指令：接近于<strong>机器指令</strong>，只能完成一个基本微操作。</li>
<li>水平型微指令：并行执行基本微操作。</li>
</ul></li>
<li><strong>微周期</strong><br />
从控制存储器读取一条微指令到执行完全部微命令。</li>
<li><strong>微程序</strong><br />
一系列微指令的<strong>有序集合</strong>。每一条机器指令对友一个微程序。</li>
</ul></li>
</ol>
<blockquote>
<p>注意：微程序和程序的区别。</p>
</blockquote>
<table style="width:100%;">
<colgroup>
<col style="width: 11%" />
<col style="width: 11%" />
<col style="width: 11%" />
<col style="width: 11%" />
<col style="width: 11%" />
<col style="width: 11%" />
<col style="width: 11%" />
<col style="width: 11%" />
<col style="width: 11%" />
</colgroup>
<tbody>
<tr class="odd">
<td>编程人员</td>
<td>计算机</td>
<td>CPU</td>
<td>主存</td>
<td>程序</td>
<td>指令</td>
<td>周期</td>
<td>地址</td>
<td>微指令</td>
</tr>
<tr class="even">
<td>设计人员</td>
<td>CPU</td>
<td>控制器</td>
<td>控制存储器</td>
<td>微程序</td>
<td>微指令</td>
<td>微周期</td>
<td>微地址</td>
<td>微命令</td>
</tr>
</tbody>
</table>
<figure>
<img src="/image/icon/loading.gif" data-original="/image/25-11-11-1-CompOrg-6-cpu/1763470913467.webp" alt="1763470913467" />
<figcaption aria-hidden="true">1763470913467</figcaption>
</figure>
<h3 id="微指令编码法">6.4.2 微指令编码法</h3>
<ol type="1">
<li><strong>直接控制法（不译码法）</strong><br />
操作控制字段直接控制计算机，每一位代表一个微命令，<code>0</code> 为无效，<code>1</code> 为有效。
<ul>
<li>优点：结构简单，并行性强。</li>
<li>缺点：很长，有些微命令互斥。</li>
</ul></li>
<li><strong>最短编码法</strong><br />
将所有微命令统一编码，微指令微命令一一对应。微命令总数 <span class="math inline">\(N\)</span>，操作控制字段长度 <span class="math inline">\(L\)</span> 满足<br />
<span class="math display">\[
L \geq \log_2 N
\]</span>
<ul>
<li>优点：字长最短。</li>
<li>缺点：微命令数较多时译码器复杂，并行性差。</li>
</ul></li>
<li><strong>字段编码法</strong> <sub>666又是凉面派</sub><br />
将操作控制字段分为若干小段，每段采用最短编码法。
<ul>
<li><p><strong>字段直接编码法</strong><br />
每一个小段独立定义一个微命令。<br />
<img src="/image/icon/loading.gif" data-original="/image/25-11-11-1-CompOrg-6-cpu/1767449130189.webp" alt="1767449130189" /></p></li>
<li><p><strong>字段间接编码法</strong><br />
微命令由多个小段联合定义。<br />
<img src="/image/icon/loading.gif" data-original="/image/25-11-11-1-CompOrg-6-cpu/1767449146760.webp" alt="1767449146760" /></p></li>
<li><p><strong>分段原则</strong></p>
<ul>
<li>将互斥的微命令放在相同段，兼容的微命令放在不同段。</li>
<li>与数据通路结构适应。</li>
<li>每小段信息不能太多。</li>
<li>每小段留出一个状态，表示本字段不发出微命令，一般为全 0。</li>
</ul></li>
</ul></li>
</ol>
<h3 id="微程序控制器的组成与工作过程">6.4.3 微程序控制器的组成与工作过程</h3>
<ol type="1">
<li><p><strong>基本组成</strong><br />
<img src="/image/icon/loading.gif" data-original="/image/25-11-11-1-CompOrg-6-cpu/1763473031697.webp" alt="1763473031697" /></p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>部件</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>控制存储器（CM）</td>
<td>微程序控制器的<strong>核心部件</strong>，存放<strong>微程序</strong>。</td>
</tr>
<tr class="even">
<td>微指令寄存器（μIR）</td>
<td>存放 CM 中取出的微指令，位数同<strong>微指令字长</strong>相等。</td>
</tr>
<tr class="odd">
<td>微地址形成部件</td>
<td>产生<strong>初始微地址</strong>和<strong>后继微地址</strong>，保证<strong>连续执行</strong>。</td>
</tr>
<tr class="even">
<td>微地址寄存器（μMAR）</td>
<td>接收微地址形成部件送来的<strong>微地址</strong>，为在 CM 读取微指令做准备。</td>
</tr>
</tbody>
</table></li>
<li><p><strong>工作过程（必考）</strong></p>
<ul>
<li><strong>取指令</strong>公共操作。</li>
<li>产生机器指令所对应的微程序的<strong>入口地址</strong>。</li>
<li>从 CM 中<strong>逐条取微指令并执行</strong>。</li>
<li>回到<strong>取指微程序</strong>入口地址，回到 1。</li>
</ul></li>
<li><p><strong>机器指令对应的微程序</strong></p>
<ul>
<li>通常一条机器指令对应一个微程序。</li>
<li>系统中有 <span class="math inline">\(n\)</span> 种指令，则控制存储器微程序数至少有 <span class="math inline">\(n + 1\)</span> 个。</li>
</ul></li>
</ol>
<h3 id="微程序入口地址的形成">6.4.4 微程序入口地址的形成</h3>
<ol type="1">
<li><p><strong>一级功能转换</strong><br />
如果机器指令操作码字段的位数与位置固定，可以直接使操作码与入口地址部分位相对应。</p></li>
<li><p><strong>二级功能转换</strong><br />
<strong>同类</strong>机器指令操作码字段的位数与位置固定，不同类机器指令操作码字段的位数与位置不固定时，先区分<strong>指令属于哪类</strong>，再确定具体指令。</p></li>
<li><p><strong>PLA 电路实现功能转换</strong><br />
机器指令操作码字段的位数与位置不固定，采用 <strong>PLA 电路</strong>进行翻译，转换速度较快。</p></li>
</ol>
<h3 id="后继微地址的形成">6.4.5 后继微地址的形成</h3>
<p>每条指令完成后需要形成后继微地址。</p>
<ol type="1">
<li><p><strong>增量方式（顺序—转移型微地址）</strong><br />
顺序执行时，后记微地址就是先行微地址<strong>加上增量</strong>（通常为 1），</p></li>
<li><p><strong>断定方式</strong><br />
后继微地址可由微程序设计者指定，或根据微指令规定的测试结果直接决定后继微地址的全部与部分值。</p>
<ul>
<li>非测试段：可由<strong>设计者</strong>指定，一般是微地址的<strong>高位部分</strong>，指定后继微地址在 <strong>CM 某区域内</strong>。</li>
<li>测试段：</li>
</ul></li>
</ol>
<h3 id="微程序设计">6.4.6 微程序设计</h3>
<ol type="1">
<li><p><strong>微程序设计方法</strong><br />
应考虑尽量缩短微指令字长，减少微程序长度，提高微程序的执行速度。</p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th>属性</th>
<th>水平型微指令、水平型微程序设计</th>
<th>垂直型微指令、垂直型微程序设计</th>
<th>混合型微指令</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>方法</td>
<td>微指令一次能定义并能并行执行多个微命令</td>
<td>微指令一次只能执行一个微命令的微指令</td>
<td>凉面派</td>
</tr>
<tr class="even">
<td>并行能力、效率、灵活性</td>
<td>强</td>
<td>弱</td>
<td>凉面派</td>
</tr>
<tr class="odd">
<td>难度</td>
<td>与机器指令差别大，不易掌握</td>
<td>与机器指令差别小，易掌握</td>
<td></td>
</tr>
</tbody>
</table></li>
</ol>
<h2 id="控制单元的设计">6.5 控制单元的设计</h2>
<h3 id="简单的-cpu-模型">6.5.1 简单的 CPU 模型</h3>
<figure>
<img src="/image/icon/loading.gif" data-original="/image/25-11-11-1-CompOrg-6-cpu/1767537579140.webp" alt="1767537579140" />
<figcaption aria-hidden="true">1767537579140</figcaption>
</figure>
<ol type="1">
<li><p><strong>非访存指令</strong></p></li>
<li><p><strong>访存指令</strong></p></li>
<li><p><strong>转移指令</strong></p></li>
</ol>
<h3 id="组合逻辑控制单元设计">6.5.2 组合逻辑控制单元设计</h3>
<ol type="1">
<li><strong>微操作节拍安排</strong><br />
应当注意：有些操作的次序不容改变；被控对象不同的操作尽量同一节拍完成；短时微操作在同一节拍完成，允许有先后顺序。
<ul>
<li><p><strong>取值周期微操作的节拍安排</strong><br />
在 3 个节拍内完成。</p>
<table>
<thead>
<tr class="header">
<th>节拍</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(T_0\)</span></td>
<td><span class="math inline">\(PC \to MAR\)</span>, Read</td>
</tr>
<tr class="even">
<td><span class="math inline">\(T_1\)</span></td>
<td><span class="math inline">\(M(MAR) \to MDR\)</span>, <span class="math inline">\(PC++\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(T_2\)</span></td>
<td><span class="math inline">\((MDR) \to IR\)</span>, 也可继续完成 <span class="math inline">\(OP(IR) \to ID\)</span></td>
</tr>
</tbody>
</table></li>
<li><p><strong>间址周期微操作的节拍安排</strong></p>
<table>
<thead>
<tr class="header">
<th>节拍</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(T_0\)</span></td>
<td><span class="math inline">\((MAR) \to MAR\)</span>, Read</td>
</tr>
<tr class="even">
<td><span class="math inline">\(T_1\)</span></td>
<td><span class="math inline">\(M(MAR) \to MDR\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(T_2\)</span></td>
<td><span class="math inline">\((MDR) \to MAR\)</span></td>
</tr>
</tbody>
</table></li>
<li><p><strong>执行周期微操作的节拍安排</strong></p>
<ul>
<li><p><strong>非访存指令</strong><br />
在执行周期只有一个微操作，按同步控制原则，可安排在 <span class="math inline">\(T_0 \sim T_2\)</span> 任一节拍内，其余留空。</p></li>
<li><p><strong>访存指令</strong></p></li>
<li><p><strong>转移类指令</strong></p></li>
</ul></li>
</ul></li>
</ol>
<h3 id="微程序控制单元设计">6.5.3 微程序控制单元设计</h3>
<ol type="1">
<li><strong>微程序控制单元的设计步骤</strong>
<ul>
<li>确定微程序控制方式。</li>
<li>拟定微命令系统。</li>
<li>编制微程序。</li>
<li>微程序代码化。</li>
<li>写入控制存储器。</li>
</ul></li>
<li><strong>设计举例</strong></li>
</ol>
<h2 id="流水线技术">6.6 流水线技术</h2>
<h3 id="重叠控制">6.6.1 重叠控制</h3>
<p>如果顺序执行，假设取指、分析、执行时间相等，则顺序执行 <span class="math inline">\(n\)</span> 条指令所需时间为<br />
<span class="math display">\[
T = \sum (t_{取指} + t_{分析} + t_{执行}) = 3nt
\]</span><br />
<img src="/image/icon/loading.gif" data-original="/image/25-11-11-1-CompOrg-6-cpu/1764074468464.webp" alt="1764074468464" /></p>
<ul>
<li><p><strong>一次重叠</strong>：将“执行 <span class="math inline">\(K\)</span>”与“取指 <span class="math inline">\(K + 1\)</span>”重叠，时间为<br />
<span class="math display">\[
T = 3t + (n - 1) \cdot 2t = (2n + 1)t
\]</span><br />
<img src="/image/icon/loading.gif" data-original="/image/25-11-11-1-CompOrg-6-cpu/1764074379946.webp" alt="1764074379946" /></p></li>
<li><p><strong>二次重叠</strong>：将“分析 <span class="math inline">\(K\)</span>”“取指 <span class="math inline">\(K + 1\)</span>”重叠，“执行 <span class="math inline">\(K\)</span>”“分析 <span class="math inline">\(K + 1\)</span>”“取指 <span class="math inline">\(K + 2\)</span>”重叠，“执行 <span class="math inline">\(K + 1\)</span>”“分析 <span class="math inline">\(K + 2\)</span>”重叠，时间为<br />
<span class="math display">\[
T = 3t + (n - 1) \cdot t = (n + 2)t
\]</span><br />
<img src="/image/icon/loading.gif" data-original="/image/25-11-11-1-CompOrg-6-cpu/1764074394080.webp" alt="1764074394080" /></p></li>
</ul>
<h3 id="先行控制原理">6.6.2 先行控制原理</h3>
<p>实际上，三次操作的时间不是均等的。为了使各部件能连续地工作，提出了先行控制的方式，如图所示。虽然图中“分析”和“执行”阶段之间有等待的时间间隔<span class="math inline">\(\Delta t_i\)</span>，但它们各自的流程中却是连续的。先行控制的主要目的是使各阶段的专用控制部件不间断的工作，以提高设备的利用率及执行速度。<br />
<img src="/image/icon/loading.gif" data-original="/image/25-11-11-1-CompOrg-6-cpu/1764075130907.webp" alt="1764075130907" /></p>
<h3 id="流水工作原理">6.6.3 流水工作原理</h3>
<ol type="1">
<li><p><strong>流水线</strong><br />
将一个较复杂的处理过程分成 <span class="math inline">\(m\)</span> 个复杂程度相当、时间大致相等的子过程。每个子过程有一个独立的功能部件来完成，处理对象在各子过程连成的线路上连续流动。同一时间，<span class="math inline">\(m\)</span> 个部件同时执行不同的操作，完成不同的对象处理。</p></li>
<li><p><strong>流水线分类</strong></p>
<ul>
<li><strong>按处理级别分类</strong>
<ul>
<li>操作部件级：拆分复杂算数逻辑运算为流水线。</li>
<li>指令级：拆分执行过程为流水线。</li>
<li>处理机级（宏流水线）：每个处理机对同意数据流的不同部分进行处理。</li>
</ul></li>
<li><strong>按功能分类</strong>
<ul>
<li>单功能</li>
<li>多功能</li>
</ul></li>
<li><strong>按工作方式分类</strong>
<ul>
<li>静态流水线</li>
<li>动态流水线</li>
</ul></li>
<li><strong>按流水线结构分类</strong>
<ul>
<li>线性流水线</li>
<li>非线性流水线</li>
</ul></li>
</ul></li>
<li><p><strong>指令流水线的相关性</strong></p>
<ul>
<li><p><strong>结构相关</strong><br />
多条指令在同一时间争夺同一资源。</p></li>
<li><p><strong>数据相关</strong><br />
后一指令还未获取前一指令的结果。</p>
<ul>
<li>RAW</li>
<li>WAR</li>
<li>WAW</li>
</ul></li>
<li><p><strong>控制相关</strong><br />
控制相关主要由<strong>转移指令</strong>引起。在无法确定该把哪一段程序放在转移指令之后的局面称为<strong>控制相关</strong>，又称<strong>指令相关</strong>。</p></li>
</ul></li>
</ol>
<h2 id="精简指令系统计算机risc">6.7 精简指令系统计算机（RISC）</h2>
<p>Reduced Instruction Set Computer.</p>
<h3 id="risc-的特点和优势">6.7.1 RISC 的特点和优势</h3>
<ol type="1">
<li><p><strong>RISC 的主要特点</strong></p>
<ul>
<li>指令总数较少</li>
<li>基本寻址方式种类少</li>
<li>指令格式少</li>
<li>除存取数指令外，大部分指令在单周期内完成。</li>
<li>除存取数指令外，其他指令均只在寄存器间进行。</li>
<li>CPU 内通用寄存器多。</li>
<li>指令执行大多采用硬连线实现，不或少用微程序。</li>
<li>采用优化的编译技术，以简单的方式支持高级语言</li>
</ul></li>
<li><p><strong>RISC 的优势</strong><br />
计算机执行一个程序所用时间<br />
<span class="math display">\[
t = ICT
\]</span></p>
<table>
<thead>
<tr class="header">
<th>变量</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(I\)</span></td>
<td>高级语言编译后在机器上执行的机器指令的总数</td>
</tr>
<tr class="even">
<td><span class="math inline">\(C\)</span></td>
<td>执行每条机器指令所需的平均周期数</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(T\)</span></td>
<td>每个周期执行时间</td>
</tr>
</tbody>
</table>
<p>相比 CISC，RISC 的 <span class="math inline">\(I\)</span> 较大，<span class="math inline">\(C\)</span>、<span class="math inline">\(T\)</span> 较小。</p></li>
</ol>
<h3 id="risc-基本技术">6.7.2 RISC 基本技术</h3>
<ol type="1">
<li><p><strong>RISC 寄存器管理技术</strong><br />
RISC II 使用重叠寄存器窗口，设计一个较大的寄存器堆，划分为很多窗口。</p></li>
<li><p><strong>流水线技术</strong></p></li>
<li><p><strong>延时转移技术</strong><br />
遇到转移指令时，流水线可能断流。</p>
<ul>
<li>延迟转移方法</li>
<li>优化转移方法</li>
</ul></li>
</ol>
<h2 id="微处理器中的新技术">6.8 微处理器中的新技术</h2>
<h3 id="超标量与超流水线技术">6.8.1 超标量与超流水线技术</h3>
<p>提高指令并行性，在每个时钟周期内解释多条指令。</p>
<h3 id="epic-的指令级并行处理">6.8.2 EPIC 的指令级并行处理</h3>
<p>使用智能化的软件指挥硬件，实现指令集的并行计算。</p>
<h3 id="超线程技术ht">6.8.3 超线程技术（HT）</h3>
<p>将一个物理 CPU 当成两个逻辑 CPU 使用，使 CPU 执行多线程。</p>
<h3 id="双核与多核技术">6.8.4 双核与多核技术</h3>
<p>在一个处理器上集成两个或多个运算核心，提高运算能力。</p>
<h3 id="睿频加速技术">6.8.5 睿频加速技术</h3>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://remy-campanella.github.io">Remy Campanella</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://remy-campanella.github.io/2026/01/05/25-11-11-1-CompOrg-6-cpu/">https://remy-campanella.github.io/2026/01/05/25-11-11-1-CompOrg-6-cpu/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://remy-campanella.github.io" target="_blank">remy-campanella.github.io</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><a class="post-meta__tags" href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">基础知识</a></div><div class="post-share"><div class="social-share" data-image="/image/background/remy.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://unpkg.com/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://unpkg.com/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2026/01/04/26-1-4-2-SoftEng-7-real/" title="【软件工程学习】 第七章 实现"><img class="cover" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">【软件工程学习】 第七章 实现</div></div><div class="info-2"><div class="info-item-1">7.1 编码 7.1.1 选择程序设计语言  选择适宜的程序设计语言的原因  根据设计去完成编码时，困难最少； 可以减少需要的程序测试量； 可以得到更容易阅读和更容易维护的程序。  高级语言优于汇编语言  汇编语言编码需要把软件设计翻译成机器操作的序列，既困难又容易出差错； 高级语言写程序比用汇编语言写程序生产率可以提高好几倍； 用高级语言写的程序容易阅读、容易测试、容易调试、容易维护。   7.1.2 编码风格  程序内部文档  标识符：含义鲜明的名字、缩写规则一致、为名字加注解； 注解：正确性，简要描述模块的功能、主要算法、接口特点、重要数据以及开发简史或解释包含这段代码的必要性； 视觉组织：适当的阶梯形式使程序的层次结构清晰明显。  数据说明 数据说明的次序应该标准化；  当多个变量名在一个语句中说明时，应该按字母顺序排列这些变量； 如果设计时使用了一个复杂的数据结构，则应该用注解说明用程序设计语言实现这个数据结构的方法和特点。  语句构造  不要为了节省空间而把多个语句写在同一行； 尽量避免复杂的条件测试；...</div></div></div></a><a class="pagination-related" href="/2026/01/05/25-11-25-1-CompOrg-7-bus/" title="【计算机组成原理】 第七章 总线"><img class="cover" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">【计算机组成原理】 第七章 总线</div></div><div class="info-2"><div class="info-item-1">7.1 总线概述 总线是一组能为多个部件分时共享的公共信息传送线路。  共享  总线上可挂载多个部件  分时  同一时刻总线上只能有一个部件发送信息。   7.1.1 总线的基本概念  分时共享的过程  总线空闲，所有部件处于高阻态。 通信时，  三态门和总线电路 三态门有逻辑 0、逻辑 1、高阻态（开路）三态。三态门有一个控制端 \(G\)/\(\bar{G}\)，控制端有效时功能正常，否则为高阻态。 总线事务 总线上一对设备间一次信息交换称为一次总线事务。 总线使用权  7.1.2 总线的分类  按功能层次分类 按数据线的多少分类  并行总线 串行总线   7.1.3 总线的组成与性能指标  总线结构  单总线 双总线 三总线  总线特性 总线的性能指标  总线宽度 总线的线数，影响地址线与数据线的数量。 总线带宽 最大数据传输速率（字节/秒）。 \[ B = \frac{WF}{N} \] \(W\)—数据总线宽度；\(F\)—时钟频率；\(N\)—一次数据传输的时钟周期...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/10/15/25-10-14-4-CompOrg-4-machine-calculation/" title="【计算机组成原理】 第四章 数值的机器运算"><img class="cover" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-15</div><div class="info-item-2">【计算机组成原理】 第四章 数值的机器运算</div></div><div class="info-2"><div class="info-item-1">4.1 基本算数运算的实现 4.1.1 加法器  全加器逻辑与真值表 （略） 逻辑表达式 \[ S_i = A_i \oplus B_i \oplus C_{i - 1} \\\\ C_i = A_iB_i + (A_i \oplus B_i)C_{i - 1} \] 串行与并行          种类 方法 优点 缺点     串行加法器 数据逐位送入一个加法器进行计算 器件少、成本低 速度慢   并行加法器 由多个全加器组成，位数多少取决于字长 速度高 加法运算最长时间问题     4.2.2 进位的产生与传递 设进位传递函数 \[ P_i = A_i \oplus B_i  \ \text{（进位传递函数）} \\\\ G_i = A_iB_i \] 则 \[ C_n = G_n + P_nC_{n - 1} \] 串行进位加法器的总延迟时间与字长成正比。设一级与门、或门的延迟时间为\(ty\)，每一级全加器延迟为\(2ty\)，从\(C_0\)到\(C_N\)的最长时间...</div></div></div></a><a class="pagination-related" href="/2026/01/05/25-11-25-1-CompOrg-7-bus/" title="【计算机组成原理】 第七章 总线"><img class="cover" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-05</div><div class="info-item-2">【计算机组成原理】 第七章 总线</div></div><div class="info-2"><div class="info-item-1">7.1 总线概述 总线是一组能为多个部件分时共享的公共信息传送线路。  共享  总线上可挂载多个部件  分时  同一时刻总线上只能有一个部件发送信息。   7.1.1 总线的基本概念  分时共享的过程  总线空闲，所有部件处于高阻态。 通信时，  三态门和总线电路 三态门有逻辑 0、逻辑 1、高阻态（开路）三态。三态门有一个控制端 \(G\)/\(\bar{G}\)，控制端有效时功能正常，否则为高阻态。 总线事务 总线上一对设备间一次信息交换称为一次总线事务。 总线使用权  7.1.2 总线的分类  按功能层次分类 按数据线的多少分类  并行总线 串行总线   7.1.3 总线的组成与性能指标  总线结构  单总线 双总线 三总线  总线特性 总线的性能指标  总线宽度 总线的线数，影响地址线与数据线的数量。 总线带宽 最大数据传输速率（字节/秒）。 \[ B = \frac{WF}{N} \] \(W\)—数据总线宽度；\(F\)—时钟频率；\(N\)—一次数据传输的时钟周期...</div></div></div></a><a class="pagination-related" href="/2025/12/24/25-11-26-2-CompOrg-5-mem/" title="【计算机组成原理】 第五章 存储系统"><img class="cover" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-24</div><div class="info-item-2">【计算机组成原理】 第五章 存储系统</div></div><div class="info-2"><div class="info-item-1">5.1 存储系统的组成 5.1.1 存储器分类  按存储器在计算机中的作用分          名称 作用 成本 性能     高速存储缓冲器（Cache） 位于主存与 CPU 之间，存放正在执行的程序段与数据 高 速度与 CPU 匹配，容量小   主存储器 存放计算机运行期间所需要的程序和数据，CPU 和直接随机读写  速度较高，具有一定容量   辅助存储器（外存储器、后援存储器） 存放当前暂不运行的程序和数据以及永久保存的信息 很低 容量大，速度较慢    按存取方式分类         名称 特性 用途     随机存取存储器（RAM） CPU 对存储器内容随机读取，对任何一个单元读写时间相同，使用灵活 主存、高速缓冲存储器   只读存储器（ROM） 内容只读不写，断电不消失 BIOS、存入固定子程序、函数发生器、字符发生器、微程序控制器的控制存储器   顺序存取存储器（SAM） 内容只能按某种顺序读取，读写时间与位置有关 磁带机  ...</div></div></div></a><a class="pagination-related" href="/2026/01/05/25-12-16-1-CompOrg-10-review/" title="【计算机组成原理】 复习要点"><img class="cover" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-05</div><div class="info-item-2">【计算机组成原理】 复习要点</div></div><div class="info-2"><div class="info-item-1">题型 简答题、计算题。 选一些计算题练习，课后习题。 闭卷考试。 实验报告：期末之前。 难度 较难，低于考研。 第一章 概论  冯 · 诺伊曼计算机 计算机基本组成  第二章 数据的机器层次表示  原码补码反码真值，互相转换 定点数、浮点数范围与典型值 浮点数进制与格式转换（IEEE 754） 字符编码 十进制数编码 奇偶校验  第三章 指令系统  指令格式 寻址方式 扩展操作码 自底向上的堆栈  第四章 数值的及其运算  8 种加减法 溢出检测 先行进位加法器的原理推导与设计 十进制数的加减法运算原理  第五章 存储系统和结构  RAM、ROM 的概念与类型 数据在主存中的存放方法 主存储器的连接、控制、寻址、扩展、刷新 主存的校验 存储系统的扩展  第六章 中央处理器  控制器的基本组成 时序系统 指令执行的过程 微程序的执行过程 取指周期的微操作，CPU 的数据通路图  第七章 总线  总线仲裁 总线定时控制  第八章 外部设备  滚木  第九章 输入输出...</div></div></div></a><a class="pagination-related" href="/2026/01/05/25-12-2-2-CompOrg-9-io-sys/" title="【计算机组成原理】 第九章 输入输出系统"><img class="cover" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-05</div><div class="info-item-2">【计算机组成原理】 第九章 输入输出系统</div></div><div class="info-2"><div class="info-item-1">9.1 主机与外部设备的连接 9.1.1 输入输出接口 主机与外设的连接方式有辐射型连接、总线型连接等。书记与外设各有自己的工作特点，必须通过 I/O 接口进行信息交换。 9.1.2 接口的功能与基本组成  接口的功能  实现主机与外设的通信联络控制。 进行地址译码与设备选择。 实现数据缓冲。 数据格式的变换。 传递控制命令和状态信息。  接口的基本组成 端口是接口电路中可以直接被 CPU 访问的寄存器。一个接口一般包含数据端口、命令端口和状态端口。  为了节省硬件，状态信息和控制信息可共用一个端口。 接口的类型  按数据传送方式  串行接口 并行接口  按主机访问 I/O 设备的控制方式分类  程序查询式接口 程序中断接口 DMA 接口 复杂通道控制器  按功能选择的灵活性分类  可编程接口 不可编程接口  按通用性分类  通用接口：可供多种外设使用的标准接口。 专用接口：为某类用途或外设专门设计。  按输入输出的信号分类  数字接口 模拟接口  按应用分类  运行辅助接口 用户交...</div></div></div></a><a class="pagination-related" href="/2026/01/05/25-12-2-2-CompOrg-8-ext-device/" title="【计算机组成原理】 第八章 外部设备"><img class="cover" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-05</div><div class="info-item-2">【计算机组成原理】 第八章 外部设备</div></div><div class="info-2"><div class="info-item-1">8.1 外部设备概述 8.1.1 外部设备的分类  输入输出设备 如键盘、鼠标、显示器、打印机等。此外还有复合型的输入输出设备。 辅助存储器 如硬盘。 终端设备 由输入设备、输出设备、终端控制器组成。可进行输入输出，与计算机通信线路通信，有的可进行数据处理。 过程控制设备 如 AD/DA 与相应检测设备。  8.1.2 外部设备的地位和作用 教材 232 / 250 页慢走不送~ ¯\_(ツ)_/¯ </div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/image/icon/loading.gif" data-original="/image/icon/Cover.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Remy Campanella</div><div class="author-info-description">A Remy Campanella blog website on Github.</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">70</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/remy-campanella"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站介绍帖、自我介绍帖内容已移至“关于”页面，目录帖内容已移至“分类”页面。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E7%BB%84%E6%88%90"><span class="toc-number">1.</span> <span class="toc-text">6.1 中央处理器的功能和组成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cpu-%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">1.1.</span> <span class="toc-text">6.1.1 CPU 的功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cpu-%E4%B8%AD%E7%9A%84%E4%B8%BB%E8%A6%81%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.2.</span> <span class="toc-text">6.1.2 CPU 中的主要寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cpu-%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">1.3.</span> <span class="toc-text">6.1.3 CPU 的组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cpu-%E7%9A%84%E4%B8%BB%E8%A6%81%E6%8A%80%E6%9C%AF%E5%8F%82%E6%95%B0"><span class="toc-number">1.4.</span> <span class="toc-text">6.1.4 CPU 的主要技术参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E7%BB%84%E6%88%90%E5%92%8C%E5%AE%9E%E9%AA%8C%E6%96%B9%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">6.2 控制器的组成和实验方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90"><span class="toc-number">2.1.</span> <span class="toc-text">6.2.1 控制器的基本组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E7%A1%AC%E4%BB%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">6.2.2 控制器的硬件的实现方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E5%BA%8F%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">6.3 时序系统与控制方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E5%BA%8F%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.1.</span> <span class="toc-text">6.3.1 时序系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">3.2.</span> <span class="toc-text">6.3.2 控制方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E8%BF%90%E8%A1%8C%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B"><span class="toc-number">3.3.</span> <span class="toc-text">6.3.3 指令运行的基本过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%9A%84%E5%BE%AE%E6%93%8D%E4%BD%9C%E5%BA%8F%E5%88%97"><span class="toc-number">3.4.</span> <span class="toc-text">6.3.4 指令的微操作序列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">6.4 微程序控制原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">4.1.</span> <span class="toc-text">6.4.1 微程序控制的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">6.4.2 微指令编码法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E7%BB%84%E6%88%90%E4%B8%8E%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">4.3.</span> <span class="toc-text">6.4.3 微程序控制器的组成与工作过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3%E5%9C%B0%E5%9D%80%E7%9A%84%E5%BD%A2%E6%88%90"><span class="toc-number">4.4.</span> <span class="toc-text">6.4.4 微程序入口地址的形成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E7%BB%A7%E5%BE%AE%E5%9C%B0%E5%9D%80%E7%9A%84%E5%BD%A2%E6%88%90"><span class="toc-number">4.5.</span> <span class="toc-text">6.4.5 后继微地址的形成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.6.</span> <span class="toc-text">6.4.6 微程序设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">5.</span> <span class="toc-text">6.5 控制单元的设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84-cpu-%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.1.</span> <span class="toc-text">6.5.1 简单的 CPU 模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E8%AE%BE%E8%AE%A1"><span class="toc-number">5.2.</span> <span class="toc-text">6.5.2 组合逻辑控制单元设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E8%AE%BE%E8%AE%A1"><span class="toc-number">5.3.</span> <span class="toc-text">6.5.3 微程序控制单元设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF"><span class="toc-number">6.</span> <span class="toc-text">6.6 流水线技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%8F%A0%E6%8E%A7%E5%88%B6"><span class="toc-number">6.1.</span> <span class="toc-text">6.6.1 重叠控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E8%A1%8C%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-number">6.2.</span> <span class="toc-text">6.6.2 先行控制原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">6.3.</span> <span class="toc-text">6.6.3 流水工作原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B2%BE%E7%AE%80%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E8%AE%A1%E7%AE%97%E6%9C%BArisc"><span class="toc-number">7.</span> <span class="toc-text">6.7 精简指令系统计算机（RISC）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#risc-%E7%9A%84%E7%89%B9%E7%82%B9%E5%92%8C%E4%BC%98%E5%8A%BF"><span class="toc-number">7.1.</span> <span class="toc-text">6.7.1 RISC 的特点和优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#risc-%E5%9F%BA%E6%9C%AC%E6%8A%80%E6%9C%AF"><span class="toc-number">7.2.</span> <span class="toc-text">6.7.2 RISC 基本技术</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%B8%AD%E7%9A%84%E6%96%B0%E6%8A%80%E6%9C%AF"><span class="toc-number">8.</span> <span class="toc-text">6.8 微处理器中的新技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E6%A0%87%E9%87%8F%E4%B8%8E%E8%B6%85%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF"><span class="toc-number">8.1.</span> <span class="toc-text">6.8.1 超标量与超流水线技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#epic-%E7%9A%84%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86"><span class="toc-number">8.2.</span> <span class="toc-text">6.8.2 EPIC 的指令级并行处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E7%BA%BF%E7%A8%8B%E6%8A%80%E6%9C%AFht"><span class="toc-number">8.3.</span> <span class="toc-text">6.8.3 超线程技术（HT）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E6%A0%B8%E4%B8%8E%E5%A4%9A%E6%A0%B8%E6%8A%80%E6%9C%AF"><span class="toc-number">8.4.</span> <span class="toc-text">6.8.4 双核与多核技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9D%BF%E9%A2%91%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF"><span class="toc-number">8.5.</span> <span class="toc-text">6.8.5 睿频加速技术</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2026/01/05/25-12-16-1-CompOrg-10-review/" title="【计算机组成原理】 复习要点"><img src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【计算机组成原理】 复习要点"/></a><div class="content"><a class="title" href="/2026/01/05/25-12-16-1-CompOrg-10-review/" title="【计算机组成原理】 复习要点">【计算机组成原理】 复习要点</a><time datetime="2026-01-05T03:05:13.000Z" title="发表于 2026-01-05 11:05:13">2026-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/05/25-12-2-2-CompOrg-9-io-sys/" title="【计算机组成原理】 第九章 输入输出系统"><img src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【计算机组成原理】 第九章 输入输出系统"/></a><div class="content"><a class="title" href="/2026/01/05/25-12-2-2-CompOrg-9-io-sys/" title="【计算机组成原理】 第九章 输入输出系统">【计算机组成原理】 第九章 输入输出系统</a><time datetime="2026-01-05T03:03:19.257Z" title="发表于 2026-01-05 11:03:19">2026-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/05/25-12-2-2-CompOrg-8-ext-device/" title="【计算机组成原理】 第八章 外部设备"><img src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【计算机组成原理】 第八章 外部设备"/></a><div class="content"><a class="title" href="/2026/01/05/25-12-2-2-CompOrg-8-ext-device/" title="【计算机组成原理】 第八章 外部设备">【计算机组成原理】 第八章 外部设备</a><time datetime="2026-01-05T02:47:29.000Z" title="发表于 2026-01-05 10:47:29">2026-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/05/25-11-25-1-CompOrg-7-bus/" title="【计算机组成原理】 第七章 总线"><img src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【计算机组成原理】 第七章 总线"/></a><div class="content"><a class="title" href="/2026/01/05/25-11-25-1-CompOrg-7-bus/" title="【计算机组成原理】 第七章 总线">【计算机组成原理】 第七章 总线</a><time datetime="2026-01-05T02:47:06.000Z" title="发表于 2026-01-05 10:47:06">2026-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/05/25-11-11-1-CompOrg-6-cpu/" title="【计算机组成原理】 第六章 中央处理器"><img src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【计算机组成原理】 第六章 中央处理器"/></a><div class="content"><a class="title" href="/2026/01/05/25-11-11-1-CompOrg-6-cpu/" title="【计算机组成原理】 第六章 中央处理器">【计算机组成原理】 第六章 中央处理器</a><time datetime="2026-01-05T02:46:54.000Z" title="发表于 2026-01-05 10:46:54">2026-01-05</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By Remy Campanella</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.0</a></span></div><div class="footer_custom_text">源代码库版本 1.4.0</div></div><script type="text/javascript" id="maid-script" src="https://unpkg.com/mermaid@9.0.0/dist/mermaid.min.js"></script><script>if (window.mermaid) {
  var options = JSON.parse(document.getElementById('maid-script').getAttribute('mermaidoptioins'));
  mermaid.initialize(options);
}</script></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        loader: {
          load: [
            // Four font extension packages (optional)
            //- '[tex]/bbm',
            //- '[tex]/bboldx',
            //- '[tex]/dsfont',
            '[tex]/mhchem'
          ],
          paths: {
            'mathjax-newcm': '[mathjax]/../@mathjax/mathjax-newcm-font',

            //- // Four font extension packages (optional)
            //- 'mathjax-bbm-extension': '[mathjax]/../@mathjax/mathjax-bbm-font-extension',
            //- 'mathjax-bboldx-extension': '[mathjax]/../@mathjax/mathjax-bboldx-font-extension',
            //- 'mathjax-dsfont-extension': '[mathjax]/../@mathjax/mathjax-dsfont-font-extension',
            'mathjax-mhchem-extension': '[mathjax]/../@mathjax/mathjax-mhchem-font-extension'
          }
        },
        output: {
          font: 'mathjax-newcm',
        },
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
          packages: {
            '[+]': [
              'mhchem'
            ]
          }
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          menuOptions: {
            settings: {
              enrich: false  // Turn off Braille and voice narration text automatic generation
            }
          },
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://unpkg.com/mathjax@4.0.0/tex-mml-chtml.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://unpkg.com/mermaid@11.11.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start -->
    <script src="/js/gallery.js" async></script>
<!-- hexo injector body_end end -->
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 2,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>