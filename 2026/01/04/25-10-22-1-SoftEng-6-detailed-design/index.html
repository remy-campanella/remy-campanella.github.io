<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>【软件工程学习】 第六章 详细设计 | remy-campanella.github.io</title><meta name="author" content="Remy Campanella"><meta name="copyright" content="Remy Campanella"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="6.1 结构程序设计 6.1.1 程序结构设计概念  程序结构设计概念的提出 1966 年 Böhm 和 Jacopini 证明，使用“顺序”、“选择”、“循环”可实现单入口单出口的程序。实际上“顺序”与“循环”可以实现“选择”，故使用“顺序”、“循环”可实现单入口单出口的程序。 结构程序设计定义 如果一个程序的代码块仅仅通过顺序、选择和循环这3种基本控制结构进行连接，并且每个代码块只">
<meta property="og:type" content="article">
<meta property="og:title" content="【软件工程学习】 第六章 详细设计">
<meta property="og:url" content="https://remy-campanella.github.io/2026/01/04/25-10-22-1-SoftEng-6-detailed-design/index.html">
<meta property="og:site_name" content="remy-campanella.github.io">
<meta property="og:description" content="6.1 结构程序设计 6.1.1 程序结构设计概念  程序结构设计概念的提出 1966 年 Böhm 和 Jacopini 证明，使用“顺序”、“选择”、“循环”可实现单入口单出口的程序。实际上“顺序”与“循环”可以实现“选择”，故使用“顺序”、“循环”可实现单入口单出口的程序。 结构程序设计定义 如果一个程序的代码块仅仅通过顺序、选择和循环这3种基本控制结构进行连接，并且每个代码块只">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://remy-campanella.github.io/image/background/remy.jpg">
<meta property="article:published_time" content="2026-01-04T06:54:43.000Z">
<meta property="article:modified_time" content="2026-01-04T06:54:43.058Z">
<meta property="article:author" content="Remy Campanella">
<meta property="article:tag" content="学习笔记">
<meta property="article:tag" content="软件工程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://remy-campanella.github.io/image/background/remy.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "【软件工程学习】 第六章 详细设计",
  "url": "https://remy-campanella.github.io/2026/01/04/25-10-22-1-SoftEng-6-detailed-design/",
  "image": "https://remy-campanella.github.io/image/background/remy.jpg",
  "datePublished": "2026-01-04T06:54:43.000Z",
  "dateModified": "2026-01-04T06:54:43.058Z",
  "author": [
    {
      "@type": "Person",
      "name": "Remy Campanella",
      "url": "https://remy-campanella.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/image/icon/icon.png"><link rel="canonical" href="https://remy-campanella.github.io/2026/01/04/25-10-22-1-SoftEng-6-detailed-design/index.html"><link rel="preconnect" href="https://unpkg.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@7.0.1/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://unpkg.com/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【软件工程学习】 第六章 详细设计',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/scripts/css/font.css"><!-- hexo injector head_end start -->
    <link rel="stylesheet" href="/css/gallery.css" media="print" onload="this.media='all'">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/image/icon/loading.gif" data-original="/image/icon/Cover.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">70</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about"><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/album"><span> 图库</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/image/background/remy.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/image/icon/loading.gif" data-original="/image/icon/icon.png" alt="Logo"><span class="site-name">remy-campanella.github.io</span></a><a class="nav-page-title" href="/"><span class="site-name">【软件工程学习】 第六章 详细设计</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about"><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/album"><span> 图库</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">【软件工程学习】 第六章 详细设计</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2026-01-04T06:54:43.000Z" title="发表于 2026-01-04 14:54:43">2026-01-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-01-04T06:54:43.058Z" title="更新于 2026-01-04 14:54:43">2026-01-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/">软件工程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="结构程序设计">6.1 结构程序设计</h2>
<h3 id="程序结构设计概念">6.1.1 程序结构设计概念</h3>
<ol type="1">
<li><p><strong>程序结构设计概念的提出</strong><br />
1966 年 Böhm 和 Jacopini 证明，使用“顺序”、“选择”、“循环”可实现单入口单出口的程序。实际上“顺序”与“循环”可以实现“选择”，故使用“顺序”、“循环”可实现单入口单出口的程序。</p></li>
<li><p><strong>结构程序设计定义</strong><br />
如果一个程序的代码块仅仅通过顺序、选择和循环这3种基本控制结构进行连接，并且每个代码块只有一个入口和一个出口，则称这个程序是结构化的。</p>
<p>结构程序设计是尽可能少用 <code>GO TO</code> 语句的程序设计方法。最好仅在检测出错误时才使用 <code>GO TO</code> 语句，而且应该总是使用前向 <code>GO TO</code> 语句。</p></li>
<li><p><strong>结构程序设计的分类</strong></p>
<ul>
<li>如果只允许使用顺序、<code>IF-THEN-ELSE</code> 型分支和<code>DO-WHILE</code> 型循环这 3 种基本控制结构，则称为<strong>经典的结构程序设计</strong>。</li>
<li>如果除了上述 3 种基本控制结构之外，还允许使用 <code>DO-CASE</code> 型多分支结构和 <code>DO-UNTIL</code> 型循环结构，则称为<strong>扩展的结构程序设计</strong>。</li>
<li>如果再允许使用 <code>LEAVE</code>（或 <code>BREAK</code>）结构，则称为<strong>修正的结构程序设计</strong>。</li>
</ul></li>
</ol>
<h3 id="程序的几种结构">6.2.2 程序的几种结构</h3>
<ol type="1">
<li><p><strong>什么是好的程序结构？</strong><br />
结构清晰、易于读写、易于验证、可靠性好、可维护性高。</p></li>
<li><p><strong>结构程序</strong><br />
只包含三种基本控制结构，且程序块均只有一个入口和一个出口。</p>
<ul>
<li><strong>序列结构（开型结构）</strong><br />

<pre class="mermaid">     graph LR

I(("IN"))
A["A"]
B["B"]
O(("OUT"))

I --> A --> B --> O</pre></li>
<li><strong>选择结构（开型结构）</strong><br />

<pre class="mermaid">     flowchart LR

I(("IN"))
A["A"]
B["B"]
D{"Decision"}
O(("OUT"))

I --> D --> A --> O
D --> B --> O</pre></li>
</ul></li>
</ol>
<ul>
<li><strong>循环结构（闭型结构）</strong><br />

<pre class="mermaid">    flowchart LR

I(("IN"))
A["A"]
B["B"]
D{"Decision"}
O(("OUT"))
P((" "))

D --> A --> P
I --> P --> B --> D --> O</pre></li>
</ul>
<h2 id="人机界面设计">6.2 人机界面设计</h2>
<h3 id="设计问题">6.2.1 设计问题</h3>
<ol type="1">
<li><p><strong>系统响应时间</strong><br />
系统响应时间指用户完成某个控制动作到软件给出预期的响应的时间。</p>
<ul>
<li><p><strong>长度</strong><br />
如果系统响应时间过长，用户可能会感到焦急。但是，当用户工作速度由人机界面决定时，过短的系统响应时间会加快用户工作节奏，导致出错。</p></li>
<li><p><strong>易变性</strong><br />
系统响应时间相对平均响应时间的偏差。不稳定的系统响应时间会打乱用户工作节奏，时用户怀疑系统工作出错。</p></li>
</ul></li>
<li><p><strong>用户帮助设施</strong></p>
<ul>
<li><p>在用户与系统交互期间，<strong>是否任何时刻都能获取帮助</strong>？<br />
提供部分帮助信息与提供全部帮助信息。</p></li>
<li><p><strong>用户怎样请求帮助？</strong><br />
帮助菜单、特殊功能键、HELP 命令等。</p></li>
<li><p><strong>怎样显示帮助信息？</strong><br />
独立窗口、指出参考某文档（不理想）、屏幕固定位置简短提示等。</p></li>
<li><p><strong>用户怎样返回正常工作？</strong></p></li>
<li><p><strong>怎样组织帮助信息？</strong><br />
平面结构、层次结构、超文本结构等。</p></li>
</ul></li>
<li><p><strong>出错信息处理</strong><br />
一般来讲，交互式系统给出的错误与警告信息，应该</p>
<ul>
<li>用用户可以理解的语言描述问题。</li>
<li>提供从错误中恢复的建设性意见。</li>
<li>指出错误可能导致哪些负面后果。</li>
<li>伴随听觉或视觉上的提示。</li>
<li>不能带有指责色彩。</li>
</ul></li>
<li><p><strong>命令交互</strong><br />
提供命令交互功能时，必须考虑</p>
<ul>
<li>是否每个菜单都有对应命令？</li>
<li>采用何种命令形式？</li>
<li>学习和记忆命令的难度有多大？忘记了命令怎么办？</li>
<li>是否可以定制和缩写？</li>
</ul></li>
</ol>
<h3 id="设计过程">6.2.2 设计过程</h3>
<p>用户界面设计是一个<strong>迭代</strong>的过程，通常先创建<strong>设计模型</strong>，再用<strong>原型</strong>实现这个设计模型，并由用户<strong>试用和评估</strong>，然后根据用户意见进行<strong>修改</strong>。</p>
<ol type="1">
<li><strong>工具</strong>
<ul>
<li>用户界面工具箱</li>
<li>用户界面开发系统</li>
<li><strong>作用</strong><br />
为简化窗口、菜单、设备交互、出错信息、命令及交互环境的许多其他元素的创建，提供了各种例程或对象。</li>
<li><strong>方式</strong>
<ul>
<li>用基于语言的方式</li>
<li>基于图形的方式</li>
</ul></li>
</ul></li>
<li><strong>用户界面的评估</strong>
<ul>
<li><strong>非正式评估</strong><br />
例如，用户即兴发表一些反馈意见；</li>
<li><strong>正式评估</strong><br />
例如，运用统计学方法评价全体终端用户填写的调查表。</li>
</ul></li>
</ol>
<h3 id="人机界面设计指南">6.2.3 人机界面设计指南</h3>
<ol type="1">
<li><p><strong>一般交互指南</strong><br />
一般交互指南涉及信息显示、数据输入和系统整体控制，因此，这类指南是全局性的，忽略它们将承担较大风险。</p>
<p>一个交互界面应该做到</p>
<ul>
<li><p><strong>保持一致性</strong><br />
菜单选择、命令输入、数据显示等应使用已知的功能。</p></li>
<li><p><strong>提供有意义的反馈</strong></p></li>
<li><p><strong>在执行有较大破坏性的操作前应要求用户确认</strong></p></li>
<li><p><strong>允许取消（回退）绝大多数操作</strong><br />
</p></li>
<li><p><strong>减少两次操作器件需要记忆的信息</strong></p></li>
<li><p><strong>提高对话、移动、思考的效率</strong></p></li>
<li><p><strong>允许犯错</strong><br />
保护自己不受严重错误的破坏。</p></li>
<li><p><strong>按功能对动作分类，据此设计屏幕布局</strong></p></li>
<li><p><strong>提供对用户工作内容敏感的帮助设施</strong></p></li>
<li><p><strong>用简单的动词短语作为命令名</strong></p></li>
</ul></li>
<li><p><strong>信息显示指南</strong></p>
<ul>
<li>只显示与当前工作内容有关的信息。</li>
<li>不要用数据淹没用户，应该用便于用户迅速吸取信息的方式来表示数据。</li>
<li>使用一致的标记、标准的缩写和可预知的颜色。</li>
<li>允许用户保持可视化的语境。</li>
<li>产生有意义的出错信息。</li>
<li>使用大小写、缩进和文本分组以帮助理解。</li>
<li>使用窗口分隔不同类型的信息。</li>
<li>使用“模拟”显示方式表示信息，以使信息更容易被用户提取。</li>
<li>高效率地使用显示屏。</li>
</ul></li>
<li><p><strong>数据输入指南</strong></p>
<ul>
<li>尽量减少用户的输入动作。</li>
<li>保持信息显示和数据输入之间的一致性。</li>
<li>允许用户自定义输入。</li>
<li>交互应该是灵活的，并且可调整成用户最喜欢的输入方式。</li>
<li>使在当前动作语境中不适用的命令不起作用。</li>
<li>让用户控制交互流。</li>
<li>对所有输入动作都提供帮助</li>
<li>消除冗余的输入。</li>
</ul></li>
</ol>
<h2 id="过程设计的工具">6.3 过程设计的工具</h2>
<h3 id="程序流程图">6.3.1 程序流程图</h3>
<p>图例<br />
<img src="/image/icon/loading.gif" data-original="/image/25-10-22-1-SoftEng-6-detailed-design/1761095660399.webp" alt="1761095660399" /></p>
<h3 id="盒图">6.3.2 盒图</h3>
<p>盒图是一种不违背结构程序设计精神的图形工具。它有下述特点</p>
<ul>
<li>功能域（即一个特定控制结构的作用域）明确，可以从盒图上一眼就看出来。</li>
<li>不可能任意转移控制。</li>
<li>很容易确定局部和全程数据的作用域。</li>
<li>很容易表现嵌套关系，也可以表示模块的层次结构。</li>
</ul>
<figure>
<img src="/image/icon/loading.gif" data-original="/image/25-10-22-1-SoftEng-6-detailed-design/1761096060061.webp" alt="1761096060061" />
<figcaption aria-hidden="true">1761096060061</figcaption>
</figure>
<h3 id="pad-图">6.3.3 PAD 图</h3>
<p>PAD 图使用二维树形结构表示程序流程，使将图翻译位代码操作较为容易。<br />
<img src="/image/icon/loading.gif" data-original="/image/25-10-22-1-SoftEng-6-detailed-design/1761096203817.webp" alt="1761096203817" /><br />
<img src="/image/icon/loading.gif" data-original="/image/25-10-22-1-SoftEng-6-detailed-design/1761096281557.webp" alt="1761096281557" /></p>
<h3 id="判定表">6.3.4 判定表</h3>
<p>判定表能够清晰地表示复杂的条件组合与应做的动作之间的对应关系。<br />
<img src="/image/icon/loading.gif" data-original="/image/25-10-22-1-SoftEng-6-detailed-design/1761096416216.webp" alt="1761096416216" /></p>
<h3 id="判定树">6.3.5 判定树</h3>
<p>判定树是判定表的变种，它也能清晰地表示复杂的条件组合与应做的动作之间的对应关系。判定树的优点在于，它的形式简单到不需任何说明，一眼就可以看出其含义，因此易于掌握和使用。<br />
<img src="/image/icon/loading.gif" data-original="/image/25-10-22-1-SoftEng-6-detailed-design/1761096520552.webp" alt="1761096520552" /></p>
<h3 id="过程设计语言">6.3.6 过程设计语言</h3>
<p>过程设计语言（PDL）也称为<strong>伪码</strong>，这是一个笼统的名称，现在有许多种不同的过程设计语言在使用。它是用正文形式表示数据和处理过程的设计工具。</p>
<p>PDL 应该具有下述特点。</p>
<ul>
<li>关键字的固定语法，它提供了结构化控制结构、数据说明和模块化的特点。</li>
<li>自然语言的自由语法，它描述处理特点。</li>
<li>数据说明的手段。</li>
<li>模块定义和调用的技术，应该提供各种接口描述模式。</li>
</ul>
<p>PDL 作为一种设计工具有如下一些优点。</p>
<ul>
<li>可以作为注释直接插在源程序中间。</li>
<li>可以使用普通的正文编辑程序或文字处理系统，很方便地完成 PDL 的书写和编辑工作。</li>
<li>已经有自动处理 PDL 的程序存在，而且可以自动由 PDL 生成程序代码。</li>
</ul>
<h2 id="面向数据结构的设计方法">6.4 面向数据结构的设计方法</h2>
<p>面向数据结构的设计方法的最终目标是得出对程序处理过程的描述。这种设计方法并不明显地使用软件结构的概念，模块是设计过程的副产品，对于模块独立原理也没有给予应有的重视。因此，这种方法最适合于在详细设计阶段使用，也就是说，在完成了软件结构设计之后，可以使用面向数据结构的方法来设计每个模块的处理过程。</p>
<h3 id="jackson-图">6.4.1 Jackson 图</h3>
<figure>
<img src="/image/icon/loading.gif" data-original="/image/25-10-22-1-SoftEng-6-detailed-design/1767507960183.webp" alt="1767507960183" />
<figcaption aria-hidden="true">1767507960183</figcaption>
</figure>
<h3 id="改进的-jackson-图">6.4.2 改进的 Jackson 图</h3>
<figure>
<img src="/image/icon/loading.gif" data-original="/image/25-10-22-1-SoftEng-6-detailed-design/1767508003246.webp" alt="1767508003246" />
<figcaption aria-hidden="true">1767508003246</figcaption>
</figure>
<h3 id="jackson-法">6.4.3 Jackson 法</h3>
<p>Jackson 结构程序设计方法基本上由下述 5 个步骤组成。</p>
<ol type="1">
<li><p>分析并确定输入数据和输出数据的逻辑结构，并用 Jackson 图描绘这些数据结构。</p></li>
<li><p>找出输入数据结构和输出数据结构中有对应关系的数据单元。</p></li>
<li><p>用下述 3 条规则从描绘数据结构的 Jackson 图导出描绘程序结构的 Jackson 图。</p>
<ul>
<li>为每对有对应关系的数据单元，按照它们在数据结构图中的层次在程序结构图的相应层次画一个处理框。</li>
<li>根据输入数据结构中剩余的每个数据单元所处的层次，在程序结构图的相应层次分别为它们画上对应的处理框。</li>
<li>根据输出数据结构中剩余的每个数据单元所处的层次，在程序结构图的相应层次分别为它们画上对应的处理框。</li>
</ul></li>
<li><p>列出所有操作和条件（包括分支条件和循环结束条件），并且把它们分配到程序结构图的适当位置。</p></li>
<li><p>用伪码表示程序。<br />
Jackson方法中使用的伪码和Jackson图是完全对应的。</p></li>
</ol>
<h2 id="程序复杂度的定量度量">6.5 程序复杂度的定量度量</h2>
<h3 id="mccabe-方法">6.5.1 McCabe 方法</h3>
<ol type="1">
<li><p><strong>流图</strong><br />
McCabe 方法根据程序控制流的复杂程度定量度量程序的复杂程度，这样度量出的结果称为<strong>程序的环形复杂度</strong>。</p>
<p>流图实质上是“退化了的”程序流程图，描绘程序的控制流程，<strong>不表现对数据的具体操作以及分支或循环的具体条件</strong>。</p>
<figure>
<img src="/image/icon/loading.gif" data-original="/image/25-10-22-1-SoftEng-6-detailed-design/1767508343735.webp" alt="1767508343735" />
<figcaption aria-hidden="true">1767508343735</figcaption>
</figure></li>
<li><p><strong>计算环形复杂度</strong></p>
<ul>
<li>流图中线性无关的区域数等于环形复杂度。</li>
<li>流图 <span class="math inline">\(G\)</span> 的环形复杂度 <span class="math inline">\(V(G)=E-N+2\)</span>，其中，<span class="math inline">\(E\)</span> 是流图中边的条数，<span class="math inline">\(N\)</span> 是结点数。</li>
<li>流图 <span class="math inline">\(G\)</span> 的环形复杂度 <span class="math inline">\(V(G)=P+1\)</span>，其中，<span class="math inline">\(P\)</span> 是流图中判定结点的数目。</li>
</ul></li>
<li><p><strong>环形复杂度的原理</strong><br />
<code>if</code>、<code>for</code>、<code>while</code> 语句都是判定语句。如果程序只有顺序语句，程序不会形成封闭区域，计其复杂度为 1。判定语句会形成封闭的区域，<strong>每增加 1个判定语句，增加一个区域，复杂度 +1</strong>。</p></li>
<li><p><strong>环形复杂度的用途</strong><br />
对测试难度的一种定量度量，也能对软件最终的可靠性给出某种预测。实践表明，模块规模以 <span class="math inline">\(V(G) \leq 10\)</span> 为宜。</p></li>
</ol>
<h3 id="halstead-方法">6.5.2 Halstead 方法</h3>
<p>根据程序中运算符和操作数的总数来度量程序的复杂程度。</p>
<p>令 <span class="math inline">\(N_1\)</span> 为程序中运算符出现的总次数，<span class="math inline">\(N_2\)</span> 为操作数出现的总次数，程序长度 <span class="math inline">\(N\)</span> 定义为：<br />
<span class="math display">\[
N=N_1+N_2
\]</span></p>
<p>程序中使用的不同运算符（包括关键字）的个数 <span class="math inline">\(n_1\)</span>，以及不同操作数（变量和常数）的个数 <span class="math inline">\(n_2\)</span>。Halstead 给出预测程序长度的公式如下：<br />
<span class="math display">\[
H = n_1 \log_2n_1+n_2 \log_2n_2
\]</span></p>
<p>多次验证都表明，预测的长度 <span class="math inline">\(H\)</span> 与实际长度 <span class="math inline">\(N\)</span> 非常接近。</p>
<p>Halstead 还给出了预测程序中包含错误的个数的公式如下：<br />
<span class="math display">\[
E = \frac{N \log_2(n_1+n_2)}{3000}
\]</span></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://remy-campanella.github.io">Remy Campanella</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://remy-campanella.github.io/2026/01/04/25-10-22-1-SoftEng-6-detailed-design/">https://remy-campanella.github.io/2026/01/04/25-10-22-1-SoftEng-6-detailed-design/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://remy-campanella.github.io" target="_blank">remy-campanella.github.io</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><a class="post-meta__tags" href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/">软件工程</a></div><div class="post-share"><div class="social-share" data-image="/image/background/remy.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://unpkg.com/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://unpkg.com/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2026/01/04/26-1-4-1-SoftEng-5-general-dgn/" title="【软件工程学习】 第五章 总体设计"><img class="cover" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">【软件工程学习】 第五章 总体设计</div></div><div class="info-2"><div class="info-item-1">一、 总体设计概述  定义与目的：  总体设计（又称概要设计或初步设计）的基本目的是回答“概括地说，系统应该如何实现”这个问题。 核心任务是设计软件结构，确定系统由哪些模块组成以及模块间的关系。  设计过程：  包含两个阶段：系统设计（从技术角度考虑最佳方案）和结构设计（确定程序结构）。 典型步骤包括：设想供选择的方案、选取合理方案、推荐最佳方案、功能分解、设计软件结构、设计数据库、制定测试计划、书写文档、审查和复审。 ### 二、 设计原理  模块化：  模块是由边界元素限定的程序元素序列（如过程、函数、对象）。模块化是将系统划分为独立命名的模块。 虽然增加模块数量可以降低单个模块成本，但会增加接口成本，因此存在一个使总成本最小的最佳模块数目。 优势：结构清晰、易于理解、测试调试方便、提高可靠性和可修改性、便于组织管理。  抽象：  抽象是抽出事物的本质特性而忽略细节。软件工程的每一步都是对解法抽象层次的精化。  逐步求精：  为了集中精力解决主要问题，尽量推迟对细节的考虑。这是自顶向下的设计策略，与模块化紧密相关。  信息...</div></div></div></a><a class="pagination-related" href="/2026/01/04/26-1-4-2-SoftEng-7-real/" title="【软件工程学习】 第七章 实现"><img class="cover" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">【软件工程学习】 第七章 实现</div></div><div class="info-2"><div class="info-item-1">7.1 编码 7.1.1 选择程序设计语言  选择适宜的程序设计语言的原因  根据设计去完成编码时，困难最少； 可以减少需要的程序测试量； 可以得到更容易阅读和更容易维护的程序。  高级语言优于汇编语言  汇编语言编码需要把软件设计翻译成机器操作的序列，既困难又容易出差错； 高级语言写程序比用汇编语言写程序生产率可以提高好几倍； 用高级语言写的程序容易阅读、容易测试、容易调试、容易维护。   7.1.2 编码风格  程序内部文档  标识符：含义鲜明的名字、缩写规则一致、为名字加注解； 注解：正确性，简要描述模块的功能、主要算法、接口特点、重要数据以及开发简史或解释包含这段代码的必要性； 视觉组织：适当的阶梯形式使程序的层次结构清晰明显。  数据说明 数据说明的次序应该标准化；  当多个变量名在一个语句中说明时，应该按字母顺序排列这些变量； 如果设计时使用了一个复杂的数据结构，则应该用注解说明用程序设计语言实现这个数据结构的方法和特点。  语句构造  不要为了节省空间而把多个语句写在同一行； 尽量避免复杂的条件测试；...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/10/15/25-10-15-1-SoftEng-1-intro/" title="【软件工程学习】 第一章 软件工程概述"><img class="cover" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-15</div><div class="info-item-2">【软件工程学习】 第一章 软件工程概述</div></div><div class="info-2"><div class="info-item-1">一、软件工程的价值与应用场景  实际用途  国家考试（如软考）、工作面试（如亚麻面试）、毕业设计、读研。 参与需求分析、撰写需求/设计报告、招标书/投标书、项目申请书。 开发原型（需掌握原型工具）、开发软件（需学习开发框架）。 绘制模型图/流程图、AI开发APP等。  工作场景  文档撰写、模型设计、原型开发、前后端分离开发、系统设计等。   二、软件工程学科与教材分析  经典教材  《Software Engineering: A Practitioner’s Approach》（2020年）：涵盖软件过程、建模、质量、项目管理等。 《软件工程导论》（2013年）：传统生命周期与面向对象方法。 《面向对象软件工程：敏捷统一方法》（2014/2023年）：强调领域建模、架构设计、交互建模等。 《软件工程：谷歌的实践》（2022年）：聚焦文化、流程、工具（如代码评审、CI/CD）。  学科演变  从传统软件工程→面向对象→敏捷开发→系统工程。 新趋势：低代码、AI开发、产品化（从Project到Product）。   三、软...</div></div></div></a><a class="pagination-related" href="/2025/10/15/25-10-15-2-SoftEng-2-feasibility/" title="【软件工程学习】 第二章 可行性研究"><img class="cover" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-15</div><div class="info-item-2">【软件工程学习】 第二章 可行性研究</div></div><div class="info-2"><div class="info-item-1">2.1 可行性研究的任务  任务 并非任何问题都有简单明显的解决办法。如果问题没有可行的解，那么花费在这项工程上的任何时间、人力、软硬件资源和经费，都是无谓的浪费。可行性研究的目的，就是用最小的代价在尽可能短的时间内确定问题是否能够解决。 分析过程  分析和澄清问题定义。 导出系统逻辑模型。 探索若干种可选的主要解法。   2.2 可行性研究过程        步骤      复查系统规模和目标 实质上是为了确保分析员正在解决的问题确实是要求他解决的问题。   研究目前正在使用的系统 新系统必须要完成旧系统的基本功能；新系统必须要解决旧系统的问题。   导出新系统的高层逻辑模型 参考现有系统的逻辑模型，设想目标系统的逻辑模型，最后根据目标系统的逻辑模型建造新的物理系统。   进一步定义问题 在之前的基础上再次定义问题，构成循环，直到提出的逻辑模型完全符合系统目标。   导出和评价供选择的解法 为每个解法考虑操作、经济方面的可行性，制定实现进度表。   推荐行动方针    草拟开发计划...</div></div></div></a><a class="pagination-related" href="/2026/01/02/25-12-3-1-SoftEng-3-demand-aly/" title="【软件工程学习】 第三章 需求分析"><img class="cover" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-02</div><div class="info-item-2">【软件工程学习】 第三章 需求分析</div></div><div class="info-2"><div class="info-item-1">需求分析是软件定义时期的最后一个阶段，它的基本任务是准确地回答“系统必须做什么”这个问题。 3.1 需求分析的任务 3.1.1 确定对系统的综合要求 通常对软件系统有下述几方面的综合要求。  功能需求 指定系统必须提供的服务。 性能需求 指定系统必须满足的定时约束或容量约束。 可靠性和可用性需求 定量地指定系统的可靠性。可用性与可靠性密切相关，它量化了用户可以使用系统的程度。 出错处理需求 系统对环境错误应该怎样响应。 接口需求 应用系统与它的环境通信的格式。 约束 在设计或实现应用系统时应遵守的限制条件。 逆向需求 软件系统不应该做什么。 将来可能提出的要求 虽然不属于当前系统开发范畴，但是据分析将来很可能会提出来的要求。  3.1.2 分析系统的数据要求 任何一个软件系统本质上都是信息处理系统，系统必须处理的信息和系统应该产生的信息在很大程度上决定了系统的面貌，对软件设计有深远影响。 复杂的数据由许多基本的数据元素组成，数据结构表示数据元素之间的逻辑关系。利用数据字典可以全面准确地定义数据，但是数据字典的缺点是不够形象直观。为了...</div></div></div></a><a class="pagination-related" href="/2026/01/04/26-1-4-2-SoftEng-7-real/" title="【软件工程学习】 第七章 实现"><img class="cover" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-04</div><div class="info-item-2">【软件工程学习】 第七章 实现</div></div><div class="info-2"><div class="info-item-1">7.1 编码 7.1.1 选择程序设计语言  选择适宜的程序设计语言的原因  根据设计去完成编码时，困难最少； 可以减少需要的程序测试量； 可以得到更容易阅读和更容易维护的程序。  高级语言优于汇编语言  汇编语言编码需要把软件设计翻译成机器操作的序列，既困难又容易出差错； 高级语言写程序比用汇编语言写程序生产率可以提高好几倍； 用高级语言写的程序容易阅读、容易测试、容易调试、容易维护。   7.1.2 编码风格  程序内部文档  标识符：含义鲜明的名字、缩写规则一致、为名字加注解； 注解：正确性，简要描述模块的功能、主要算法、接口特点、重要数据以及开发简史或解释包含这段代码的必要性； 视觉组织：适当的阶梯形式使程序的层次结构清晰明显。  数据说明 数据说明的次序应该标准化；  当多个变量名在一个语句中说明时，应该按字母顺序排列这些变量； 如果设计时使用了一个复杂的数据结构，则应该用注解说明用程序设计语言实现这个数据结构的方法和特点。  语句构造  不要为了节省空间而把多个语句写在同一行； 尽量避免复杂的条件测试；...</div></div></div></a><a class="pagination-related" href="/2026/01/04/26-1-4-1-SoftEng-5-general-dgn/" title="【软件工程学习】 第五章 总体设计"><img class="cover" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-04</div><div class="info-item-2">【软件工程学习】 第五章 总体设计</div></div><div class="info-2"><div class="info-item-1">一、 总体设计概述  定义与目的：  总体设计（又称概要设计或初步设计）的基本目的是回答“概括地说，系统应该如何实现”这个问题。 核心任务是设计软件结构，确定系统由哪些模块组成以及模块间的关系。  设计过程：  包含两个阶段：系统设计（从技术角度考虑最佳方案）和结构设计（确定程序结构）。 典型步骤包括：设想供选择的方案、选取合理方案、推荐最佳方案、功能分解、设计软件结构、设计数据库、制定测试计划、书写文档、审查和复审。 ### 二、 设计原理  模块化：  模块是由边界元素限定的程序元素序列（如过程、函数、对象）。模块化是将系统划分为独立命名的模块。 虽然增加模块数量可以降低单个模块成本，但会增加接口成本，因此存在一个使总成本最小的最佳模块数目。 优势：结构清晰、易于理解、测试调试方便、提高可靠性和可修改性、便于组织管理。  抽象：  抽象是抽出事物的本质特性而忽略细节。软件工程的每一步都是对解法抽象层次的精化。  逐步求精：  为了集中精力解决主要问题，尽量推迟对细节的考虑。这是自顶向下的设计策略，与模块化紧密相关。  信息...</div></div></div></a><a class="pagination-related" href="/2025/10/15/25-10-14-1-CompOrg-1-intro/" title="【计算机组成原理】 第一章 概论"><img class="cover" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-15</div><div class="info-item-2">【计算机组成原理】 第一章 概论</div></div><div class="info-2"><div class="info-item-1">教材 计算机组成原理（第四版） 蒋本珊 清华大学出版社 第一章 概论 1.1 电子计算机与存储程序控制  存储程序的计算机 世界上第一台数字计算机：美国 ENIAC（1946）。 早期存储程序控制的计算机：美国 EDVAC（Von Neumann, 1951），英国 EDSAC（1949）。 存储程序概念（Von Neumann, 1945）  计算机硬件应由五大基本部件组成。 计算机内部采用二进制表示指令和数据。 将程序与原始数据存入存储器中，在启动计算机工作。   1.2 计算机的硬件组成  计算机的主要部件        输入设备 将人们编好的程序和原始数据输送到计算机中，并将其转化为计算机内部所能识别和接受的信息方式的部件   输出设备 将计算机的处理结果以人或其他设备所能接收的形式送出计算机的设备   存储器 用于存放程序和数据的部件   运算器 对信息进行处理和运算的部件，又称算数逻辑运算部件（Arithmetic and Logical Unit, ALU）   控制器 按照人们预先...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/image/icon/loading.gif" data-original="/image/icon/Cover.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Remy Campanella</div><div class="author-info-description">A Remy Campanella blog website on Github.</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">70</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/remy-campanella"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站介绍帖、自我介绍帖内容已移至“关于”页面，目录帖内容已移至“分类”页面。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.</span> <span class="toc-text">6.1 结构程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">6.1.1 程序结构设计概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">6.2.2 程序的几种结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%BA%E6%9C%BA%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.</span> <span class="toc-text">6.2 人机界面设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.</span> <span class="toc-text">6.2.1 设计问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">6.2.2 设计过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%BA%E6%9C%BA%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%8D%97"><span class="toc-number">2.3.</span> <span class="toc-text">6.2.3 人机界面设计指南</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="toc-number">3.</span> <span class="toc-text">6.3 过程设计的工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">3.1.</span> <span class="toc-text">6.3.1 程序流程图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%92%E5%9B%BE"><span class="toc-number">3.2.</span> <span class="toc-text">6.3.2 盒图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pad-%E5%9B%BE"><span class="toc-number">3.3.</span> <span class="toc-text">6.3.3 PAD 图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E5%AE%9A%E8%A1%A8"><span class="toc-number">3.4.</span> <span class="toc-text">6.3.4 判定表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E5%AE%9A%E6%A0%91"><span class="toc-number">3.5.</span> <span class="toc-text">6.3.5 判定树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80"><span class="toc-number">3.6.</span> <span class="toc-text">6.3.6 过程设计语言</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">6.4 面向数据结构的设计方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jackson-%E5%9B%BE"><span class="toc-number">4.1.</span> <span class="toc-text">6.4.1 Jackson 图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E7%9A%84-jackson-%E5%9B%BE"><span class="toc-number">4.2.</span> <span class="toc-text">6.4.2 改进的 Jackson 图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jackson-%E6%B3%95"><span class="toc-number">4.3.</span> <span class="toc-text">6.4.3 Jackson 法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E5%AE%9A%E9%87%8F%E5%BA%A6%E9%87%8F"><span class="toc-number">5.</span> <span class="toc-text">6.5 程序复杂度的定量度量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mccabe-%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.</span> <span class="toc-text">6.5.1 McCabe 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#halstead-%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.</span> <span class="toc-text">6.5.2 Halstead 方法</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2026/01/05/25-12-16-1-CompOrg-10-review/" title="【计算机组成原理】 复习要点"><img src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【计算机组成原理】 复习要点"/></a><div class="content"><a class="title" href="/2026/01/05/25-12-16-1-CompOrg-10-review/" title="【计算机组成原理】 复习要点">【计算机组成原理】 复习要点</a><time datetime="2026-01-05T03:05:13.000Z" title="发表于 2026-01-05 11:05:13">2026-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/05/25-12-2-2-CompOrg-9-io-sys/" title="【计算机组成原理】 第九章 输入输出系统"><img src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【计算机组成原理】 第九章 输入输出系统"/></a><div class="content"><a class="title" href="/2026/01/05/25-12-2-2-CompOrg-9-io-sys/" title="【计算机组成原理】 第九章 输入输出系统">【计算机组成原理】 第九章 输入输出系统</a><time datetime="2026-01-05T03:03:19.257Z" title="发表于 2026-01-05 11:03:19">2026-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/05/25-12-2-2-CompOrg-8-ext-device/" title="【计算机组成原理】 第八章 外部设备"><img src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【计算机组成原理】 第八章 外部设备"/></a><div class="content"><a class="title" href="/2026/01/05/25-12-2-2-CompOrg-8-ext-device/" title="【计算机组成原理】 第八章 外部设备">【计算机组成原理】 第八章 外部设备</a><time datetime="2026-01-05T02:47:29.000Z" title="发表于 2026-01-05 10:47:29">2026-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/05/25-11-25-1-CompOrg-7-bus/" title="【计算机组成原理】 第七章 总线"><img src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【计算机组成原理】 第七章 总线"/></a><div class="content"><a class="title" href="/2026/01/05/25-11-25-1-CompOrg-7-bus/" title="【计算机组成原理】 第七章 总线">【计算机组成原理】 第七章 总线</a><time datetime="2026-01-05T02:47:06.000Z" title="发表于 2026-01-05 10:47:06">2026-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/05/25-11-11-1-CompOrg-6-cpu/" title="【计算机组成原理】 第六章 中央处理器"><img src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【计算机组成原理】 第六章 中央处理器"/></a><div class="content"><a class="title" href="/2026/01/05/25-11-11-1-CompOrg-6-cpu/" title="【计算机组成原理】 第六章 中央处理器">【计算机组成原理】 第六章 中央处理器</a><time datetime="2026-01-05T02:46:54.000Z" title="发表于 2026-01-05 10:46:54">2026-01-05</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By Remy Campanella</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.0</a></span></div><div class="footer_custom_text">源代码库版本 1.4.0</div></div><script type="text/javascript" id="maid-script" src="https://unpkg.com/mermaid@9.0.0/dist/mermaid.min.js"></script><script>if (window.mermaid) {
  var options = JSON.parse(document.getElementById('maid-script').getAttribute('mermaidoptioins'));
  mermaid.initialize(options);
}</script></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        loader: {
          load: [
            // Four font extension packages (optional)
            //- '[tex]/bbm',
            //- '[tex]/bboldx',
            //- '[tex]/dsfont',
            '[tex]/mhchem'
          ],
          paths: {
            'mathjax-newcm': '[mathjax]/../@mathjax/mathjax-newcm-font',

            //- // Four font extension packages (optional)
            //- 'mathjax-bbm-extension': '[mathjax]/../@mathjax/mathjax-bbm-font-extension',
            //- 'mathjax-bboldx-extension': '[mathjax]/../@mathjax/mathjax-bboldx-font-extension',
            //- 'mathjax-dsfont-extension': '[mathjax]/../@mathjax/mathjax-dsfont-font-extension',
            'mathjax-mhchem-extension': '[mathjax]/../@mathjax/mathjax-mhchem-font-extension'
          }
        },
        output: {
          font: 'mathjax-newcm',
        },
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
          packages: {
            '[+]': [
              'mhchem'
            ]
          }
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          menuOptions: {
            settings: {
              enrich: false  // Turn off Braille and voice narration text automatic generation
            }
          },
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://unpkg.com/mathjax@4.0.0/tex-mml-chtml.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://unpkg.com/mermaid@11.11.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start -->
    <script src="/js/gallery.js" async></script>
<!-- hexo injector body_end end -->
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 2,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>