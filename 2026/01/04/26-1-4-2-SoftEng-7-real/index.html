<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>【软件工程学习】 第七章 实现 | remy-campanella.github.io</title><meta name="author" content="Remy Campanella"><meta name="copyright" content="Remy Campanella"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="7.1 编码 7.1.1 选择程序设计语言  选择适宜的程序设计语言的原因  根据设计去完成编码时，困难最少； 可以减少需要的程序测试量； 可以得到更容易阅读和更容易维护的程序。  高级语言优于汇编语言  汇编语言编码需要把软件设计翻译成机器操作的序列，既困难又容易出差错； 高级语言写程序比用汇编语言写程序生产率可以提高好几倍； 用高级语言写的程序容易阅读、容易测试、容易">
<meta property="og:type" content="article">
<meta property="og:title" content="【软件工程学习】 第七章 实现">
<meta property="og:url" content="https://remy-campanella.github.io/2026/01/04/26-1-4-2-SoftEng-7-real/index.html">
<meta property="og:site_name" content="remy-campanella.github.io">
<meta property="og:description" content="7.1 编码 7.1.1 选择程序设计语言  选择适宜的程序设计语言的原因  根据设计去完成编码时，困难最少； 可以减少需要的程序测试量； 可以得到更容易阅读和更容易维护的程序。  高级语言优于汇编语言  汇编语言编码需要把软件设计翻译成机器操作的序列，既困难又容易出差错； 高级语言写程序比用汇编语言写程序生产率可以提高好几倍； 用高级语言写的程序容易阅读、容易测试、容易">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://remy-campanella.github.io/image/background/remy.jpg">
<meta property="article:published_time" content="2026-01-04T08:31:45.000Z">
<meta property="article:modified_time" content="2026-01-04T08:34:32.254Z">
<meta property="article:author" content="Remy Campanella">
<meta property="article:tag" content="学习笔记">
<meta property="article:tag" content="软件工程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://remy-campanella.github.io/image/background/remy.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "【软件工程学习】 第七章 实现",
  "url": "https://remy-campanella.github.io/2026/01/04/26-1-4-2-SoftEng-7-real/",
  "image": "https://remy-campanella.github.io/image/background/remy.jpg",
  "datePublished": "2026-01-04T08:31:45.000Z",
  "dateModified": "2026-01-04T08:34:32.254Z",
  "author": [
    {
      "@type": "Person",
      "name": "Remy Campanella",
      "url": "https://remy-campanella.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/image/icon/icon.png"><link rel="canonical" href="https://remy-campanella.github.io/2026/01/04/26-1-4-2-SoftEng-7-real/index.html"><link rel="preconnect" href="https://unpkg.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@7.0.1/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://unpkg.com/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【软件工程学习】 第七章 实现',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/scripts/css/font.css"><!-- hexo injector head_end start -->
    <link rel="stylesheet" href="/css/gallery.css" media="print" onload="this.media='all'">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/image/icon/loading.gif" data-original="/image/icon/Cover.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">70</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about"><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/album"><span> 图库</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/image/background/remy.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/image/icon/loading.gif" data-original="/image/icon/icon.png" alt="Logo"><span class="site-name">remy-campanella.github.io</span></a><a class="nav-page-title" href="/"><span class="site-name">【软件工程学习】 第七章 实现</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about"><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/album"><span> 图库</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">【软件工程学习】 第七章 实现</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2026-01-04T08:31:45.000Z" title="发表于 2026-01-04 16:31:45">2026-01-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-01-04T08:34:32.254Z" title="更新于 2026-01-04 16:34:32">2026-01-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/">软件工程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="编码">7.1 编码</h2>
<h3 id="选择程序设计语言">7.1.1 选择程序设计语言</h3>
<ol type="1">
<li><strong>选择适宜的程序设计语言的原因</strong>
<ul>
<li>根据设计去完成编码时，困难最少；</li>
<li>可以减少需要的程序测试量；</li>
<li>可以得到更容易阅读和更容易维护的程序。</li>
</ul></li>
<li><strong>高级语言优于汇编语言</strong>
<ul>
<li>汇编语言编码需要把软件设计翻译成机器操作的序列，既困难又容易出差错；</li>
<li>高级语言写程序比用汇编语言写程序生产率可以提高好几倍；</li>
<li>用高级语言写的程序容易阅读、容易测试、容易调试、容易维护。</li>
</ul></li>
</ol>
<h3 id="编码风格">7.1.2 编码风格</h3>
<ol type="1">
<li><strong>程序内部文档</strong>
<ul>
<li>标识符：含义鲜明的名字、缩写规则一致、为名字加注解；</li>
<li>注解：正确性，简要描述模块的功能、主要算法、接口特点、重要数据以及开发简史或解释包含这段代码的必要性；</li>
<li>视觉组织：适当的阶梯形式使程序的层次结构清晰明显。</li>
</ul></li>
<li><strong>数据说明</strong><br />
数据说明的次序应该标准化；
<ul>
<li>当多个变量名在一个语句中说明时，应该按字母顺序排列这些变量；</li>
<li>如果设计时使用了一个复杂的数据结构，则应该用注解说明用程序设计语言实现这个数据结构的方法和特点。</li>
</ul></li>
<li><strong>语句构造</strong>
<ul>
<li>不要为了节省空间而把多个语句写在同一行；</li>
<li>尽量避免复杂的条件测试；</li>
<li>尽量减少对“非”条件的测试；</li>
<li>避免大量使用循环嵌套和条件嵌套；<br />
利用括号使逻辑表达式或算术表达式的运算次序清晰直观。</li>
</ul></li>
<li><strong>输入输出</strong>
<ul>
<li>对所有输入数据都进行检验；</li>
<li>检查输入项重要组合的合法性；</li>
<li>保持输入格式简单；</li>
<li>使用数据结束标记，不要要求用户指定数据的数目；</li>
<li>明确提示交互式输入的请求，详细说明可用的选择或边界数值；</li>
<li>程序设计语言对格式有严格要求时，应保持输入格式一致；</li>
<li>设计良好的输出报表；</li>
<li>给所有输出数据加标志。</li>
</ul></li>
<li><strong>效率</strong>
<ul>
<li>程序运行时间</li>
<li>存储器效率</li>
<li>输入输出效率</li>
</ul></li>
</ol>
<h2 id="软件测试基础">7.2 软件测试基础</h2>
<h3 id="软件测试的目标">7.2.1 软件测试的目标</h3>
<p>测试的正确定义是“为了发现程序中的错误而执行程序的过程”。应该认识到<strong>测试决不能证明程序是正确的</strong>。即使经过了最严格的测试之后，仍然可能还有没被发现的错误潜藏在程序中。另外，在综合测试阶段通常由其他人员组成测试小组来完成测试工作。</p>
<h3 id="软件测试准则">7.2.2 软件测试准则</h3>
<p>主要的软件测试准则如下：</p>
<ul>
<li>所有测试都应该能追溯到<strong>用户需求</strong>；</li>
<li>应该远在测试开始之前就制定出<strong>测试计划</strong>；</li>
<li>把 <strong>Pareto 原理</strong>应用到软件测试中；</li>
<li>应该从“<strong>小规模</strong>”测试开始，并逐步进行“大规模”测试；</li>
<li>穷举测试是不可能的；</li>
<li>为了达到最佳的测试效果，应该由<strong>独立的第三方</strong>从事测试工作。</li>
</ul>
<h3 id="测试方法">7.2.3 测试方法</h3>
<ol type="1">
<li><p><strong>黑盒测试</strong><br />
黑盒测试（又称<strong>功能测试</strong>）把程序看作一个黑盒子，完全不考虑程序的内部结构和处理过程。黑盒测试是在<strong>程序接口</strong>进行的测试，只检查程序功能是否<strong>能按照规格说明书的规定正常使用</strong>，程序是否能<strong>适当地接收输入数据并产生正确的输出信息</strong>，程序运行过程中<strong>能否保持外部信息（例如数据库或文件）的完整性</strong>。</p></li>
<li><p><strong>白盒测试</strong><br />
白盒测试（又称<strong>结构测试</strong>）是把程序看成装在一个透明的白盒子里，测试者完全知道程序的结构和处理算法。这种方法按照程序内部的逻辑测试程序，检测程序中的<strong>主要执行通路是否都能按预定要求正确工作</strong>。</p></li>
</ol>
<h3 id="测试步骤">7.2.4 测试步骤</h3>
<ol type="1">
<li><p><strong>模块测试</strong><br />
把<strong>每个模块</strong>作为一个单独的实体来测试，而且通常比较容易设计检验模块正确性的测试方案。</p>
<p>模块测试的目的是保证<strong>每个模块作为一个单元能正确运行</strong>，所以模块测试通常又称为<strong>单元测试</strong>。在这个测试步骤中所发现的往往是<strong>编码和详细设计</strong>的错误。</p></li>
<li><p><strong>子系统测试</strong><br />
子系统测试是把经过单元测试的模块放在一起<strong>形成一个子系统</strong>来测试。<strong>模块相互间的协调和通信</strong>是这个测试过程中的主要问题，因此，这个步骤着重测试<strong>模块的接口</strong>。</p></li>
<li><p><strong>系统测试</strong><br />
系统测试是把经过测试的子系统装配成<strong>一个完整的系统</strong>来测试。在这个过程中不仅应该发现<strong>设计和编码</strong>的错误，还应该验证系统<strong>确实能提供需求说明书中指定的功能</strong>，而且系统的<strong>动态特性</strong>也符合预定要求。在这个测试步骤中发现的往往是<strong>软件设计</strong>中的错误，也可能发现<em>需求说明</em>中的错误。</p></li>
</ol>
<p>子系统测试和系统测试，都兼有检测和组装两重含义，通常称为<strong>集成测试</strong>。</p>
<ol start="4" type="1">
<li><p><strong>验收测试</strong><br />
验收测试把软件系统作为<strong>单一的实体</strong>进行测试，测试内容与系统测试基本类似，但是它是在<strong>用户积极参与</strong>下进行的，而且可能主要使用<strong>实际数据</strong>（系统将来要处理的信息）进行测试。</p>
<p>验收测试的目的是验证<strong>系统确实能够满足用户的需要</strong>，在这个测试步骤中发现的往往是<strong>系统需求说明书</strong>中的错误。验收测试也称为<strong>确认测试</strong>。</p></li>
</ol>
<h3 id="测试阶段的信息流">7.2.5 测试阶段的信息流</h3>
<figure>
<img src="/image/icon/loading.gif" data-original="/image/26-1-4-2-SoftEng-7-real/1767511042534.webp" alt="1767511042534" />
<figcaption aria-hidden="true">1767511042534</figcaption>
</figure>
<h2 id="单元测试">7.3 单元测试</h2>
<h3 id="测试重点">7.3.1 测试重点</h3>
<ol type="1">
<li><p><strong>模块接口</strong></p>
<ul>
<li><strong>测试对象</strong><br />
通过模块接口的数据流</li>
<li><strong>检查方面</strong>
<ul>
<li>参数的数目、次序、属性或单位系统与变元是否一致；</li>
<li>是否修改了只作输入用的变元；</li>
<li>全局变量的定义和用法在各个模块中是否一致。</li>
</ul></li>
</ul></li>
<li><p><strong>局部数据结构</strong></p>
<ul>
<li>局部数据说明</li>
<li>初始化</li>
<li>默认值</li>
</ul></li>
<li><p><strong>重要执行通路</strong><br />
由于通常不可能进行穷尽测试，因此，在单元测试期间选择<strong>最有代表性、最可能发现错误</strong>的执行通路进行测试就是十分关键的。</p>
<p>应该设计测试方案用来发现由于错误的计算、不正确的比较或不适当的控制流而造成的错误。</p></li>
<li><p><strong>出错处理通路</strong></p></li>
<li><p><strong>边界条件</strong><br />
使用刚好小于、刚好等于和刚好大于最大值或最小值的数据结构、控制量和数据值的测试方案，非常可能发现软件中的错误。</p></li>
</ol>
<h3 id="代码审查">7.3.2 代码审查</h3>
<h3 id="计算机测试">7.3.3 计算机测试</h3>
<p>模块并不是一个独立的程序，因此必须为每个单元测试开发驱动软件和（或）存根软件。</p>
<ol type="1">
<li><p><strong>驱动程序</strong><br />
通常驱动程序也就是一个“主程序”，它接收测试数据，把这些数据<strong>传送给被测试的模块</strong>，并且印出有关的结果。</p></li>
<li><p><strong>存根程序</strong><br />
存根程序代替被测试的模块所调用的模块。因此存根程序也可以称为“虚拟子程序”。它使用<strong>被它代替的模块的接口</strong>，可能做最少量的数据操作，印出对入口的检验或操作结果，并且把控制归还给调用它的模块。</p></li>
</ol>
<h2 id="集成测试">7.4 集成测试</h2>
<h3 id="模块组装成程序的方法">7.4.1 模块组装成程序的方法</h3>
<ol type="1">
<li><p><strong>非渐增式测试</strong><br />
一种方法是先<strong>分别测试每个模块</strong>，再把所有模块按设计要求放在一起结合成所要的程序。<br />
<img src="/image/icon/loading.gif" data-original="/image/26-1-4-2-SoftEng-7-real/1767511695289.webp" alt="1767511695289" /></p></li>
<li><p><strong>渐增式测试</strong><br />
另一种方法是把<strong>下一个要测试的模块</strong>同<strong>已经测试好的那些模块</strong>结合起来进行测试，测试完以后再把下一个应该测试的模块结合进来测试。这种每次增加一个模块的方法称为渐增式测试，这种方法实际上<strong>同时完成单元测试和集成测试</strong>。<br />
<img src="/image/icon/loading.gif" data-original="/image/26-1-4-2-SoftEng-7-real/1767511760037.webp" alt="1767511760037" /></p></li>
</ol>
<p>目前在进行集成测试时普遍采用渐增式测试方法。</p>
<ol start="3" type="1">
<li><strong>渐增方式的集成策略</strong>
<ul>
<li>自顶向下：从主控制模块开始，沿着程序的控制层次向下移动，逐渐把各个模块结合起来。不需要驱动程序。
<ul>
<li>深度优先：先组装在软件结构的一条主控制通路上的所有模块。</li>
<li>广度优先：沿软件结构水平地移动，把处于同一个控制层次上的所有模块组装起来。</li>
</ul></li>
<li>自底向上：从“叶子”模块（即在软件结构最低层的模块）开始组装和测试。<strong>不需要存根程序。</strong></li>
</ul></li>
</ol>
<h3 id="自底向上的结合策略">7.4.2 自底向上的结合策略</h3>
<ol type="1">
<li><p>把低层模块组合成实现某个特定的子功能的族；</p></li>
<li><p>写一个驱动程序，协调测试数据的输入和输出；</p></li>
<li><p>对由模块组成的子功能族进行测试；</p></li>
<li><p>去掉驱动程序，沿软件结构自下向上移动，把子功能族组合起来形成更大的子功能族。</p></li>
<li><p>重复第 1 到第 4 步。</p></li>
</ol>
<figure>
<img src="/image/icon/loading.gif" data-original="/image/26-1-4-2-SoftEng-7-real/1767512185358.webp" alt="1767512185358" />
<figcaption aria-hidden="true">1767512185358</figcaption>
</figure>
<h3 id="不同集成测试策略的比较">7.4.3 不同集成测试策略的比较</h3>
<ol type="1">
<li><p><strong>自顶向下测试方法</strong></p>
<ul>
<li>优点：不需要测试驱动程序，能够在测试阶段的早期实现并验证系统主要功能，发现上层模块接口错误。</li>
<li>缺点：需要<strong>存根程序</strong>，低层关键模块中的错误发现较晚，不能充分展开人力。</li>
</ul></li>
<li><p><strong>自底向上测试方法的优缺点</strong><br />
优缺点与自顶向下测试方法相反。</p></li>
<li><p><strong>混合策略</strong></p>
<ul>
<li>1
<ul>
<li>主要使用自顶向下的测试方法</li>
<li>早期使用自底向上的方法测试软件中的少数关键模块。</li>
</ul></li>
<li>2
<ul>
<li>较上层使用自顶向下</li>
<li>较下层使用自底向上</li>
</ul></li>
</ul></li>
</ol>
<h3 id="回归测试">7.4.4 回归测试</h3>
<ol type="1">
<li><p><strong>定义</strong><br />
回归测试是指<strong>重新执行</strong>已经做过的测试的某个子集（<strong>回归测试集</strong>），以保证上述这些变化<strong>没有带来非预期的副作用</strong>。</p></li>
<li><p><strong>方法</strong></p>
<ul>
<li>通过重新执行全部测试用例的一个子集人工地进行</li>
<li>也可以使用自动化的捕获回放工具自动进行。</li>
</ul></li>
<li><p><strong>回归测试集种类</strong></p>
<ul>
<li>检测软件全部功能的代表性测试用例；</li>
<li>专门针对可能受修改影响的软件功能的附加测试；</li>
<li>针对被修改过的软件成分的测试。</li>
</ul></li>
</ol>
<h2 id="确认测试">7.5 确认测试</h2>
<h3 id="定义">7.5.1 定义</h3>
<p>确认测试也称为验收测试，它的目标是<strong>验证软件的有效性</strong>。</p>
<h3 id="过程">7.5.2 过程</h3>
<figure>
<img src="/image/icon/loading.gif" data-original="/image/26-1-4-2-SoftEng-7-real/1767512630095.webp" alt="1767512630095" />
<figcaption aria-hidden="true">1767512630095</figcaption>
</figure>
<h3 id="alpha-测试和-beta-测试">Alpha 测试和 Beta 测试</h3>
<ol type="1">
<li><p><strong>Alpha 测试</strong><br />
Alpha 测试由用户在<strong>开发者的场所</strong>进行，并且在开发者对用户的“指导”下进行测试。开发者负责记录发现的错误和使用中遇到的问题。总之，Alpha 测试是在<strong>受控的</strong>环境中进行的。</p></li>
<li><p><strong>Beta 测试</strong><br />
Beta测试由软件的最终用户们在一个或多个<strong>客户场所</strong>进行。Beta 测试是软件在开发者不能控制的环境中的“真实”应用。</p></li>
</ol>
<h2 id="白盒测试技术">7.6 白盒测试技术</h2>
<h3 id="逻辑覆盖">7.6.1 逻辑覆盖</h3>
<p>有选择地执行程序中某些最有代表性的通路是对穷尽测试的惟一可行的替代办法。逻辑覆盖是对<strong>一系列测试过程的总称</strong>，这组测试过程逐渐进行<strong>越来越完整的通路测试</strong>。</p>
<ol type="1">
<li><p><strong>语句覆盖</strong><br />
选择足够多的测试数据，使被测程序中每个语句<strong>至少执行一次</strong>。</p></li>
<li><p><strong>判定覆盖</strong><br />
又称<strong>分支覆盖</strong>，不仅每个语句必须至少执行一次，而且<strong>每个判定的每种可能的结果</strong>都应该<strong>至少执行一次</strong>。</p></li>
<li><p><strong>条件覆盖</strong><br />
不仅每个语句至少执行一次，而且使判定表达式中的<strong>每个条件</strong>都取到<strong>各种可能的结果</strong>。</p></li>
<li><p><strong>判定/条件覆盖</strong><br />
同时满足这两种覆盖标准的逻辑覆盖。选取足够多的测试数据，使得判定表达式中的每个条件都取到各种可能的值，而且每个判定表达式也都取到各种可能的结果。</p>
<blockquote>
<p>有时判定/条件覆盖也并不比条件覆盖更强。</p>
</blockquote></li>
<li><p><strong>条件去组合覆盖</strong><br />
选取足够多的测试数据，使得<strong>每个判定表达式中条件</strong>的<strong>各种可能组合</strong>都至少出现一次。但是，满足条件组合覆盖标准的测试数据并不一定能使程序中的<strong>每条路径</strong>都执行到。</p></li>
<li><p><strong>点覆盖</strong><br />
选取足够多的测试数据，使得程序执行路径至少经过<strong>流图</strong>的每个结点一次。<strong>点覆盖标准和语句覆盖标准是相同的。</strong></p></li>
<li><p><strong>边覆盖</strong><br />
选取足够多测试数据，使得程序执行路径至少经过<strong>流图</strong>中每条边一次。<strong>边覆盖和判定覆盖是一致的。</strong></p></li>
<li><p><strong>路径覆盖</strong><br />
选取足够多测试数据，使程序的<strong>每条可能路径</strong>都至少执行一次（如果程序图中有环，则要求<strong>每个环</strong>至少经过一次）。</p></li>
</ol>
<h3 id="控制结构测试">7.6.2 控制结构测试</h3>
<ol type="1">
<li><p><strong>基本路径测试</strong><br />
至少引入程序的一个新处理语句集合或一个新条件的路径，用流图术语描述，独立路径至少包含一条在定义该路径之前<strong>不曾用过的边</strong>。<br />
<img src="/image/icon/loading.gif" data-original="/image/26-1-4-2-SoftEng-7-real/1767513445244.webp" alt="1767513445244" /></p>
<ul>
<li>首先计算程序的<strong>环形复杂度</strong>，</li>
<li>用该复杂度为指南定义<strong>执行路径的基本集合</strong>，</li>
<li>从该基本集合导出的测试用例可以保证<strong>程序中的每条语句至少执行一次</strong>，而且<strong>每个条件在执行时都将分别取真、假两种值</strong>。</li>
</ul></li>
<li><p><strong>独立路径</strong><br />
至少引入程序的一个新处理语句集合或一个新条件的路径，用流图术语描述，独立路径至少包含一条在定义该路径之前不曾用过的边。</p>
<p>使用基本路径测试法设计测试用例时，<strong>程序的环形复杂度决定了程序中独立路径的数量</strong>，而且这个数是确保程序中<strong>所有语句至少被执行一次所需的测试数量的上界</strong>。</p></li>
<li><p><strong>条件测试</strong></p>
<ul>
<li><p><strong>分支测试</strong><br />
对于复合条件 C 来说，C 的<strong>真分支</strong>和<strong>假分支</strong>以及 C 中的<strong>每个简单条件</strong>，都应该<strong>至少执行一次</strong>。</p></li>
<li><p><strong>域测试</strong><br />
要求对一个关系表达式执行 3 个或 4 个测试。</p></li>
<li><p><strong>布尔表达式测试（穷举法）</strong><br />
包含 <span class="math inline">\(n\)</span> 个变量的布尔表达式需要 <span class="math inline">\(2^n\)</span> 个（每个变量分别取真或假这两个可能值的组合数）测试。这个策略可以发现布尔算符、变量和括弧的错误，但是，该策略仅在 <span class="math inline">\(n\)</span> 很小时才是实用的。</p></li>
<li><p><strong>BRO（Branch and Rational Operator）测试</strong></p></li>
</ul></li>
<li><p><strong>循环测试</strong></p></li>
</ol>
<h2 id="黑盒测试技术">7.7 黑盒测试技术</h2>
<h3 id="等价划分">7.7.1 等价划分</h3>
<p>把程序的输入域划分成<strong>若干个数据类</strong>，据此导出测试用例。一个理想的测试用例能<strong>独自发现一类错误</strong>。</p>
<h3 id="边界值分析">7.7.2 边界值分析</h3>
<p>通常输入等价类和输出等价类的边界，就是应该着重测试的程序边界情况。</p>
<p>选取的测试数据应该刚好等于、刚刚小于和刚刚大于边界值。</p>
<h3 id="错误推测">7.7.3 错误推测</h3>
<p>错误推测法在很大程度上靠直觉和经验进行。它的基本想法是列举出程序中可能有的错误和容易发生错误的特殊情况，并且根据它们选择测试方案。</p>
<h2 id="调试">7.8 调试</h2>
<h3 id="调试过程">7.8.1 调试过程</h3>
<p>调试（也称为纠错）作为成功测试的后果出现，也就是说，调试是在测试<strong>发现错误之后排除错误</strong>的过程。</p>
<h3 id="调试途径">7.8.2 调试途径</h3>
<ol type="1">
<li><p><strong>蛮干法</strong><br />
大量打印信息。</p></li>
<li><p><strong>回溯法</strong><br />
从发现症状的地方开始，人工<strong>沿程序的控制流</strong>往回追踪分析源程序代码，直到找出错误原因为止。</p></li>
<li><p><strong>原因排除法</strong></p>
<ul>
<li><p>对分查找法：如果已经知道每个变量在程序内若干个关键点的正确值，则可以用赋值语句或输入语句在程序中点附近“<strong>注入</strong>”<strong>这些变量的正确值</strong>，然后运行程序并检查所得到的输出。如果输出结果是正确的，则错误原因在程序的前半部分；反之，错误原因在程序的后半部分。</p></li>
<li><p>归纳法：首先把和错误有关的数据组织起来进行分析，以便发现可能的错误原因。然后导出对错误原因的<strong>一个或多个假设</strong>，并利用已有的数据来证明或排除这些假设。</p></li>
<li><p>演绎法：首先设想出<strong>所有可能的出错原因</strong>，然后试图用测试来排除每一个假设的原因。如果测试表明某个假设的原因可能是真的原因，则对数据进行<strong>细化</strong>以准确定位错误。</p></li>
</ul></li>
</ol>
<h2 id="软件可靠性">7.9 软件可靠性</h2>
<h3 id="定义-1">7.9.1 定义</h3>
<ol type="1">
<li><p><strong>定义</strong><br />
软件可靠性是程序在<strong>给定的时间间隔内</strong>，按照规格说明书的规定<strong>成功地运行</strong>的概率。</p></li>
<li><p><strong>软件的可用性</strong><br />
软件可用性是程序在<strong>给定的时间点</strong>，按照规格说明书的规定，成功地运行的概率。</p></li>
</ol>
<h3 id="估算平均无故障时间-mttf-的方法">7.9.2 估算平均无故障时间 MTTF 的方法</h3>
<ol type="1">
<li><p><strong>公式</strong><br />
在估算 MTTF 的过程中使用下述符号表示有关的数量：</p>
<ul>
<li><span class="math inline">\(E_T\)</span>——测试之前程序中错误总数；</li>
<li><span class="math inline">\(I_T\)</span>——程序长度（机器指令总数）；</li>
<li><span class="math inline">\(\tau\)</span>——测试（包括调试）时间；</li>
<li><span class="math inline">\(E_d(\tau)\)</span>——在 0 至 <span class="math inline">\(\tau\)</span> 期间发现的错误数；</li>
<li><span class="math inline">\(E_c(\tau)\)</span>——在 0 至 <span class="math inline">\(\tau\)</span> 期间改正的错误数。</li>
</ul>
<p><span class="math display">\[
MTTF = \frac{1}{K(\frac{E_T}{I_T} - \frac{E_c(\tau)}{I_T})}
\]</span></p></li>
<li><p><strong>基本假定</strong><br />
通常<br />
<span class="math display">\[
-0.5 \times 10^{-2} \leq \frac{E_T}{I_T} \leq 2 \times 10^{-2}
\]</span></p>
<p>也就是说，在测试之前每 1000 条指令中大约有 5～20 个错误。</p></li>
<li><p><strong>估算平均无故障时间</strong><br />
一般取 <span class="math inline">\(K = 200\)</span>.<br />
<span class="math display">\[
E_c = E_T - \frac{I_T}{K \cdot MTTF}
\]</span></p></li>
<li><p><strong>估计错误总数的方法</strong></p>
<ul>
<li>植入错误法：在测试之前由专人在程序中随机地植入一些错误，测试之后，根据测试小组发现的错误中原有的和植入的两种错误的比例，来估计程序中原有错误的总数 <span class="math inline">\(E_T\)</span>。</li>
<li>分别测试法：随机地把程序中一部分原有的错误加上标记，根据测试过程中发现的有标记错误和无标记错误的比例，估计程序中的错误总数。</li>
</ul></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://remy-campanella.github.io">Remy Campanella</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://remy-campanella.github.io/2026/01/04/26-1-4-2-SoftEng-7-real/">https://remy-campanella.github.io/2026/01/04/26-1-4-2-SoftEng-7-real/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://remy-campanella.github.io" target="_blank">remy-campanella.github.io</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><a class="post-meta__tags" href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/">软件工程</a></div><div class="post-share"><div class="social-share" data-image="/image/background/remy.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://unpkg.com/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://unpkg.com/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2026/01/04/25-10-22-1-SoftEng-6-detailed-design/" title="【软件工程学习】 第六章 详细设计"><img class="cover" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">【软件工程学习】 第六章 详细设计</div></div><div class="info-2"><div class="info-item-1">6.1 结构程序设计 6.1.1 程序结构设计概念  程序结构设计概念的提出 1966 年 Böhm 和 Jacopini 证明，使用“顺序”、“选择”、“循环”可实现单入口单出口的程序。实际上“顺序”与“循环”可以实现“选择”，故使用“顺序”、“循环”可实现单入口单出口的程序。 结构程序设计定义 如果一个程序的代码块仅仅通过顺序、选择和循环这3种基本控制结构进行连接，并且每个代码块只有一个入口和一个出口，则称这个程序是结构化的。 结构程序设计是尽可能少用 GO TO 语句的程序设计方法。最好仅在检测出错误时才使用 GO TO 语句，而且应该总是使用前向 GO TO 语句。 结构程序设计的分类  如果只允许使用顺序、IF-THEN-ELSE 型分支和DO-WHILE 型循环这 3 种基本控制结构，则称为经典的结构程序设计。 如果除了上述 3 种基本控制结构之外，还允许使用 DO-CASE 型多分支结构和 DO-UNTIL 型循环结构，则称为扩展的结构程序设计。 如果再允许使用 LEAVE（或 BREAK）结构，则称为修正的结构程序设计。   6.2....</div></div></div></a><a class="pagination-related" href="/2026/01/05/25-11-11-1-CompOrg-6-cpu/" title="【计算机组成原理】 第六章 中央处理器"><img class="cover" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">【计算机组成原理】 第六章 中央处理器</div></div><div class="info-2"><div class="info-item-1">6.1 中央处理器的功能和组成 6.1.1 CPU 的功能 程序运行过程中，在计算机的各部分之间流动的指令和数据形成指令流和数据流。  指令流：CPU 的指令序列。 数据流：根据指令操作要求依次存取的数据的序列。  6.1.2 CPU 中的主要寄存器  通用寄存器  累加寄存器（Acc） Acc 用于暂时存放 ALU 运算的结果信息。  专用寄存器  程序计数器（PC）  顺序执行时，PC 内容每次自增（自动或运算器实现）。 改变执行顺序时，将转移的目标地址送往寄存器。有时还要保留改变前的内容，以便返回时使用。  指令寄存器（IR） 存放从存储器中取出的指令。 执行指令时，IR 内容不可变。 存储器数据寄存器（MDR） 暂存由主存储器读出（或将写入主存）的一条指令或数据字。 存储器地址寄存器（MAR） 当前 CPU 访问的主存单元地址。CPU 与主存有速度差别，MAR 可用于调和速度差异。 程序状态字寄存器（状态标志寄存器，PSWR） 存放程序状态字（PSR）。PSR 的位数往往等于机器字长。   6.1.3 CPU...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/10/15/25-10-15-1-SoftEng-1-intro/" title="【软件工程学习】 第一章 软件工程概述"><img class="cover" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-15</div><div class="info-item-2">【软件工程学习】 第一章 软件工程概述</div></div><div class="info-2"><div class="info-item-1">一、软件工程的价值与应用场景  实际用途  国家考试（如软考）、工作面试（如亚麻面试）、毕业设计、读研。 参与需求分析、撰写需求/设计报告、招标书/投标书、项目申请书。 开发原型（需掌握原型工具）、开发软件（需学习开发框架）。 绘制模型图/流程图、AI开发APP等。  工作场景  文档撰写、模型设计、原型开发、前后端分离开发、系统设计等。   二、软件工程学科与教材分析  经典教材  《Software Engineering: A Practitioner’s Approach》（2020年）：涵盖软件过程、建模、质量、项目管理等。 《软件工程导论》（2013年）：传统生命周期与面向对象方法。 《面向对象软件工程：敏捷统一方法》（2014/2023年）：强调领域建模、架构设计、交互建模等。 《软件工程：谷歌的实践》（2022年）：聚焦文化、流程、工具（如代码评审、CI/CD）。  学科演变  从传统软件工程→面向对象→敏捷开发→系统工程。 新趋势：低代码、AI开发、产品化（从Project到Product）。   三、软...</div></div></div></a><a class="pagination-related" href="/2025/10/15/25-10-15-2-SoftEng-2-feasibility/" title="【软件工程学习】 第二章 可行性研究"><img class="cover" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-15</div><div class="info-item-2">【软件工程学习】 第二章 可行性研究</div></div><div class="info-2"><div class="info-item-1">2.1 可行性研究的任务  任务 并非任何问题都有简单明显的解决办法。如果问题没有可行的解，那么花费在这项工程上的任何时间、人力、软硬件资源和经费，都是无谓的浪费。可行性研究的目的，就是用最小的代价在尽可能短的时间内确定问题是否能够解决。 分析过程  分析和澄清问题定义。 导出系统逻辑模型。 探索若干种可选的主要解法。   2.2 可行性研究过程        步骤      复查系统规模和目标 实质上是为了确保分析员正在解决的问题确实是要求他解决的问题。   研究目前正在使用的系统 新系统必须要完成旧系统的基本功能；新系统必须要解决旧系统的问题。   导出新系统的高层逻辑模型 参考现有系统的逻辑模型，设想目标系统的逻辑模型，最后根据目标系统的逻辑模型建造新的物理系统。   进一步定义问题 在之前的基础上再次定义问题，构成循环，直到提出的逻辑模型完全符合系统目标。   导出和评价供选择的解法 为每个解法考虑操作、经济方面的可行性，制定实现进度表。   推荐行动方针    草拟开发计划...</div></div></div></a><a class="pagination-related" href="/2026/01/04/25-10-22-1-SoftEng-6-detailed-design/" title="【软件工程学习】 第六章 详细设计"><img class="cover" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-04</div><div class="info-item-2">【软件工程学习】 第六章 详细设计</div></div><div class="info-2"><div class="info-item-1">6.1 结构程序设计 6.1.1 程序结构设计概念  程序结构设计概念的提出 1966 年 Böhm 和 Jacopini 证明，使用“顺序”、“选择”、“循环”可实现单入口单出口的程序。实际上“顺序”与“循环”可以实现“选择”，故使用“顺序”、“循环”可实现单入口单出口的程序。 结构程序设计定义 如果一个程序的代码块仅仅通过顺序、选择和循环这3种基本控制结构进行连接，并且每个代码块只有一个入口和一个出口，则称这个程序是结构化的。 结构程序设计是尽可能少用 GO TO 语句的程序设计方法。最好仅在检测出错误时才使用 GO TO 语句，而且应该总是使用前向 GO TO 语句。 结构程序设计的分类  如果只允许使用顺序、IF-THEN-ELSE 型分支和DO-WHILE 型循环这 3 种基本控制结构，则称为经典的结构程序设计。 如果除了上述 3 种基本控制结构之外，还允许使用 DO-CASE 型多分支结构和 DO-UNTIL 型循环结构，则称为扩展的结构程序设计。 如果再允许使用 LEAVE（或 BREAK）结构，则称为修正的结构程序设计。   6.2....</div></div></div></a><a class="pagination-related" href="/2026/01/02/25-12-3-1-SoftEng-3-demand-aly/" title="【软件工程学习】 第三章 需求分析"><img class="cover" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-02</div><div class="info-item-2">【软件工程学习】 第三章 需求分析</div></div><div class="info-2"><div class="info-item-1">需求分析是软件定义时期的最后一个阶段，它的基本任务是准确地回答“系统必须做什么”这个问题。 3.1 需求分析的任务 3.1.1 确定对系统的综合要求 通常对软件系统有下述几方面的综合要求。  功能需求 指定系统必须提供的服务。 性能需求 指定系统必须满足的定时约束或容量约束。 可靠性和可用性需求 定量地指定系统的可靠性。可用性与可靠性密切相关，它量化了用户可以使用系统的程度。 出错处理需求 系统对环境错误应该怎样响应。 接口需求 应用系统与它的环境通信的格式。 约束 在设计或实现应用系统时应遵守的限制条件。 逆向需求 软件系统不应该做什么。 将来可能提出的要求 虽然不属于当前系统开发范畴，但是据分析将来很可能会提出来的要求。  3.1.2 分析系统的数据要求 任何一个软件系统本质上都是信息处理系统，系统必须处理的信息和系统应该产生的信息在很大程度上决定了系统的面貌，对软件设计有深远影响。 复杂的数据由许多基本的数据元素组成，数据结构表示数据元素之间的逻辑关系。利用数据字典可以全面准确地定义数据，但是数据字典的缺点是不够形象直观。为了...</div></div></div></a><a class="pagination-related" href="/2026/01/04/26-1-4-1-SoftEng-5-general-dgn/" title="【软件工程学习】 第五章 总体设计"><img class="cover" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-04</div><div class="info-item-2">【软件工程学习】 第五章 总体设计</div></div><div class="info-2"><div class="info-item-1">一、 总体设计概述  定义与目的：  总体设计（又称概要设计或初步设计）的基本目的是回答“概括地说，系统应该如何实现”这个问题。 核心任务是设计软件结构，确定系统由哪些模块组成以及模块间的关系。  设计过程：  包含两个阶段：系统设计（从技术角度考虑最佳方案）和结构设计（确定程序结构）。 典型步骤包括：设想供选择的方案、选取合理方案、推荐最佳方案、功能分解、设计软件结构、设计数据库、制定测试计划、书写文档、审查和复审。 ### 二、 设计原理  模块化：  模块是由边界元素限定的程序元素序列（如过程、函数、对象）。模块化是将系统划分为独立命名的模块。 虽然增加模块数量可以降低单个模块成本，但会增加接口成本，因此存在一个使总成本最小的最佳模块数目。 优势：结构清晰、易于理解、测试调试方便、提高可靠性和可修改性、便于组织管理。  抽象：  抽象是抽出事物的本质特性而忽略细节。软件工程的每一步都是对解法抽象层次的精化。  逐步求精：  为了集中精力解决主要问题，尽量推迟对细节的考虑。这是自顶向下的设计策略，与模块化紧密相关。  信息...</div></div></div></a><a class="pagination-related" href="/2025/10/15/25-10-14-3-CompOrg-3-command-system/" title="【计算机组成原理】 第三章 指令系统"><img class="cover" src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-15</div><div class="info-item-2">【计算机组成原理】 第三章 指令系统</div></div><div class="info-2"><div class="info-item-1">3.1 指令格式  基本格式 | | | | — | — | | 操作码字段 | 地址码字段 | 地址码结构 对于一般的双操作数运算指令，除去操作码（Operation Code），还包含  第一操作数地址 \(A_1\)， 第二操作数地址 \(A_2\)， 操作结果存放地址 \(A_3\)， 下一条指令地址 \(A_4\)。  指令结构  四地址指令  含义：\((A_1) OP (A_2) \rightarrow A_3\) 直观，但太长，不实际。  三地址指令  含义：\((A_1) OP (A_2) \rightarrow A_3\)，\((PC) + 1 \rightarrow PC\) 每执行一条指令，程序计数器（PC） 自增。 仍然较长，在大、中型计算机使用。 适用于向量、矩阵运算。  二地址指令  含义：\((A_1) OP (A_2) \rightarrow A_1\)，\(\rm (PC) + 1 \rightarrow PC\) \(A_1\) 为目的操作数地址，\(A_2\)为源操作数地址。\(...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/image/icon/loading.gif" data-original="/image/icon/Cover.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Remy Campanella</div><div class="author-info-description">A Remy Campanella blog website on Github.</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">70</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/remy-campanella"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站介绍帖、自我介绍帖内容已移至“关于”页面，目录帖内容已移至“分类”页面。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A0%81"><span class="toc-number">1.</span> <span class="toc-text">7.1 编码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">7.1.1 选择程序设计语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC"><span class="toc-number">1.2.</span> <span class="toc-text">7.1.2 编码风格</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80"><span class="toc-number">2.</span> <span class="toc-text">7.2 软件测试基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-number">2.1.</span> <span class="toc-text">7.2.1 软件测试的目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%87%86%E5%88%99"><span class="toc-number">2.2.</span> <span class="toc-text">7.2.2 软件测试准则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">7.2.3 测试方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.4.</span> <span class="toc-text">7.2.4 测试步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E9%98%B6%E6%AE%B5%E7%9A%84%E4%BF%A1%E6%81%AF%E6%B5%81"><span class="toc-number">2.5.</span> <span class="toc-text">7.2.5 测试阶段的信息流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">3.</span> <span class="toc-text">7.3 单元测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E9%87%8D%E7%82%B9"><span class="toc-number">3.1.</span> <span class="toc-text">7.3.1 测试重点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5"><span class="toc-number">3.2.</span> <span class="toc-text">7.3.2 代码审查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%B5%8B%E8%AF%95"><span class="toc-number">3.3.</span> <span class="toc-text">7.3.3 计算机测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95"><span class="toc-number">4.</span> <span class="toc-text">7.4 集成测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E7%BB%84%E8%A3%85%E6%88%90%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.</span> <span class="toc-text">7.4.1 模块组装成程序的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E7%BB%93%E5%90%88%E7%AD%96%E7%95%A5"><span class="toc-number">4.2.</span> <span class="toc-text">7.4.2 自底向上的结合策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E7%AD%96%E7%95%A5%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">4.3.</span> <span class="toc-text">7.4.3 不同集成测试策略的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E5%BD%92%E6%B5%8B%E8%AF%95"><span class="toc-number">4.4.</span> <span class="toc-text">7.4.4 回归测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AE%E8%AE%A4%E6%B5%8B%E8%AF%95"><span class="toc-number">5.</span> <span class="toc-text">7.5 确认测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">5.1.</span> <span class="toc-text">7.5.1 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B"><span class="toc-number">5.2.</span> <span class="toc-text">7.5.2 过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#alpha-%E6%B5%8B%E8%AF%95%E5%92%8C-beta-%E6%B5%8B%E8%AF%95"><span class="toc-number">5.3.</span> <span class="toc-text">Alpha 测试和 Beta 测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF"><span class="toc-number">6.</span> <span class="toc-text">7.6 白盒测试技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%A6%86%E7%9B%96"><span class="toc-number">6.1.</span> <span class="toc-text">7.6.1 逻辑覆盖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84%E6%B5%8B%E8%AF%95"><span class="toc-number">6.2.</span> <span class="toc-text">7.6.2 控制结构测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF"><span class="toc-number">7.</span> <span class="toc-text">7.7 黑盒测试技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E4%BB%B7%E5%88%92%E5%88%86"><span class="toc-number">7.1.</span> <span class="toc-text">7.7.1 等价划分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%B9%E7%95%8C%E5%80%BC%E5%88%86%E6%9E%90"><span class="toc-number">7.2.</span> <span class="toc-text">7.7.2 边界值分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E6%8E%A8%E6%B5%8B"><span class="toc-number">7.3.</span> <span class="toc-text">7.7.3 错误推测</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E8%AF%95"><span class="toc-number">8.</span> <span class="toc-text">7.8 调试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E8%BF%87%E7%A8%8B"><span class="toc-number">8.1.</span> <span class="toc-text">7.8.1 调试过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E9%80%94%E5%BE%84"><span class="toc-number">8.2.</span> <span class="toc-text">7.8.2 调试途径</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-number">9.</span> <span class="toc-text">7.9 软件可靠性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-number">9.1.</span> <span class="toc-text">7.9.1 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%B0%E7%AE%97%E5%B9%B3%E5%9D%87%E6%97%A0%E6%95%85%E9%9A%9C%E6%97%B6%E9%97%B4-mttf-%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">9.2.</span> <span class="toc-text">7.9.2 估算平均无故障时间 MTTF 的方法</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2026/01/05/25-12-16-1-CompOrg-10-review/" title="【计算机组成原理】 复习要点"><img src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【计算机组成原理】 复习要点"/></a><div class="content"><a class="title" href="/2026/01/05/25-12-16-1-CompOrg-10-review/" title="【计算机组成原理】 复习要点">【计算机组成原理】 复习要点</a><time datetime="2026-01-05T03:05:13.000Z" title="发表于 2026-01-05 11:05:13">2026-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/05/25-12-2-2-CompOrg-9-io-sys/" title="【计算机组成原理】 第九章 输入输出系统"><img src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【计算机组成原理】 第九章 输入输出系统"/></a><div class="content"><a class="title" href="/2026/01/05/25-12-2-2-CompOrg-9-io-sys/" title="【计算机组成原理】 第九章 输入输出系统">【计算机组成原理】 第九章 输入输出系统</a><time datetime="2026-01-05T03:03:19.257Z" title="发表于 2026-01-05 11:03:19">2026-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/05/25-12-2-2-CompOrg-8-ext-device/" title="【计算机组成原理】 第八章 外部设备"><img src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【计算机组成原理】 第八章 外部设备"/></a><div class="content"><a class="title" href="/2026/01/05/25-12-2-2-CompOrg-8-ext-device/" title="【计算机组成原理】 第八章 外部设备">【计算机组成原理】 第八章 外部设备</a><time datetime="2026-01-05T02:47:29.000Z" title="发表于 2026-01-05 10:47:29">2026-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/05/25-11-25-1-CompOrg-7-bus/" title="【计算机组成原理】 第七章 总线"><img src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【计算机组成原理】 第七章 总线"/></a><div class="content"><a class="title" href="/2026/01/05/25-11-25-1-CompOrg-7-bus/" title="【计算机组成原理】 第七章 总线">【计算机组成原理】 第七章 总线</a><time datetime="2026-01-05T02:47:06.000Z" title="发表于 2026-01-05 10:47:06">2026-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/05/25-11-11-1-CompOrg-6-cpu/" title="【计算机组成原理】 第六章 中央处理器"><img src="/image/icon/loading.gif" data-original="/image/background/remy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【计算机组成原理】 第六章 中央处理器"/></a><div class="content"><a class="title" href="/2026/01/05/25-11-11-1-CompOrg-6-cpu/" title="【计算机组成原理】 第六章 中央处理器">【计算机组成原理】 第六章 中央处理器</a><time datetime="2026-01-05T02:46:54.000Z" title="发表于 2026-01-05 10:46:54">2026-01-05</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By Remy Campanella</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.0</a></span></div><div class="footer_custom_text">源代码库版本 1.4.0</div></div><script type="text/javascript" id="maid-script" src="https://unpkg.com/mermaid@9.0.0/dist/mermaid.min.js"></script><script>if (window.mermaid) {
  var options = JSON.parse(document.getElementById('maid-script').getAttribute('mermaidoptioins'));
  mermaid.initialize(options);
}</script></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        loader: {
          load: [
            // Four font extension packages (optional)
            //- '[tex]/bbm',
            //- '[tex]/bboldx',
            //- '[tex]/dsfont',
            '[tex]/mhchem'
          ],
          paths: {
            'mathjax-newcm': '[mathjax]/../@mathjax/mathjax-newcm-font',

            //- // Four font extension packages (optional)
            //- 'mathjax-bbm-extension': '[mathjax]/../@mathjax/mathjax-bbm-font-extension',
            //- 'mathjax-bboldx-extension': '[mathjax]/../@mathjax/mathjax-bboldx-font-extension',
            //- 'mathjax-dsfont-extension': '[mathjax]/../@mathjax/mathjax-dsfont-font-extension',
            'mathjax-mhchem-extension': '[mathjax]/../@mathjax/mathjax-mhchem-font-extension'
          }
        },
        output: {
          font: 'mathjax-newcm',
        },
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
          packages: {
            '[+]': [
              'mhchem'
            ]
          }
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          menuOptions: {
            settings: {
              enrich: false  // Turn off Braille and voice narration text automatic generation
            }
          },
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://unpkg.com/mathjax@4.0.0/tex-mml-chtml.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://unpkg.com/mermaid@11.11.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start -->
    <script src="/js/gallery.js" async></script>
<!-- hexo injector body_end end -->
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 2,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>